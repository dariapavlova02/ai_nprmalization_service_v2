<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="202" skipped="15" tests="1833" time="425.504" timestamp="2025-09-15T21:42:27.520191+02:00" hostname="MacBook-Pro-Dara.local"><testcase classname="tests.e2e.test_full_pipeline_risk.TestFullPipelineRiskE2E" name="test_full_pipeline_high_risk_scenario" time="0.004" /><testcase classname="tests.e2e.test_full_pipeline_risk.TestFullPipelineRiskE2E" name="test_decision_engine_integration_with_mock_data" time="0.003" /><testcase classname="tests.e2e.test_full_pipeline_risk.TestFullPipelineRiskE2E" name="test_api_response_format_with_risk_fields" time="0.005" /><testcase classname="tests.e2e.test_full_pipeline_risk.TestFullPipelineRiskE2E" name="test_pipeline_with_different_risk_levels" time="0.002" /><testcase classname="tests.e2e.test_full_pipeline_risk.TestFullPipelineRiskE2E" name="test_pipeline_error_handling" time="0.002" /><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_nightmare_scenario_gnatyuk_abdullaev" time="0.002" /><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_multilingual_nightmare" time="0.001" /><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_corrupted_encoding_nightmare" time="0.002"><failure message="AssertionError: Should recover Sergii variants from corrupted text 0&#10;assert False&#10; +  where False = any(&lt;generator object TestNightmareScenario.test_corrupted_encoding_nightmare.&lt;locals&gt;.&lt;genexpr&gt; at 0x16bb89700&gt;)">self = &lt;tests.e2e.test_nightmare_scenario.TestNightmareScenario object at 0x13f80ba80&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x16bb69810&gt;

    async def test_corrupted_encoding_nightmare(self, orchestrator_service):
        """
        Corrupted encoding nightmare test:
        Simulating encoding problems during data transmission
        """
        # Arrange
        # Simulate various encoding problems
        corrupted_texts = [
            "Ð¡ÐµÑ€Ð³Ð¸Ð¹ Ð˜Ð²Ð°Ð½Ð¾Ð²",  # UTF-8 interpreted as Latin-1
            "СергÐ¸Ð¹ Иванов",  # Partially corrupted encoding
            "Sergii Ä°vanov",  # Mixed encodings
            "Сергій Іванов",  # Correct Ukrainian encoding for comparison
        ]
    
        # Act &amp; Assert
        for i, corrupted_text in enumerate(corrupted_texts):
            result = await orchestrator_service.process(
                text=corrupted_text,
                generate_variants=True,
                generate_embeddings=False
            )
    
            assert result.success is True, f"Failed to process corrupted text {i}: {corrupted_text}"
            assert len(result.variants) &gt; 0, f"No variants generated for corrupted text {i}"
    
            # Check that the system tries to recover the name
            all_variants_lower = ' '.join(result.variants).lower()
&gt;           assert any(name in all_variants_lower for name in ['sergii', 'sergey', 'сергий', 'сергій']), \
                f"Should recover Sergii variants from corrupted text {i}"
E           AssertionError: Should recover Sergii variants from corrupted text 0
E           assert False
E            +  where False = any(&lt;generator object TestNightmareScenario.test_corrupted_encoding_nightmare.&lt;locals&gt;.&lt;genexpr&gt; at 0x16bb89700&gt;)

tests/e2e/test_nightmare_scenario.py:149: AssertionError</failure></testcase><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_performance_nightmare" time="0.002"><failure message="AssertionError: Should generate many variants for complex text, got 12&#10;assert 12 &gt;= 50&#10; +  where 12 = len(['Gnatuk Abdulaeva Zhorzha Rashida', 'Gnatuk Abdulaev Zhorzha Rashid', 'Gnatuk Abdulaev Zhorzha Rashidovich', 'Gnatuk ...hidovich Freedom', 'Jean-Baptiste Müller Олександр Петренко-Сміт', 'Jean-Baptiste Muller Олександр Петренко-Сміт', ...])&#10; +    where ['Gnatuk Abdulaeva Zhorzha Rashida', 'Gnatuk Abdulaev Zhorzha Rashid', 'Gnatuk Abdulaev Zhorzha Rashidovich', 'Gnatuk ...hidovich Freedom', 'Jean-Baptiste Müller Олександр Петренко-Сміт', 'Jean-Baptiste Muller Олександр Петренко-Сміт', ...] = UnifiedProcessingResult(original_text='\n        В конференции участвовали: Jean-Baptiste Müller (Zürich), Олександр П...мит Zürcher Strasse'], embeddings=None, decision=None, processing_time=0.00015616416931152344, success=True, errors=[]).variants">self = &lt;tests.e2e.test_nightmare_scenario.TestNightmareScenario object at 0x13f80b950&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x16bb74fc0&gt;

    async def test_performance_nightmare(self, orchestrator_service):
        """
        Performance test for nightmare scenario:
        Large volume of complex text with many names
        """
        # Arrange
        complex_text = """
        В конференции участвовали: Jean-Baptiste Müller (Zürich), Олександр Петренко-Сміт (Київ),
        María José García-Rodríguez (Madrid), Владимир Александрович Иванов-Петров (Москва),
        O'Connor Patrick Michael (Dublin), Žofie Nováková-Svobodová (Praha),
        Αλέξανδρος Παπαδόπουλος (Athens), 山田太郎 (Tokyo), محمد عبد الله (Cairo),
        Андрій Васильович Коваленко-Шевченко (Львів), Giuseppe Di Marco-Rossi (Milano).
        Также присутствовали представители организаций 'Freedom &amp; Justice', "Human Rights Watch",
        'Врачи без границ', и фонда имени Андрея Сахарова.
        """
    
        # Act
        import time
        start_time = time.time()
    
        result = await orchestrator_service.process(
            text=complex_text,
            generate_variants=True,
            generate_embeddings=False
        )
    
        end_time = time.time()
        processing_time = end_time - start_time
    
        # Assert
        assert result.success is True, "Complex text processing should succeed"
        assert processing_time &lt; 30.0, f"Processing should complete within 30 seconds, took {processing_time:.2f}s"
&gt;       assert len(result.variants) &gt;= 50, f"Should generate many variants for complex text, got {len(result.variants)}"
E       AssertionError: Should generate many variants for complex text, got 12
E       assert 12 &gt;= 50
E        +  where 12 = len(['Gnatuk Abdulaeva Zhorzha Rashida', 'Gnatuk Abdulaev Zhorzha Rashid', 'Gnatuk Abdulaev Zhorzha Rashidovich', 'Gnatuk ...hidovich Freedom', 'Jean-Baptiste Müller Олександр Петренко-Сміт', 'Jean-Baptiste Muller Олександр Петренко-Сміт', ...])
E        +    where ['Gnatuk Abdulaeva Zhorzha Rashida', 'Gnatuk Abdulaev Zhorzha Rashid', 'Gnatuk Abdulaev Zhorzha Rashidovich', 'Gnatuk ...hidovich Freedom', 'Jean-Baptiste Müller Олександр Петренко-Сміт', 'Jean-Baptiste Muller Олександр Петренко-Сміт', ...] = UnifiedProcessingResult(original_text='\n        В конференции участвовали: Jean-Baptiste Müller (Zürich), Олександр П...мит Zürcher Strasse'], embeddings=None, decision=None, processing_time=0.00015616416931152344, success=True, errors=[]).variants

tests/e2e/test_nightmare_scenario.py:184: AssertionError</failure></testcase><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_edge_cases_nightmare" time="0.003"><failure message="AssertionError: assert ('   \t\n\r   ' == ''&#10;  &#10;  Strings contain only whitespace, escaping them using repr()&#10;  - ''&#10;  + '   \t\n\r   ' or 9 &lt;= 2)&#10; +  where 9 = len('   \t\n\r   ')&#10; +    where '   \t\n\r   ' = UnifiedProcessingResult(original_text='   \t\n\r   ', language='uk', language_confidence=0.9, normalized_text='   \t\n...Смит Zürcher Strasse'], embeddings=None, decision=None, processing_time=6.890296936035156e-05, success=True, errors=[]).normalized_text">self = &lt;tests.e2e.test_nightmare_scenario.TestNightmareScenario object at 0x13fa39010&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x16bb75ba0&gt;

    async def test_edge_cases_nightmare(self, orchestrator_service):
        """
        Edge cases test:
        Very short, very long, and strange input data
        """
        # Arrange
        edge_cases = [
            "",  # Empty string
            "A",  # Single letter
            "Я",  # Single Cyrillic letter
            "X" * 1000,  # Very long string
            "Ё" * 100,  # Repeated special characters
            "∑∂∆∞≈≠≤≥±",  # Mathematical symbols
            "#x1F3AD#x1F3A8#x1F3AA#x1F3AF#x1F3B2",  # Emojis
            "Тест\x00\x01\x02",  # Control characters
            "   \t\n\r   ",  # Only spaces
            "Сергій" + "\u200b" * 10 + "Іванов",  # Invisible characters
        ]
    
        # Act &amp; Assert
        for i, edge_case in enumerate(edge_cases):
            result = await orchestrator_service.process(
                text=edge_case,
                generate_variants=True,
                generate_embeddings=False
            )
    
            # Main check - should not crash
            assert result is not None, f"Edge case {i} returned None: '{repr(edge_case)}'"
            assert hasattr(result, 'success'), f"Edge case {i} missing success attribute"
    
            # For empty or meaningless input data
            if not edge_case.strip() or len(edge_case.strip()) &lt; 2:
&gt;               assert result.normalized_text == "" or len(result.normalized_text) &lt;= 2
E               AssertionError: assert ('   \t\n\r   ' == ''
E                 
E                 Strings contain only whitespace, escaping them using repr()
E                 - ''
E                 + '   \t\n\r   ' or 9 &lt;= 2)
E                +  where 9 = len('   \t\n\r   ')
E                +    where '   \t\n\r   ' = UnifiedProcessingResult(original_text='   \t\n\r   ', language='uk', language_confidence=0.9, normalized_text='   \t\n...Смит Zürcher Strasse'], embeddings=None, decision=None, processing_time=6.890296936035156e-05, success=True, errors=[]).normalized_text

tests/e2e/test_nightmare_scenario.py:248: AssertionError</failure></testcase><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_cache_effectiveness_nightmare" time="0.002"><failure message="TypeError: UnifiedOrchestrator.process() got an unexpected keyword argument 'cache_result'">self = &lt;tests.e2e.test_nightmare_scenario.TestNightmareScenario object at 0x13f8a99d0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x16baed130&gt;

    async def test_cache_effectiveness_nightmare(self, orchestrator_service):
        """
        Cache effectiveness test in nightmare scenarios
        """
        # Arrange
        test_text = "Олександр Петренко-Сміт встретил Jean-Baptiste Müller"
    
        # Act - first request (cache miss)
        import time
    
        start_time = time.time()
&gt;       result1 = await orchestrator_service.process(
            text=test_text,
            generate_variants=True,
            cache_result=True
        )
E       TypeError: UnifiedOrchestrator.process() got an unexpected keyword argument 'cache_result'

tests/e2e/test_nightmare_scenario.py:266: TypeError</failure></testcase><testcase classname="tests.e2e.test_nightmare_scenario.TestNightmareScenario" name="test_batch_nightmare" time="0.002"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'process_batch'">self = &lt;tests.e2e.test_nightmare_scenario.TestNightmareScenario object at 0x13f8a86b0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x16bbd8160&gt;

    async def test_batch_nightmare(self, orchestrator_service):
        """
        Batch processing test for nightmare cases
        """
        # Arrange
        nightmare_batch = [
            "Гнатюк-Абдуллаєв Жорж",
            "Jean-Baptiste Müller",
            "Олександр Петренко-Сміт",
            "María José García",
            "O'Connor Patrick",
            "Владимир Иванов-Петров",
            "∑∂∆ Тест ∞",
            "",
            "X" * 100,
            "Сергій" + "\u200b" + "Іванов"
        ]
    
        # Act
&gt;       results = await orchestrator_service.process_batch(
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            texts=nightmare_batch,
            generate_variants=True,
            generate_embeddings=False,
            max_concurrent=3
        )
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'process_batch'

tests/e2e/test_nightmare_scenario.py:330: AttributeError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_high_risk_sanctioned_individual" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_ukrainian_surname_pattern_detection" time="0.001"><failure message="AssertionError: assert &lt;Mock name='mock.screen_entity().input_text' id='6102502768'&gt; == 'Petro Poroshenko'&#10; +  where &lt;Mock name='mock.screen_entity().input_text' id='6102502768'&gt; = &lt;Mock name='mock.screen_entity()' id='6102500080'&gt;.input_text">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13f899e50&gt;
screening_pipeline = &lt;AsyncMock id='6102500752'&gt;

    async def test_ukrainian_surname_pattern_detection(self, screening_pipeline):
        """Test E2E screening with Ukrainian surname pattern"""
        # Arrange
        ukrainian_name = "Petro Poroshenko"
        metadata = {
            'entity_type': 'PERSON',
            'country': 'UA'
        }
    
        # Act
        result = await screening_pipeline.screen_entity(ukrainian_name, metadata)
    
        # Assert
&gt;       assert result.input_text == ukrainian_name
E       AssertionError: assert &lt;Mock name='mock.screen_entity().input_text' id='6102502768'&gt; == 'Petro Poroshenko'
E        +  where &lt;Mock name='mock.screen_entity().input_text' id='6102502768'&gt; = &lt;Mock name='mock.screen_entity()' id='6102500080'&gt;.input_text

tests/e2e/test_sanctions_screening_pipeline.py:98: AssertionError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_low_risk_common_name" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_malicious_input_sanitization" time="0.001"><failure message="assert &lt;Mock name='mock.screen_entity().input_text' id='6103093936'&gt; == &quot;&lt;script&gt;alert('xss')&lt;/script&gt;Petro Poroshenko&quot;&#10; +  where &lt;Mock name='mock.screen_entity().input_text' id='6103093936'&gt; = &lt;Mock name='mock.screen_entity()' id='6103092928'&gt;.input_text">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13fa24770&gt;
screening_pipeline = &lt;AsyncMock id='6103091248'&gt;

    async def test_malicious_input_sanitization(self, screening_pipeline):
        """Test E2E handling of malicious input through sanitization"""
        # Arrange
        malicious_input = "&lt;script&gt;alert('xss')&lt;/script&gt;Petro Poroshenko"
    
        # Act
        result = await screening_pipeline.screen_entity(malicious_input)
    
        # Assert
&gt;       assert result.input_text == malicious_input  # Original preserved for audit
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert &lt;Mock name='mock.screen_entity().input_text' id='6103093936'&gt; == "&lt;script&gt;alert('xss')&lt;/script&gt;Petro Poroshenko"
E        +  where &lt;Mock name='mock.screen_entity().input_text' id='6103093936'&gt; = &lt;Mock name='mock.screen_entity()' id='6103092928'&gt;.input_text

tests/e2e/test_sanctions_screening_pipeline.py:135: AssertionError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_homoglyph_obfuscation_detection" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_zero_width_character_obfuscation" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_mixed_cyrillic_latin_text" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_payment_context_screening" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_early_stopping_high_confidence" time="0.001"><failure message="AssertionError: assert &lt;Mock name='mock.screen_entity().early_stopped' id='6103098304'&gt; is True&#10; +  where &lt;Mock name='mock.screen_entity().early_stopped' id='6103098304'&gt; = &lt;Mock name='mock.screen_entity()' id='6103099648'&gt;.early_stopped">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13fa14050&gt;
screening_pipeline = &lt;AsyncMock id='6103099984'&gt;

    async def test_early_stopping_high_confidence(self, screening_pipeline):
        """Test E2E early stopping on high confidence match"""
        # Arrange
        high_confidence_match = "putin"  # Should trigger AC exact match
    
        # Act
        result = await screening_pipeline.screen_entity(high_confidence_match)
    
        # Assert
        if result.final_confidence &gt;= 0.95:
&gt;           assert result.early_stopped is True
E           AssertionError: assert &lt;Mock name='mock.screen_entity().early_stopped' id='6103098304'&gt; is True
E            +  where &lt;Mock name='mock.screen_entity().early_stopped' id='6103098304'&gt; = &lt;Mock name='mock.screen_entity()' id='6103099648'&gt;.early_stopped

tests/e2e/test_sanctions_screening_pipeline.py:207: AssertionError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_multi_language_entity_screening" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_performance_under_load" time="0.001"><failure message="AssertionError: assert &lt;Mock name='mock.screen_entity().input_text' id='6103438336'&gt; == 'Petro Poroshenko'&#10; +  where &lt;Mock name='mock.screen_entity().input_text' id='6103438336'&gt; = &lt;Mock name='mock.screen_entity()' id='6103437328'&gt;.input_text">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13f84d040&gt;
screening_pipeline = &lt;AsyncMock id='6103436656'&gt;

    async def test_performance_under_load(self, screening_pipeline):
        """Test E2E performance under concurrent load"""
        # Arrange
        test_entities = [
            "Petro Poroshenko",
            "Volodymyr Zelenskyy",
            "John Smith",
            "Maria Gonzalez",
            "Test Name",  # Chinese characters
            "Mohammed Ali"  # Arabic characters
        ]
    
        # Act - Process concurrently
        tasks = [
            screening_pipeline.screen_entity(entity)
            for entity in test_entities
        ]
        results = await asyncio.gather(*tasks)
    
        # Assert
        assert len(results) == len(test_entities)
    
        for i, result in enumerate(results):
&gt;           assert result.input_text == test_entities[i]
E           AssertionError: assert &lt;Mock name='mock.screen_entity().input_text' id='6103438336'&gt; == 'Petro Poroshenko'
E            +  where &lt;Mock name='mock.screen_entity().input_text' id='6103438336'&gt; = &lt;Mock name='mock.screen_entity()' id='6103437328'&gt;.input_text

tests/e2e/test_sanctions_screening_pipeline.py:259: AssertionError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_error_recovery_and_graceful_degradation" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_audit_trail_completeness" time="0.001"><failure message="AssertionError: assert 'start_time' in {'tiers': ['tier1', 'tier2']}&#10; +  where {'tiers': ['tier1', 'tier2']} = &lt;Mock name='mock.screen_entity()' id='6103444384'&gt;.audit_trail">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13fa32430&gt;
screening_pipeline = &lt;AsyncMock id='6103443712'&gt;

    async def test_audit_trail_completeness(self, screening_pipeline):
        """Test E2E audit trail completeness"""
        # Arrange
        test_entity = "Audit Trail Test"
    
        # Act
        result = await screening_pipeline.screen_entity(test_entity)
    
        # Assert
        assert 'tiers' in result.audit_trail
&gt;       assert 'start_time' in result.audit_trail
E       AssertionError: assert 'start_time' in {'tiers': ['tier1', 'tier2']}
E        +  where {'tiers': ['tier1', 'tier2']} = &lt;Mock name='mock.screen_entity()' id='6103444384'&gt;.audit_trail

tests/e2e/test_sanctions_screening_pipeline.py:294: AssertionError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_risk_level_classification_accuracy" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_vector_similarity_integration" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_screening_metrics_collection" time="0.001"><failure message="TypeError: argument of type 'coroutine' is not iterable">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13f8bdb50&gt;
screening_pipeline = &lt;AsyncMock id='6103763664'&gt;

    def test_screening_metrics_collection(self, screening_pipeline):
        """Test E2E metrics collection"""
        # Act
        metrics = screening_pipeline.get_screening_metrics()
    
        # Assert
&gt;       assert 'total_screenings' in metrics
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'coroutine' is not iterable

tests/e2e/test_sanctions_screening_pipeline.py:337: TypeError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_configuration_driven_processing" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_sanctions_data_format_compatibility" time="0.001"><failure message="AssertionError: assert &lt;Mock name='mock.screen_entity().input_text' id='6103766016'&gt; == 'Test Entity'&#10; +  where &lt;Mock name='mock.screen_entity().input_text' id='6103766016'&gt; = &lt;Mock name='mock.screen_entity()' id='6103097296'&gt;.input_text">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E object at 0x13fa49ff0&gt;
screening_pipeline = &lt;AsyncMock id='6103095616'&gt;

    async def test_sanctions_data_format_compatibility(self, screening_pipeline):
        """Test E2E compatibility with actual sanctions data format"""
        # Arrange - Simulate real sanctions data structure
        sanctions_entity = {
            'name': 'Test Entity',
            'name_en': 'Test Entity',
            'name_ru': 'Test Entity',
            'entity_type': 'PERSON',
            'birthdate': '1970-01-01',
            'itn': '1234567890',
            'status': 'ACTIVE',
            'source': 'TEST_SANCTIONS_LIST'
        }
    
        # Act
        result = await screening_pipeline.screen_entity(
            sanctions_entity['name'],
            entity_metadata=sanctions_entity
        )
    
        # Assert
&gt;       assert result.input_text == sanctions_entity['name']
E       AssertionError: assert &lt;Mock name='mock.screen_entity().input_text' id='6103766016'&gt; == 'Test Entity'
E        +  where &lt;Mock name='mock.screen_entity().input_text' id='6103766016'&gt; = &lt;Mock name='mock.screen_entity()' id='6103097296'&gt;.input_text

tests/e2e/test_sanctions_screening_pipeline.py:387: AssertionError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningPipelineE2E" name="test_language_detection_integration" time="0.001" /><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningRobustness" name="test_extremely_long_input_handling" time="0.001"><failure message="TypeError: object Mock can't be used in 'await' expression">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningRobustness object at 0x13f89b110&gt;
robust_screening_pipeline = &lt;Mock id='6103768032'&gt;

    async def test_extremely_long_input_handling(self, robust_screening_pipeline):
        """Test handling of extremely long input text"""
        # Arrange
        very_long_text = "Test " * 10000  # 50k+ characters
    
        # Act
&gt;       result = await robust_screening_pipeline.screen_entity(very_long_text)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: object Mock can't be used in 'await' expression

tests/e2e/test_sanctions_screening_pipeline.py:430: TypeError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningRobustness" name="test_unicode_edge_cases" time="0.001"><failure message="TypeError: object Mock can't be used in 'await' expression">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningRobustness object at 0x13f89b250&gt;
robust_screening_pipeline = &lt;Mock id='6103446400'&gt;

    async def test_unicode_edge_cases(self, robust_screening_pipeline):
        """Test Unicode edge cases and special characters"""
        # Arrange
        unicode_test_cases = [
            "Test Name",  # Emoji
            "Test\u0000Name",      # Null character
            "Test\u200eName",      # Left-to-right mark
            "Hebrew Name Arabic",   # Mixed RTL/LTR
            "Test\U0001F4A9Name"   # 4-byte Unicode
        ]
    
        # Act &amp; Assert
        for test_case in unicode_test_cases:
&gt;           result = await robust_screening_pipeline.screen_entity(test_case)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           TypeError: object Mock can't be used in 'await' expression

tests/e2e/test_sanctions_screening_pipeline.py:450: TypeError</failure></testcase><testcase classname="tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningRobustness" name="test_concurrent_screening_stress" time="0.001"><failure message="TypeError: An asyncio.Future, a coroutine or an awaitable is required">self = &lt;tests.e2e.test_sanctions_screening_pipeline.TestSanctionsScreeningRobustness object at 0x13fa248a0&gt;
robust_screening_pipeline = &lt;Mock id='6103094608'&gt;

    async def test_concurrent_screening_stress(self, robust_screening_pipeline):
        """Test concurrent screening under stress conditions"""
        # Arrange
        num_concurrent = 50
        test_entities = [f"Concurrent Test {i}" for i in range(num_concurrent)]
    
        # Act
        start_time = asyncio.get_event_loop().time()
        tasks = [
            robust_screening_pipeline.screen_entity(entity)
            for entity in test_entities
        ]
&gt;       results = await asyncio.gather(*tasks, return_exceptions=True)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/e2e/test_sanctions_screening_pipeline.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

return_exceptions = True
coros_or_futures = (&lt;Mock name='mock.screen_entity()' id='6103094272'&gt;, &lt;Mock name='mock.screen_entity()' id='6103094272'&gt;, &lt;Mock name='m...3094272'&gt;, &lt;Mock name='mock.screen_entity()' id='6103094272'&gt;, &lt;Mock name='mock.screen_entity()' id='6103094272'&gt;, ...)
loop = None
_done_callback = &lt;function gather.&lt;locals&gt;._done_callback at 0x16bc13d80&gt;

    def gather(*coros_or_futures, return_exceptions=False):
        """Return a future aggregating results from the given coroutines/futures.
    
        Coroutines will be wrapped in a future and scheduled in the event
        loop. They will not necessarily be scheduled in the same order as
        passed in.
    
        All futures must share the same event loop.  If all the tasks are
        done successfully, the returned future's result is the list of
        results (in the order of the original sequence, not necessarily
        the order of results arrival).  If *return_exceptions* is True,
        exceptions in the tasks are treated the same as successful
        results, and gathered in the result list; otherwise, the first
        raised exception will be immediately propagated to the returned
        future.
    
        Cancellation: if the outer Future is cancelled, all children (that
        have not completed yet) are also cancelled.  If any child is
        cancelled, this is treated as if it raised CancelledError --
        the outer Future is *not* cancelled in this case.  (This is to
        prevent the cancellation of one child to cause other children to
        be cancelled.)
    
        If *return_exceptions* is False, cancelling gather() after it
        has been marked done won't cancel any submitted awaitables.
        For instance, gather can be marked done after propagating an
        exception to the caller, therefore, calling ``gather.cancel()``
        after catching an exception (raised by one of the awaitables) from
        gather won't cancel any other awaitables.
        """
        if not coros_or_futures:
            loop = events.get_event_loop()
            outer = loop.create_future()
            outer.set_result([])
            return outer
    
        def _done_callback(fut):
            nonlocal nfinished
            nfinished += 1
    
            if outer is None or outer.done():
                if not fut.cancelled():
                    # Mark exception retrieved.
                    fut.exception()
                return
    
            if not return_exceptions:
                if fut.cancelled():
                    # Check if 'fut' is cancelled first, as
                    # 'fut.exception()' will *raise* a CancelledError
                    # instead of returning it.
                    exc = fut._make_cancelled_error()
                    outer.set_exception(exc)
                    return
                else:
                    exc = fut.exception()
                    if exc is not None:
                        outer.set_exception(exc)
                        return
    
            if nfinished == nfuts:
                # All futures are done; create a list of results
                # and set it to the 'outer' future.
                results = []
    
                for fut in children:
                    if fut.cancelled():
                        # Check if 'fut' is cancelled first, as 'fut.exception()'
                        # will *raise* a CancelledError instead of returning it.
                        # Also, since we're adding the exception return value
                        # to 'results' instead of raising it, don't bother
                        # setting __context__.  This also lets us preserve
                        # calling '_make_cancelled_error()' at most once.
                        res = exceptions.CancelledError(
                            '' if fut._cancel_message is None else
                            fut._cancel_message)
                    else:
                        res = fut.exception()
                        if res is None:
                            res = fut.result()
                    results.append(res)
    
                if outer._cancel_requested:
                    # If gather is being cancelled we must propagate the
                    # cancellation regardless of *return_exceptions* argument.
                    # See issue 32684.
                    exc = fut._make_cancelled_error()
                    outer.set_exception(exc)
                else:
                    outer.set_result(results)
    
        arg_to_fut = {}
        children = []
        nfuts = 0
        nfinished = 0
        done_futs = []
        loop = None
        outer = None  # bpo-46672
        for arg in coros_or_futures:
            if arg not in arg_to_fut:
&gt;               fut = ensure_future(arg, loop=loop)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/tasks.py:884: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

coro_or_future = &lt;Mock name='mock.screen_entity()' id='6103094272'&gt;

    def ensure_future(coro_or_future, *, loop=None):
        """Wrap a coroutine or an awaitable in a future.
    
        If the argument is a Future, it is returned directly.
        """
        if futures.isfuture(coro_or_future):
            if loop is not None and loop is not futures._get_loop(coro_or_future):
                raise ValueError('The future belongs to a different loop than '
                                'the one specified as the loop argument')
            return coro_or_future
        should_close = True
        if not coroutines.iscoroutine(coro_or_future):
            if inspect.isawaitable(coro_or_future):
                async def _wrap_awaitable(awaitable):
                    return await awaitable
    
                coro_or_future = _wrap_awaitable(coro_or_future)
                should_close = False
            else:
&gt;               raise TypeError('An asyncio.Future, a coroutine or an awaitable '
                                'is required')
E               TypeError: An asyncio.Future, a coroutine or an awaitable is required

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/tasks.py:742: TypeError</failure></testcase><testcase classname="tests.integration.test_api_risk_response.TestAPIRiskResponse" name="test_process_endpoint_response_format" time="0.001" /><testcase classname="tests.integration.test_api_risk_response.TestAPIRiskResponse" name="test_process_endpoint_response_without_decision_engine" time="0.000" /><testcase classname="tests.integration.test_api_risk_response.TestAPIRiskResponse" name="test_decision_output_serialization" time="0.000" /><testcase classname="tests.integration.test_api_risk_response.TestAPIRiskResponse" name="test_risk_level_values" time="0.000" /><testcase classname="tests.integration.test_diminutive_forms" name="test_diminutive_forms" time="0.034" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_russian_person_with_documents" time="0.116" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_ukrainian_organization_with_legal_form" time="0.005" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_english_mixed_script_name" time="0.005" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_complex_payment_description" time="0.010" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_edge_case_compound_names" time="0.004" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_decision_engine_thresholds" time="0.008" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_metrics_collection" time="0.004" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_performance_benchmarks" time="0.013" /><testcase classname="tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening" name="test_golden_dataset_stability" time="0.004"><failure message="AssertionError: assert None == 'ООО'&#10; +  where None = &lt;ai_service.layers.signals.signals_service.OrgObj object at 0x16bbc3e00&gt;.legal_form">self = &lt;tests.integration.test_e2e_sanctions_screening.TestE2ESanctionsScreening object at 0x13fa14750&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x16bbc12b0&gt;

    @pytest.mark.asyncio
    async def test_golden_dataset_stability(self, orchestrator):
        """
        Тест стабильности на золотом наборе данных
        Результаты должны быть воспроизводимыми между запусками
        """
        golden_cases = [
            {
                "text": "Иванов Сергей Петрович д.р. 15.03.1985",
                "expected_persons": 1,
                "expected_normalized": "Иванов Сергей Петрович",
                "expected_language": "ru",
                "expected_dates": 1
            },
            {
                "text": 'ООО "Рога и Копыта" ИНН 7701123456',
                "expected_organizations": 1,
                "expected_legal_form": "ООО",
                "expected_language": "ru",
                "expected_inn": "7701123456"
            },
            {
                "text": "John Smith, born 1985-03-15",
                "expected_persons": 1,
                "expected_language": "en",
                "expected_dates": 1
            }
        ]
    
        for case in golden_cases:
            result = await orchestrator.process(
                text=case["text"],
                remove_stop_words=True,
                preserve_names=True,
                enable_advanced_features=True
            )
    
            assert result.success is True
            assert result.language == case["expected_language"]
    
            if "expected_persons" in case:
                assert len(result.signals.persons) &gt;= case["expected_persons"]
    
            if "expected_organizations" in case:
                assert len(result.signals.organizations) &gt;= case["expected_organizations"]
    
            if "expected_legal_form" in case:
                org = result.signals.organizations[0]
&gt;               assert org.legal_form == case["expected_legal_form"]
E               AssertionError: assert None == 'ООО'
E                +  where None = &lt;ai_service.layers.signals.signals_service.OrgObj object at 0x16bbc3e00&gt;.legal_form

tests/integration/test_e2e_sanctions_screening.py:395: AssertionError</failure></testcase><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_name_variants_similarity" time="4.976" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_organization_names_similarity" time="3.371" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_unrelated_strings_low_similarity" time="4.164" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_mixed_script_names" time="5.575" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_common_names_different_languages" time="6.279" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_organization_variants" time="4.420" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_embedding_dimensions_consistency" time="5.327" /><testcase classname="tests.integration.test_embeddings_multilingual.TestMultilingualEmbeddings" name="test_preprocessing_effectiveness" time="4.929" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u041e\u043f\u043b\u0430\u0442\u0430 \u0437\u0430 \u043f\u043e\u0441\u043b\u0443\u0433\u0438, \u043f\u043b\u0430\u0442\u043d\u0438\u043a \u041f\u0435\u0442\u0440\u0438\u043a \u041f.-\u041f\u0435\u0442\u0440\u043e \u041f.]" time="1.404" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0414\u043b\u044f \u041f\u0435\u0442\u0440\u0443\u0441\u044f \u0406\u0432\u0430\u043d\u043e\u0432\u0430, \u0437\u0430 \u0440\u0435\u043c\u043e\u043d\u0442-\u041f\u0435\u0442\u0440\u043e \u0406\u0432\u0430\u043d\u043e\u0432]" time="0.065" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u041f\u0435\u0440\u0435\u043a\u0430\u0437 \u0432\u0456\u0434 \u0412\u043e\u0432\u0447\u0438\u043a\u0430 \u0417\u0435\u043b\u0435\u043d\u0441\u044c\u043a\u043e\u0433\u043e \u0412. \u041e.-\u0412\u043e\u043b\u043e\u0434\u0438\u043c\u0438\u0440 \u0417\u0435\u043b\u0435\u043d\u0441\u044c\u043a\u0438\u0439 \u0412. \u041e.]" time="2.848" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u041f\u043e\u0434\u0430\u0440\u0443\u043d\u043e\u043a \u0434\u043b\u044f \u0414\u0430\u0448\u0435\u043d\u044c\u043a\u0438 \u041a\u0432\u0456\u0442\u043a\u043e\u0432\u043e\u0457-\u0414\u0430\u0440\u0456\u044f \u041a\u0432\u0456\u0442\u043a\u043e\u0432\u0430]" time="0.053" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0412\u0456\u0434 \u0421\u0430\u0448\u043a\u0430 \u041f\u043e\u043b\u043e\u0436\u0438\u043d\u0441\u044c\u043a\u043e\u0433\u043e \u0437\u0430 \u043a\u0432\u0438\u0442\u043a\u0438-\u041e\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u041f\u043e\u043b\u043e\u0436\u0438\u043d\u0441\u044c\u043a\u0438\u0439]" time="0.090" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0414\u043b\u044f \u0416\u0435\u043d\u0456 \u0413\u0430\u043b\u0438\u0447\u0430 \u0437 \u0433\u0440\u0443\u043f\u0438 O.Torvald-\u0404\u0432\u0433\u0435\u043d \u0413\u0430\u043b\u0438\u0447]" time="0.132"><failure message="AssertionError: Ожидалось: {'галич', 'євген'}, получено: {'з.', 'галич', 'євген'}&#10;assert {'галич', 'євген'} == {'галич', 'з.', 'євген'}&#10;  &#10;  Extra items in the right set:&#10;  'з.'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16cb4f020&gt;
input_text = 'Для Жені Галича з групи O.Torvald', expected_name = 'Євген Галич'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Євген Галич З.', tokens=['Євген', 'Галич', 'З.'], trace=[TokenTrace(token='Жені', role...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Євген Галич'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'галич', 'євген'}, получено: {'з.', 'галич', 'євген'}
E       assert {'галич', 'євген'} == {'галич', 'з.', 'євген'}
E         
E         Extra items in the right set:
E         'з.'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0414\u044f\u043a\u0443\u0454\u043c\u043e \u0421\u0435\u0440\u0433\u0456\u0454\u0432\u0456 \u0416\u0430\u0434\u0430\u043d\u0443 \u0437\u0430 \u0442\u0432\u043e\u0440\u0447\u0456\u0441\u0442\u044c-\u0421\u0435\u0440\u0433\u0456\u0439 \u0416\u0430\u0434\u0430\u043d]" time="0.121" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0417\u0443\u0441\u0442\u0440\u0456\u0447 \u0437 \u041b\u0456\u043d\u043e\u044e \u041a\u043e\u0441\u0442\u0435\u043d\u043a\u043e-\u041b\u0456\u043d\u0430 \u041a\u043e\u0441\u0442\u0435\u043d\u043a\u043e]" time="0.103"><failure message="AssertionError: Ожидалось: {'костенко', 'ліна'}, получено: {'костенко', 'з.', 'ліна'}&#10;assert {'костенко', 'ліна'} == {'з.', 'костенко', 'ліна'}&#10;  &#10;  Extra items in the right set:&#10;  'з.'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16bcf8e50&gt;
input_text = 'Зустріч з Ліною Костенко', expected_name = 'Ліна Костенко'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='З. Ліна Костенко', tokens=['З.', 'Ліна', 'Костенко'], trace=[TokenTrace(token='з', rol...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Ліна Костенко'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'костенко', 'ліна'}, получено: {'костенко', 'з.', 'ліна'}
E       assert {'костенко', 'ліна'} == {'з.', 'костенко', 'ліна'}
E         
E         Extra items in the right set:
E         'з.'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u041f\u043e\u0434\u0430\u0440\u0443\u043d\u043e\u043a \u0434\u043b\u044f \u041e\u043a\u0441\u0430\u043d\u0438 \u0417\u0430\u0431\u0443\u0436\u043a\u043e-\u041e\u043a\u0441\u0430\u043d\u0430 \u0417\u0430\u0431\u0443\u0436\u043a\u043e]" time="0.139" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0420\u043e\u0437\u043c\u043e\u0432\u043b\u044f\u0432 \u0437 \u0412\u0430\u043b\u0435\u0440\u0456\u0454\u043c \u0417\u0430\u043b\u0443\u0436\u043d\u0438\u043c-\u0412\u0430\u043b\u0435\u0440\u0456\u0439 \u0417\u0430\u043b\u0443\u0436\u043d\u0438\u0439]" time="0.086"><failure message="AssertionError: Ожидалось: {'залужний', 'валерій'}, получено: {'валерій', 'залужний', 'з.'}&#10;assert {'валерій', 'залужний'} == {'валерій', 'з.', 'залужний'}&#10;  &#10;  Extra items in the right set:&#10;  'з.'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x306eff890&gt;
input_text = 'Розмовляв з Валерієм Залужним', expected_name = 'Валерій Залужний'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='З. Валерій Залужний', tokens=['З.', 'Валерій', 'Залужний'], trace=[TokenTrace(token='з...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Валерій Залужний'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'залужний', 'валерій'}, получено: {'валерій', 'залужний', 'з.'}
E       assert {'валерій', 'залужний'} == {'валерій', 'з.', 'залужний'}
E         
E         Extra items in the right set:
E         'з.'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u041f\u043b\u0442\u0456\u0436 \u0432\u0456\u0434 \u0412'\u044f\u0447\u0435\u0441\u043b\u0430\u0432\u0430 \u0432\u0430\u043a\u0430\u0440\u0447\u0443\u043a\u0430 (\u043e\u043a\u0435\u0430\u043d \u0435\u043b\u044c\u0437\u0438)-\u0412'\u044f\u0447\u0435\u0441\u043b\u0430\u0432 \u0412\u0430\u043a\u0430\u0440\u0447\u0443\u043a]" time="0.083" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u041f\u0435\u0440\u0435\u043a\u0430\u0437 \u041e\u041b\u0415\u0413\u0423 \u0421\u041a\u0420\u0418\u041f\u0426\u0406-\u041e\u043b\u0435\u0433 \u0421\u043a\u0440\u0438\u043f\u043a\u0430]" time="0.792" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_ukrainian_full_normalization[\u0414\u043b\u044f \u0406\u0432\u0430\u043d\u043e\u0432\u0430-\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u0430 \u0421.\u0412.-\u0406\u0432\u0430\u043d\u043e\u0432-\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u043e \u0421. \u0412.]" time="0.049" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u043e\u0442 \u0421\u0430\u0448\u0438 \u041f\u0443\u0448\u043a\u0438\u043d\u0430 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447\u0430-\u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u041f\u0443\u0448\u043a\u0438\u043d \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447]" time="0.061" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u041e\u043f\u043b\u0430\u0442\u0430 \u0434\u043b\u044f \u0412\u043e\u043b\u043e\u0434\u0438 \u0412\u044b\u0441\u043e\u0446\u043a\u043e\u0433\u043e-\u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440 \u0412\u044b\u0441\u043e\u0446\u043a\u0438\u0439]" time="0.117" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u041f\u043b\u0430\u0442\u0451\u0436 \u043e\u0442 \u0414\u0438\u043c\u044b \u041c\u0435\u0434\u0432\u0435\u0434\u0435\u0432\u0430-\u0414\u043c\u0438\u0442\u0440\u0438\u0439 \u041c\u0435\u0434\u0432\u0435\u0434\u0435\u0432]" time="0.074" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u0414\u043b\u044f \u0410\u043b\u043b\u044b \u0411\u043e\u0440\u0438\u0441\u043e\u0432\u043d\u044b \u041f\u0443\u0433\u0430\u0447\u0435\u0432\u043e\u0439-\u0410\u043b\u043b\u0430 \u0411\u043e\u0440\u0438\u0441\u043e\u0432\u043d\u0430 \u041f\u0443\u0433\u0430\u0447\u0435\u0432\u0430]" time="0.093"><failure message="AssertionError: Ожидалось: {'пугачева', 'алла', 'борисовна'}, получено: {'пугачев', 'аллы', 'борисовн'}&#10;assert {'алла', 'бор...', 'пугачева'} == {'аллы', 'бор...н', 'пугачев'}&#10;  &#10;  Extra items in the left set:&#10;  'пугачева'&#10;  'алла'&#10;  'борисовна'&#10;  Extra items in the right set:&#10;  'пугачев'...&#10;  &#10;  ...Full output truncated (3 lines hidden), use '-vv' to show">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x345f21d30&gt;
input_text = 'Для Аллы Борисовны Пугачевой'
expected_name = 'Алла Борисовна Пугачева'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Аллы Борисовн Пугачев', tokens=['Аллы', 'Борисовн', 'Пугачев'], trace=[TokenTrace(toke...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Алла Борисовна Пугачева'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'пугачева', 'алла', 'борисовна'}, получено: {'пугачев', 'аллы', 'борисовн'}
E       assert {'алла', 'бор...', 'пугачева'} == {'аллы', 'бор...н', 'пугачев'}
E         
E         Extra items in the left set:
E         'пугачева'
E         'алла'
E         'борисовна'
E         Extra items in the right set:
E         'пугачев'...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u0411\u043b\u0430\u0433\u043e\u0434\u0430\u0440\u043d\u043e\u0441\u0442\u044c \u041f\u0435\u0442\u0440\u0443 \u0427\u0430\u0439\u043a\u043e\u0432\u0441\u043a\u043e\u043c\u0443-\u041f\u0435\u0442\u0440 \u0427\u0430\u0439\u043a\u043e\u0432\u0441\u043a\u0438\u0439]" time="0.071"><failure message="AssertionError: Ожидалось: {'чайковский', 'петр'}, получено: {'чайковском', 'петр'}&#10;assert {'петр', 'чайковский'} == {'петр', 'чайковском'}&#10;  &#10;  Extra items in the left set:&#10;  'чайковский'&#10;  Extra items in the right set:&#10;  'чайковском'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x306225860&gt;
input_text = 'Благодарность Петру Чайковскому'
expected_name = 'Петр Чайковский'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Петр Чайковском', tokens=['Петр', 'Чайковском'], trace=[TokenTrace(token='Петру', role...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Петр Чайковский'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'чайковский', 'петр'}, получено: {'чайковском', 'петр'}
E       assert {'петр', 'чайковский'} == {'петр', 'чайковском'}
E         
E         Extra items in the left set:
E         'чайковский'
E         Extra items in the right set:
E         'чайковском'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u0412\u0441\u0442\u0440\u0435\u0447\u0430 \u0441 \u0410\u043d\u043d\u043e\u0439 \u0410\u0445\u043c\u0430\u0442\u043e\u0432\u043e\u0439-\u0410\u043d\u043d\u0430 \u0410\u0445\u043c\u0430\u0442\u043e\u0432\u0430]" time="0.062"><failure message="AssertionError: Ожидалось: {'ахматова', 'анна'}, получено: {'ахматова', 'с.', 'анна'}&#10;assert {'анна', 'ахматова'} == {'анна', 'ахматова', 'с.'}&#10;  &#10;  Extra items in the right set:&#10;  'с.'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x306ecddb0&gt;
input_text = 'Встреча с Анной Ахматовой', expected_name = 'Анна Ахматова'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='С. Анна Ахматова', tokens=['С.', 'Анна', 'Ахматова'], trace=[TokenTrace(token='с', rol...re_female': 5, 'score_male': 0, 'gap': 5}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Анна Ахматова'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'ахматова', 'анна'}, получено: {'ахматова', 'с.', 'анна'}
E       assert {'анна', 'ахматова'} == {'анна', 'ахматова', 'с.'}
E         
E         Extra items in the right set:
E         'с.'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0418\u0432\u0430\u043d\u0443 \u0411\u0443\u043d\u0438\u043d\u0443-\u0418\u0432\u0430\u043d \u0411\u0443\u043d\u0438\u043d]" time="0.057" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0434\u043b\u044f \u0415\u0441\u0435\u043d\u0438\u043d\u0430 \u0421. \u0410.-\u0415\u0441\u0435\u043d\u0438\u043d \u0421. \u0410.]" time="0.059" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_russian_full_normalization[\u0417\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043e\u0442 \u041b\u0435\u0440\u043c\u043e\u043d\u0442\u043e\u0432\u0430 \u041c.\u042e.-\u041b\u0435\u0440\u043c\u043e\u043d\u0442\u043e\u0432 \u041c. \u042e.]" time="0.445" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[Payment from John Fitzgerald Kennedy-John Fitzgerald Kennedy]" time="0.086" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[Transfer to Stephen E. King for services-Stephen E. King]" time="0.087" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[For Mr. Sherlock Holmes, Baker st. 221b-Sherlock Holmes]" time="0.065" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[Refund to Ms. Joanna Rowling-Joanna Rowling]" time="0.089" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[From Bill Gates for charity-William Gates]" time="0.065" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[For Liz Truss, former PM-Elizabeth Truss]" time="0.072" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[Payment from Mike Johnson-Michael Johnson]" time="0.068" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[Sent to ELON MUSK for X corp-Elon Musk]" time="0.064"><failure message="AssertionError: Ожидалось: {'elon', 'musk'}, получено: {'x', 'elon', 'musk'}&#10;assert {'elon', 'musk'} == {'elon', 'musk', 'x'}&#10;  &#10;  Extra items in the right set:&#10;  'x'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30620b350&gt;
input_text = 'Sent to ELON MUSK for X corp', expected_name = 'Elon Musk'

    @pytest.mark.parametrize("input_text, expected_name", english_test_cases)
    def test_english_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию английских имен."""
        result = normalization_service.normalize(input_text, language="en")
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_full_normalization_suite.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Elon Musk X', tokens=['Elon', 'Musk', 'X'], trace=[TokenTrace(token='ELON', role='give...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Elon Musk'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'elon', 'musk'}, получено: {'x', 'elon', 'musk'}
E       assert {'elon', 'musk'} == {'elon', 'musk', 'x'}
E         
E         Extra items in the right set:
E         'x'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_full_normalization_suite" name="test_english_full_normalization[For BARACK H. OBAMA, invoice 123-Barack H. Obama]" time="1.173" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_critical_ukrainian_normalization" time="0.097" /><testcase classname="tests.integration.test_full_normalization_suite" name="test_critical_russian_normalization" time="0.089"><failure message="AssertionError: Expected {'сергей', 'петров', 'владимирович'}, but got {'петров', 'в.', 'сергей', 'владимирович'}&#10;assert {'в.', 'влади...ов', 'сергей'} == {'владимирови...ов', 'сергей'}&#10;  &#10;  Extra items in the left set:&#10;  'в.'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16e0cf0d0&gt;

    def test_critical_russian_normalization(normalization_service):
        """Критический тест: Сергея Владимировича Петрова -&gt; Сергей Владимирович Петров"""
        input_text = "Платеж в пользу Сергея Владимировича Петрова"
        result = normalization_service.normalize(input_text, language="ru", remove_stop_words=True)
    
        # Строгие проверки
        assert result.success, f"Normalization failed: {result.errors}"
        assert result.tokens, "No tokens returned"
    
        tokens_lower = {token.lower() for token in result.tokens}
        expected_tokens = {"сергей", "владимирович", "петров"}
    
&gt;       assert tokens_lower == expected_tokens, f"Expected {expected_tokens}, but got {tokens_lower}"
E       AssertionError: Expected {'сергей', 'петров', 'владимирович'}, but got {'петров', 'в.', 'сергей', 'владимирович'}
E       assert {'в.', 'влади...ов', 'сергей'} == {'владимирови...ов', 'сергей'}
E         
E         Extra items in the left set:
E         'в.'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:160: AssertionError</failure></testcase><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_ukrainian_female_name_with_patronymic" time="0.081"><failure message="AssertionError: assert ['Павлов', 'Дарʼї', 'Юріївна'] == ['Павлов', 'Дарʼя', 'Юріївна']&#10;  &#10;  At index 1 diff: 'Дарʼї' != 'Дарʼя'&#10;  Use -v to get more diff">self = &lt;tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration object at 0x13fab07d0&gt;

    def test_ukrainian_female_name_with_patronymic(self):
        """Test Ukrainian female name with patronymic - should adjust surname to feminine."""
        text = "оплата за комунальні послуги Павлової Дарʼї Юріївни"
        result = self.service.normalize_sync(text)
    
        assert result.success
        assert len(result.persons) == 1
    
        person = result.persons[0]
        # Note: Дарʼя is not in Ukrainian names dictionary, so it's tagged as surname
&gt;       assert person["tokens"] == ["Павлов", "Дарʼя", "Юріївна"]
E       AssertionError: assert ['Павлов', 'Дарʼї', 'Юріївна'] == ['Павлов', 'Дарʼя', 'Юріївна']
E         
E         At index 1 diff: 'Дарʼї' != 'Дарʼя'
E         Use -v to get more diff

tests/integration/test_gender_adjustment.py:32: AssertionError</failure></testcase><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_russian_male_name_with_patronymic" time="0.095" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_russian_female_name_only" time="0.140" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_russian_male_dative_case" time="0.085" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_ukrainian_invariant_surname_kovalenko" time="0.108" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_ukrainian_invariant_surname_sushko" time="0.081" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_ukrainian_invariant_surname_lemish" time="1.477" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_surname_only_without_name" time="0.192" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_multiple_persons_with_different_genders" time="0.141" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_confidence_gap_boundary_cases" time="0.170" /><testcase classname="tests.integration.test_gender_adjustment.TestGenderAdjustmentIntegration" name="test_trace_information_completeness" time="0.093" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_russian_language_in_results" time="0.172" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_ukrainian_language_in_results" time="0.008" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_english_language_in_results" time="0.004" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_mixed_language_in_results" time="0.005" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_unknown_language_in_results" time="0.003" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_confidence_range_validation" time="0.007" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_normalization_result_language_fields" time="0.000" /><testcase classname="tests.integration.test_lang_in_results.TestLanguageInResults" name="test_processing_result_language_fields" time="0.000" /><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_unicode_normalization_before_language_detection" time="0.029"><failure message="AssertionError: Expected 'normalize_unicode' to be called once. Called 0 times.">self = &lt;tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder object at 0x13fab0e10&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x30ac71e10&gt;

    def test_unicode_normalization_before_language_detection(self, orchestrator):
        """
        Test that Unicode normalization is called before language detection
        """
        # Test text with mixed Unicode forms and accents
        test_text = "Платеж Иванову"  # Russian text
    
        # Mock unicode service to return normalized text
        unicode_result = {
            "normalized": "Платеж Иванову",  # Normalized version
            "confidence": 0.95,
            "changes_count": 0,
            "char_replacements": 0
        }
        async def mock_normalize_unicode(text):
            return unicode_result
    
        orchestrator.unicode_service.normalize_unicode = Mock(side_effect=mock_normalize_unicode)
    
        # Mock language service to return detection result
        lang_result = {
            "language": "ru",
            "confidence": 0.8,
            "method": "config_driven"
        }
        orchestrator.language_service.detect_language = Mock(return_value=lang_result)
    
        # Mock other services
        async def mock_validate_and_sanitize(text):
            return {
                "sanitized_text": test_text,
                "is_valid": True,
                "should_process": True,
                "errors": []
            }
    
        orchestrator.validation_service.validate_and_sanitize = Mock(side_effect=mock_validate_and_sanitize)
    
        async def mock_normalize_async(text, **kwargs):
            return Mock(
                success=True,
                tokens=["платеж", "иванову"],
                confidence=0.9
            )
    
        orchestrator.normalization_service.normalize_async = Mock(side_effect=mock_normalize_async)
    
        async def mock_extract_async(text, normalization_result):
            return Mock(
                confidence=0.8,
                persons=[],
                organizations=[]
            )
    
        orchestrator.signals_service.extract_async = Mock(side_effect=mock_extract_async)
    
        # Run the orchestrator
        import asyncio
        result = asyncio.run(orchestrator.process(test_text))
    
        # Verify unicode normalization was called first
&gt;       orchestrator.unicode_service.normalize_unicode.assert_called_once_with(test_text)

tests/integration/test_lang_order_unicode_first.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Mock name='mock.normalize_unicode' id='13066107072'&gt;
args = ('Платеж Иванову',), kwargs = {}
msg = "Expected 'normalize_unicode' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
&gt;           raise AssertionError(msg)
E           AssertionError: Expected 'normalize_unicode' to be called once. Called 0 times.

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:990: AssertionError</failure></testcase><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_mixed_unicode_forms_detection" time="0.010" /><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_unicode_idempotency_protection" time="0.000" /><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_diacritics_normalization_stability" time="0.003" /><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_orchestrator_call_order_verification" time="0.003"><failure message="AssertionError: assert 'unicode' in []">self = &lt;tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder object at 0x13fae1370&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x309afed50&gt;

    def test_orchestrator_call_order_verification(self, orchestrator):
        """
        Test that orchestrator calls services in the correct order
        """
        test_text = "Платеж Иванову"
    
        # Mock all services
        async def mock_normalize_unicode(text):
            return {
                "normalized": test_text,
                "confidence": 0.95
            }
    
        orchestrator.unicode_service.normalize_unicode = mock_normalize_unicode
    
        orchestrator.language_service.detect_language = Mock(return_value={
            "language": "ru",
            "confidence": 0.8
        })
    
        async def mock_normalize_async(text, **kwargs):
            return Mock(
                success=True,
                tokens=["платеж", "иванову"],
                confidence=0.9
            )
    
        orchestrator.normalization_service.normalize_async = mock_normalize_async
    
        async def mock_extract_async(text, normalization_result):
            return Mock(
                confidence=0.8,
                persons=[],
                organizations=[]
            )
    
        orchestrator.signals_service.extract_async = mock_extract_async
    
        async def mock_validate_and_sanitize(text):
            return {
                "sanitized_text": test_text,
                "is_valid": True,
                "should_process": True,
                "errors": []
            }
    
        orchestrator.validation_service.validate_and_sanitize = Mock(side_effect=mock_validate_and_sanitize)
    
        # Track call order
        call_order = []
    
        async def track_unicode_call(*args, **kwargs):
            call_order.append("unicode")
            return {
                "normalized": test_text,
                "confidence": 0.95
            }
    
        def track_lang_call(*args, **kwargs):
            call_order.append("language")
            return {
                "language": "ru",
                "confidence": 0.8
            }
    
        orchestrator.unicode_service.normalize_unicode = Mock(side_effect=track_unicode_call)
        orchestrator.language_service.detect_language = Mock(side_effect=track_lang_call)
    
        # Run orchestrator
        import asyncio
        asyncio.run(orchestrator.process(test_text))
    
        # Verify call order
&gt;       assert "unicode" in call_order
E       AssertionError: assert 'unicode' in []

tests/integration/test_lang_order_unicode_first.py:297: AssertionError</failure></testcase><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_edge_cases_unicode_normalization" time="0.001" /><testcase classname="tests.integration.test_lang_order_unicode_first.TestUnicodeFirstLanguageDetectionOrder" name="test_unicode_normalization_preserves_meaning" time="0.001" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_detection" time="0.005" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_normalization" time="0.103" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_smart_filter" time="0.046" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_signals" time="0.164" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_birthdate_proximity" time="0.122" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_full_flow" time="0.075" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_edge_cases" time="4.595" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_confidence_scoring" time="0.003" /><testcase classname="tests.integration.test_mixed_language_flow.TestMixedLanguageFlow" name="test_mixed_language_token_traces" time="0.169" /><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_in_ukrainian_context" time="0.102" /><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_in_russian_context" time="0.105" /><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_with_cyrillic_surnames" time="0.168"><failure message="AssertionError: assert 'Петрова' in 'John Коваленко Mary Петров'&#10; +  where 'John Коваленко Mary Петров' = NormalizationResult(normalized='John Коваленко Mary Петров', tokens=['John', 'Коваленко', 'Mary', 'Петров'], trace=[To...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.integration.test_mixed_script_names.TestMixedScriptNames object at 0x13fa27490&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30c2513d0&gt;

    def test_ascii_names_with_cyrillic_surnames(self, service):
        """Test ASCII given names with Cyrillic surnames"""
        text = "John Коваленко и Mary Петрова работают вместе"
        result = service._normalize_sync(text, language="uk")
    
        # Check that all names are preserved
        assert "John" in result.normalized
        assert "Коваленко" in result.normalized
        assert "Mary" in result.normalized
&gt;       assert "Петрова" in result.normalized
E       AssertionError: assert 'Петрова' in 'John Коваленко Mary Петров'
E        +  where 'John Коваленко Mary Петров' = NormalizationResult(normalized='John Коваленко Mary Петров', tokens=['John', 'Коваленко', 'Mary', 'Петров'], trace=[To...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/integration/test_mixed_script_names.py:66: AssertionError</failure></testcase><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_positional_inference" time="0.094" /><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_no_morphology" time="0.175"><failure message="AssertionError: assert 'morph' not in 'morph'&#10;  &#10;  'morph' is contained here:&#10;    morph">self = &lt;tests.integration.test_mixed_script_names.TestMixedScriptNames object at 0x13fa39b50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30b51e5d0&gt;

    def test_ascii_names_no_morphology(self, service):
        """Test that ASCII names skip morphology"""
        text = "John Smith работает"
        result = service._normalize_sync(text, language="uk")
    
        # Check that ASCII names are not morphed
        john_trace = next(t for t in result.trace if t.token == "John")
        smith_trace = next(t for t in result.trace if t.token == "Smith")
    
        # Should not have morphology-related rules
        assert "morph" not in john_trace.rule.lower()
&gt;       assert "morph" not in smith_trace.rule.lower()
E       AssertionError: assert 'morph' not in 'morph'
E         
E         'morph' is contained here:
E           morph

tests/integration/test_mixed_script_names.py:106: AssertionError</failure></testcase><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_mixed_script_multiple_persons" time="0.169" /><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_with_apostrophes" time="0.117" /><testcase classname="tests.integration.test_mixed_script_names.TestMixedScriptNames" name="test_ascii_names_not_demoted_to_unknown" time="0.101" /><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_ukrainian_name_pipeline" time="6.290"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fab1a90&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30f4a1d30&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30f4a1e80&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x30ff74c20&gt;

    @pytest.mark.asyncio
    async def test_ukrainian_name_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """
        Full pipeline test for Ukrainian name
        Checks: language detected as uk, Ukrainian morphological forms generated
        """
        # Arrange
        input_text = "Олена Петрівна"
    
        # Act
        # Step 1: Language detection
        language_result = language_detection_service.detect_language(input_text)
        detected_language = language_result['language']
    
        # Step 2: Advanced normalization
        normalization_result = await advanced_normalization_service.normalize_async(
            text=input_text,
            language=detected_language
        )
    
        # Step 3: Variant generation
        variant_result = variant_generation_service.generate_variants(
            text=normalization_result.normalized,
            language=detected_language,
            max_variants=20
        )
    
        # Assert
        # Check language detection
        assert detected_language == 'uk', f"Expected Ukrainian, got {detected_language}"
        assert language_result['confidence'] &gt; 0.5
    
        # Check normalization
&gt;       assert normalization_result['language'] == 'uk'
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:51: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_russian_name_pipeline" time="0.895"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fab1590&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30e978fc0&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30d00a990&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x30d009e50&gt;

    @pytest.mark.asyncio
    async def test_russian_name_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Pipeline test for Russian name"""
        # Arrange
        input_text = "Сергей Иванов"
    
        # Act
        language_result = language_detection_service.detect_language(input_text)
        normalization_result = await advanced_normalization_service.normalize_async(
            text=input_text,
            language=language_result['language'],
            enable_morphology=True
        )
        variant_result = variant_generation_service.generate_variants(
&gt;           text=normalization_result['normalized'],
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            language=language_result['language']
        )
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:96: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_mixed_language_text_pipeline" time="0.488"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fa27820&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30f0e5bf0&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16bfc0a50&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x16e056e90&gt;

    @pytest.mark.asyncio
    async def test_mixed_language_text_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Pipeline test for mixed language text"""
        # Arrange
        input_text = "John Smith and Іван Петренко"
    
        # Act
        language_result = language_detection_service.detect_language(input_text)
        normalization_result = await advanced_normalization_service.normalize_async(
            text=input_text,
            language=language_result['language'],
            enable_morphology=True
        )
    
        # Assert
        # Language can be detected as any, but normalization should work
&gt;       assert normalization_result['language'] in ['en', 'ru', 'uk']
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:125: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_compound_name_pipeline" time="0.217"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fa27950&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30b5b0d50&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x311bac9d0&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x311baf950&gt;

    @pytest.mark.asyncio
    async def test_compound_name_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Pipeline test for compound name"""
        # Arrange
        input_text = "Жан-Поль Сартр"
    
        # Act
        language_result = language_detection_service.detect_language(input_text)
        normalization_result = await advanced_normalization_service.normalize_async(
            text=input_text,
            language=language_result['language'],
            enable_morphology=True
        )
        variant_result = variant_generation_service.generate_variants(
&gt;           text=normalization_result['normalized'],
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            language=language_result['language']
        )
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:154: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_error_resilience_pipeline" time="2.156"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fae1130&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x3128e1b70&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x312826780&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x3134ed810&gt;

    @pytest.mark.asyncio
    async def test_error_resilience_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Pipeline error resilience test"""
        # Arrange
        problematic_text = "∑∂∆ Тест ∞"
    
        # Act &amp; Assert - should not crash with error
        language_result = language_detection_service.detect_language(problematic_text)
        assert language_result is not None
    
        normalization_result = await advanced_normalization_service.normalize_async(
            text=problematic_text,
            language=language_result['language']
        )
        assert normalization_result is not None
    
        variant_result = variant_generation_service.generate_variants(
&gt;           text=normalization_result['normalized'],
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            language=language_result['language']
        )
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:199: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_empty_text_pipeline" time="0.264"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fade690&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30c00eed0&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30ff83530&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x30dd11130&gt;

    @pytest.mark.asyncio
    async def test_empty_text_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Pipeline test with empty text"""
        # Arrange
        empty_text = ""
    
        # Act
        language_result = language_detection_service.detect_language(empty_text)
        normalization_result = await advanced_normalization_service.normalize_async(
            text=empty_text,
            language=language_result['language']
        )
        variant_result = variant_generation_service.generate_variants(
&gt;           text=normalization_result['normalized'],
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            language=language_result['language']
        )
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:217: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_performance_pipeline" time="0.251"><failure message="AssertionError: assert 'token_variants' in NormalizationResult(normalized='Олександр Петренко', tokens=['Олександр', 'Петренко'], trace=[TokenTrace(token='Олекса...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fade8b0&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30e32eaf0&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30f4fd8c0&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x30f965480&gt;

    @pytest.mark.asyncio
    async def test_performance_pipeline(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Pipeline performance test"""
        # Arrange
        test_names = [
            "Олександр Петренко",
            "Maria Gonzalez",
            "Сергій Іваненко",
            "John O'Connor",
            "Анна-Марія Коваленко"
        ]
    
        # Act
        import time
        start_time = time.time()
    
        results = []
        for name in test_names:
            language_result = language_detection_service.detect_language(name)
            normalization_result = await advanced_normalization_service.normalize_async(
                text=name,
                language=language_result['language'],
                enable_morphology=True
            )
            results.append(normalization_result)
    
        end_time = time.time()
        total_time = end_time - start_time
    
        # Assert
        assert total_time &lt; 10.0, f"Pipeline should complete within 10 seconds, took {total_time:.2f}s"
        assert len(results) == len(test_names)
    
        for result in results:
            assert result is not None
&gt;           assert 'token_variants' in result
E           AssertionError: assert 'token_variants' in NormalizationResult(normalized='Олександр Петренко', tokens=['Олександр', 'Петренко'], trace=[TokenTrace(token='Олекса...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')

tests/integration/test_normalization_pipeline.py:262: AssertionError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_language_detection_consistency" time="0.163" /><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_morphology_integration" time="0.122"><failure message="AttributeError: 'NormalizationResult' object has no attribute 'get'">self = NormalizationResult(normalized='', tokens=[], trace=[], errors=[], language='ru', confidence=1.0, original_length=9, n..._core=[], organizations_core=[], persons=[], person_gender=None, gender_confidence=None, organizations=[], org_core='')
item = 'get'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
&gt;                   return pydantic_extra[item]
                           ^^^^^^^^^^^^^^^^^^^^
E                   KeyError: 'get'

venv/lib/python3.13/site-packages/pydantic/main.py:983: KeyError

The above exception was the direct cause of the following exception:

self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13fa16450&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30fd5e8d0&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30e9e1450&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x30e9e1050&gt;

    @pytest.mark.asyncio
    async def test_morphology_integration(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Morphological analysis integration test"""
        # Arrange
        ukrainian_name = "Володимир"
    
        # Act
        language_result = language_detection_service.detect_language(ukrainian_name)
        normalization_result = await advanced_normalization_service.normalize_async(
            text=ukrainian_name,
            language=language_result['language'],
            enable_morphology=True,
            clean_unicode=False  # Preserve Cyrillic text for morphological analysis
        )
    
        # Assert
        # Language detection may vary, so just check that it's one of the supported languages
        assert language_result['language'] in ['uk', 'ru', 'en']
    
        # Check that morphological analysis worked
&gt;       names_analysis = normalization_result.get('names_analysis', [])
                         ^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_normalization_pipeline.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NormalizationResult(normalized='', tokens=[], trace=[], errors=[], language='ru', confidence=1.0, original_length=9, n..._core=[], organizations_core=[], persons=[], person_gender=None, gender_confidence=None, organizations=[], org_core='')
item = 'get'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
E                   AttributeError: 'NormalizationResult' object has no attribute 'get'

venv/lib/python3.13/site-packages/pydantic/main.py:985: AttributeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_transliteration_integration" time="0.106"><failure message="TypeError: 'NormalizationResult' object is not subscriptable">self = &lt;tests.integration.test_normalization_pipeline.TestNormalizationPipeline object at 0x13f84f5c0&gt;
language_detection_service = &lt;src.ai_service.layers.language.language_detection_service.LanguageDetectionService object at 0x30dd2d850&gt;
advanced_normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x30e9e2e50&gt;
variant_generation_service = &lt;src.ai_service.layers.variants.variant_generation_service.VariantGenerationService object at 0x30e9e3250&gt;

    @pytest.mark.asyncio
    async def test_transliteration_integration(self, language_detection_service, advanced_normalization_service, variant_generation_service):
        """Transliteration integration test"""
        # Arrange
        cyrillic_name = "Сергій"
    
        # Act
        language_result = language_detection_service.detect_language(cyrillic_name)
        normalization_result = await advanced_normalization_service.normalize_async(
            text=cyrillic_name,
            language=language_result['language'],
            enable_transliterations=True
        )
    
        # Assert
&gt;       token_variants = normalization_result['token_variants']
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NormalizationResult' object is not subscriptable

tests/integration/test_normalization_pipeline.py:328: TypeError</failure></testcase><testcase classname="tests.integration.test_normalization_pipeline.TestNormalizationPipeline" name="test_variant_generation_integration" time="0.107" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_high_risk_scenario" time="0.269" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_skip_scenario_smartfilter_false" time="0.068" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_medium_risk_scenario" time="0.064" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_low_risk_scenario" time="2.664" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_decision_engine_disabled" time="0.169" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_decision_input_creation" time="0.210" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_risk_level_determination" time="0.061" /><testcase classname="tests.integration.test_orchestrator_decision_integration.TestOrchestratorDecisionIntegration" name="test_decision_reasons_generation" time="0.067" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_single_person_normalization" time="0.067" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_multiple_persons_with_conjunction" time="0.061" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_persons_with_patronymics" time="0.118" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_persons_with_initials" time="0.067" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_persons_with_comma_separator" time="0.263" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_persons_with_mixed_separators" time="0.088" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_persons_with_non_person_tokens" time="0.059" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_persons_data_structure" time="0.912" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_empty_text" time="0.183" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_text_without_persons" time="0.103" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_ukrainian_persons" time="0.063" /><testcase classname="tests.integration.test_persons_grouping.TestPersonsGroupingIntegration" name="test_english_persons" time="0.069" /><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[ukrainian_simple_name]" time="0.268" /><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[ukrainian_full_name_with_patronymic]" time="0.011" /><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[ukrainian_company_with_legal_form]" time="0.004"><failure message="AssertionError: Expected 1 orgs, got 0&#10;assert 0 == 1&#10; +  where 0 = len([])&#10; +    where [] = &lt;ai_service.layers.signals.signals_service.SignalsService.extract_signals.&lt;locals&gt;.ResultWrapper object at 0x318534ad0&gt;.organizations&#10; +      where &lt;ai_service.layers.signals.signals_service.SignalsService.extract_signals.&lt;locals&gt;.ResultWrapper object at 0x318534ad0&gt; = UnifiedProcessingResult(original_text=&quot;ТОВ 'ПриватБанк'&quot;, language='ru', language_confidence=0.6, normalized_text='', ...318534ad0&gt;, variants=None, embeddings=None, decision=None, processing_time=0.0017242431640625, success=True, errors=[]).signals&#10; +  and   1 = len([{'core': 'ПриватБанк', 'full_name': 'ТОВ ПриватБанк', 'legal_form': 'ТОВ'}])&#10; +    where [{'core': 'ПриватБанк', 'full_name': 'ТОВ ПриватБанк', 'legal_form': 'ТОВ'}] = IntegrationTestCase(name='ukrainian_company_with_legal_form', input_text=&quot;ТОВ 'ПриватБанк'&quot;, expected_language='ru', e...cess=True, expected_trace_roles=[], notes='Company with legal form - legal form handled by Signals, not Normalization').expected_organizations">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fb24640&gt;
test_case = IntegrationTestCase(name='ukrainian_company_with_legal_form', input_text="ТОВ 'ПриватБанк'", expected_language='ru', e...cess=True, expected_trace_roles=[], notes='Company with legal form - legal form handled by Signals, not Normalization')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
        assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
    
        # 2. Smart Filter Layer Tests
        smart_filter_meta = result.__dict__.get('metadata', {}).get('smart_filter', {})
        if smart_filter_meta:
            detected_signals = smart_filter_meta.get('detected_signals', [])
            for expected_signal in test_case.expected_smart_filter_signals:
                assert expected_signal in detected_signals, \
                    f"Expected smart filter signal '{expected_signal}' not found in {detected_signals}"
    
        # 3. Normalization Layer Tests (THE CORE)
        assert result.normalized_text == test_case.expected_normalized, \
            f"Expected normalized '{test_case.expected_normalized}', got '{result.normalized_text}'"
    
        # 4. TokenTrace Validation (per CLAUDE.md requirement)
        if test_case.expected_trace_roles:
            trace_roles = [trace.role for trace in result.trace if hasattr(trace, 'role')]
            assert trace_roles == test_case.expected_trace_roles, \
                f"Expected trace roles {test_case.expected_trace_roles}, got {trace_roles}"
    
        # 5. Signals Layer Tests - Persons
        assert len(result.signals.persons) == len(test_case.expected_persons), \
            f"Expected {len(test_case.expected_persons)} persons, got {len(result.signals.persons)}"
    
        for i, expected_person in enumerate(test_case.expected_persons):
            if i &lt; len(result.signals.persons):
                actual_person = result.signals.persons[i]
                assert actual_person.core == expected_person["core"], \
                    f"Person {i} core mismatch: expected {expected_person['core']}, got {actual_person.core}"
    
                if expected_person["dob"]:
                    assert actual_person.dob == expected_person["dob"], \
                        f"Person {i} DOB mismatch: expected {expected_person['dob']}, got {actual_person.dob}"
    
        # 6. Signals Layer Tests - Organizations
&gt;       assert len(result.signals.organizations) == len(test_case.expected_organizations), \
            f"Expected {len(test_case.expected_organizations)} orgs, got {len(result.signals.organizations)}"
E       AssertionError: Expected 1 orgs, got 0
E       assert 0 == 1
E        +  where 0 = len([])
E        +    where [] = &lt;ai_service.layers.signals.signals_service.SignalsService.extract_signals.&lt;locals&gt;.ResultWrapper object at 0x318534ad0&gt;.organizations
E        +      where &lt;ai_service.layers.signals.signals_service.SignalsService.extract_signals.&lt;locals&gt;.ResultWrapper object at 0x318534ad0&gt; = UnifiedProcessingResult(original_text="ТОВ 'ПриватБанк'", language='ru', language_confidence=0.6, normalized_text='', ...318534ad0&gt;, variants=None, embeddings=None, decision=None, processing_time=0.0017242431640625, success=True, errors=[]).signals
E        +  and   1 = len([{'core': 'ПриватБанк', 'full_name': 'ТОВ ПриватБанк', 'legal_form': 'ТОВ'}])
E        +    where [{'core': 'ПриватБанк', 'full_name': 'ТОВ ПриватБанк', 'legal_form': 'ТОВ'}] = IntegrationTestCase(name='ukrainian_company_with_legal_form', input_text="ТОВ 'ПриватБанк'", expected_language='ru', e...cess=True, expected_trace_roles=[], notes='Company with legal form - legal form handled by Signals, not Normalization').expected_organizations

tests/integration/test_pipeline_end2end.py:374: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[mixed_person_and_company]" time="0.005"><failure message="AssertionError: Expected normalized 'П. І. Коваленко', got 'П. І. Коваленко Агросвіт'&#10;assert 'П. І. Коваленко Агросвіт' == 'П. І. Коваленко'&#10;  &#10;  - П. І. Коваленко&#10;  + П. І. Коваленко Агросвіт&#10;  ?                +++++++++">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fb24770&gt;
test_case = IntegrationTestCase(name='mixed_person_and_company', input_text="Рахунок від П.І. Коваленко, ТОВ 'Агросвіт'", expected...ce_roles=['initial', 'initial', 'surname'], notes='Mixed person with initials and company - proper initial formatting')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
        assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
    
        # 2. Smart Filter Layer Tests
        smart_filter_meta = result.__dict__.get('metadata', {}).get('smart_filter', {})
        if smart_filter_meta:
            detected_signals = smart_filter_meta.get('detected_signals', [])
            for expected_signal in test_case.expected_smart_filter_signals:
                assert expected_signal in detected_signals, \
                    f"Expected smart filter signal '{expected_signal}' not found in {detected_signals}"
    
        # 3. Normalization Layer Tests (THE CORE)
&gt;       assert result.normalized_text == test_case.expected_normalized, \
            f"Expected normalized '{test_case.expected_normalized}', got '{result.normalized_text}'"
E       AssertionError: Expected normalized 'П. І. Коваленко', got 'П. І. Коваленко Агросвіт'
E       assert 'П. І. Коваленко Агросвіт' == 'П. І. Коваленко'
E         
E         - П. І. Коваленко
E         + П. І. Коваленко Агросвіт
E         ?                +++++++++

tests/integration/test_pipeline_end2end.py:350: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[person_with_birth_date]" time="0.011" /><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[person_with_inn]" time="0.006"><failure message="AssertionError: Expected normalized 'П. С. Іванов', got 'Иванов П. С.'&#10;assert 'Иванов П. С.' == 'П. С. Іванов'&#10;  &#10;  - П. С. Іванов&#10;  + Иванов П. С.">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fadf130&gt;
test_case = IntegrationTestCase(name='person_with_inn', input_text='Платеж Иванову П.С., ІПН 1234567890', expected_language='uk', ...e, expected_trace_roles=['initial', 'initial', 'surname'], notes='Person with INN - signals should extract identifier')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
        assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
    
        # 2. Smart Filter Layer Tests
        smart_filter_meta = result.__dict__.get('metadata', {}).get('smart_filter', {})
        if smart_filter_meta:
            detected_signals = smart_filter_meta.get('detected_signals', [])
            for expected_signal in test_case.expected_smart_filter_signals:
                assert expected_signal in detected_signals, \
                    f"Expected smart filter signal '{expected_signal}' not found in {detected_signals}"
    
        # 3. Normalization Layer Tests (THE CORE)
&gt;       assert result.normalized_text == test_case.expected_normalized, \
            f"Expected normalized '{test_case.expected_normalized}', got '{result.normalized_text}'"
E       AssertionError: Expected normalized 'П. С. Іванов', got 'Иванов П. С.'
E       assert 'Иванов П. С.' == 'П. С. Іванов'
E         
E         - П. С. Іванов
E         + Иванов П. С.

tests/integration/test_pipeline_end2end.py:350: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[mixed_script_names]" time="0.003"><failure message="AssertionError: Expected normalized 'John Smith Олена Петренко', got 'John Smith'&#10;assert 'John Smith' == 'John Smith Олена Петренко'&#10;  &#10;  - John Smith Олена Петренко&#10;  + John Smith">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fadf350&gt;
test_case = IntegrationTestCase(name='mixed_script_names', input_text='Payment for John Smith and Олена Петренко', expected_langua...['given', 'surname', 'given', 'surname'], notes='Mixed script - ASCII names in Cyrillic context should not be morphed')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
        assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
    
        # 2. Smart Filter Layer Tests
        smart_filter_meta = result.__dict__.get('metadata', {}).get('smart_filter', {})
        if smart_filter_meta:
            detected_signals = smart_filter_meta.get('detected_signals', [])
            for expected_signal in test_case.expected_smart_filter_signals:
                assert expected_signal in detected_signals, \
                    f"Expected smart filter signal '{expected_signal}' not found in {detected_signals}"
    
        # 3. Normalization Layer Tests (THE CORE)
&gt;       assert result.normalized_text == test_case.expected_normalized, \
            f"Expected normalized '{test_case.expected_normalized}', got '{result.normalized_text}'"
E       AssertionError: Expected normalized 'John Smith Олена Петренко', got 'John Smith'
E       assert 'John Smith' == 'John Smith Олена Петренко'
E         
E         - John Smith Олена Петренко
E         + John Smith

tests/integration/test_pipeline_end2end.py:350: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[noise_context_should_filter]" time="0.006" /><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[quoted_company_with_person]" time="0.009"><failure message="AssertionError: Language confidence 0.75 below minimum 0.8&#10;assert 0.75 &gt;= 0.8&#10; +  where 0.75 = UnifiedProcessingResult(original_text=&quot;ООО 'Тест Системс' перевод средств Ивану Петрову&quot;, language='ru', language_conf...349ef90&gt;, variants=None, embeddings=None, decision=None, processing_time=0.007681131362915039, success=True, errors=[]).language_confidence&#10; +  and   0.8 = IntegrationTestCase(name='quoted_company_with_person', input_text=&quot;ООО 'Тест Системс' перевод средств Ивану Петрову&quot;, ...ected_should_process=True, expected_trace_roles=['given', 'surname'], notes='Quoted company name with person transfer').expected_language_confidence_min">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fa17450&gt;
test_case = IntegrationTestCase(name='quoted_company_with_person', input_text="ООО 'Тест Системс' перевод средств Ивану Петрову", ...ected_should_process=True, expected_trace_roles=['given', 'surname'], notes='Quoted company name with person transfer')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
&gt;       assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
E       AssertionError: Language confidence 0.75 below minimum 0.8
E       assert 0.75 &gt;= 0.8
E        +  where 0.75 = UnifiedProcessingResult(original_text="ООО 'Тест Системс' перевод средств Ивану Петрову", language='ru', language_conf...349ef90&gt;, variants=None, embeddings=None, decision=None, processing_time=0.007681131362915039, success=True, errors=[]).language_confidence
E        +  and   0.8 = IntegrationTestCase(name='quoted_company_with_person', input_text="ООО 'Тест Системс' перевод средств Ивану Петрову", ...ected_should_process=True, expected_trace_roles=['given', 'surname'], notes='Quoted company name with person transfer').expected_language_confidence_min

tests/integration/test_pipeline_end2end.py:338: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[hyphenated_surname]" time="0.014"><failure message="AssertionError: Expected normalized 'Марія Коцюбинська-Гончаренко', got 'Марії Коцюбинський-Гончаренко'&#10;assert 'Марії Коцюби...ий-Гончаренко' == 'Марія Коцюбинська-Гончаренко'&#10;  &#10;  - Марія Коцюбинська-Гончаренко&#10;  ?     ^           ^&#10;  + Марії Коцюбинський-Гончаренко&#10;  ?     ^           ^^">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fb40230&gt;
test_case = IntegrationTestCase(name='hyphenated_surname', input_text='Платеж для Марії Коцюбинської-Гончаренко', expected_languag...ocess=True, expected_trace_roles=['given', 'surname'], notes='Hyphenated surname - preserve_names should keep hyphens')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
        assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
    
        # 2. Smart Filter Layer Tests
        smart_filter_meta = result.__dict__.get('metadata', {}).get('smart_filter', {})
        if smart_filter_meta:
            detected_signals = smart_filter_meta.get('detected_signals', [])
            for expected_signal in test_case.expected_smart_filter_signals:
                assert expected_signal in detected_signals, \
                    f"Expected smart filter signal '{expected_signal}' not found in {detected_signals}"
    
        # 3. Normalization Layer Tests (THE CORE)
&gt;       assert result.normalized_text == test_case.expected_normalized, \
            f"Expected normalized '{test_case.expected_normalized}', got '{result.normalized_text}'"
E       AssertionError: Expected normalized 'Марія Коцюбинська-Гончаренко', got 'Марії Коцюбинський-Гончаренко'
E       assert 'Марії Коцюби...ий-Гончаренко' == 'Марія Коцюбинська-Гончаренко'
E         
E         - Марія Коцюбинська-Гончаренко
E         ?     ^           ^
E         + Марії Коцюбинський-Гончаренко
E         ?     ^           ^^

tests/integration/test_pipeline_end2end.py:350: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[overfit_canary]" time="0.007"><failure message="AssertionError: Expected language uk, got ru&#10;assert 'ru' == 'uk'&#10;  &#10;  - uk&#10;  + ru">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fb40320&gt;
test_case = IntegrationTestCase(name='overfit_canary', input_text='клавиатура, рахунок, дисплей, table', expected_language='uk', e... expected_should_process=False, expected_trace_roles=[], notes='Overfit canary - random words should not become names')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
&gt;       assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
E       AssertionError: Expected language uk, got ru
E       assert 'ru' == 'uk'
E         
E         - uk
E         + ru

tests/integration/test_pipeline_end2end.py:335: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_pipeline_integration[full_pipeline_stress_test]" time="0.012"><failure message="AssertionError: Expected normalized 'Іваненко Іван Іванович', got 'Агросвіт Іваненко Іван Іванович'&#10;assert 'Агросвіт Іва...Іван Іванович' == 'Іваненко Іван Іванович'&#10;  &#10;  - Іваненко Іван Іванович&#10;  + Агросвіт Іваненко Іван Іванович&#10;  ? +++++++++">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13faf9fd0&gt;
test_case = IntegrationTestCase(name='full_pipeline_stress_test', input_text="ТОВ 'Агросвіт', ФОП Іваненко Іван Іванович, ІПН 1234...expected_trace_roles=['surname', 'given', 'patronymic'], notes='Full pipeline stress test - all signals types present')

    @pytest.mark.parametrize("test_case", INTEGRATION_TEST_CASES, ids=lambda tc: tc.name)
    async def test_pipeline_integration(self, test_case: IntegrationTestCase):
        """Test complete pipeline integration with real payment scenarios"""
    
        logger.info(f"Testing: {test_case.name} - {test_case.notes}")
        logger.info(f"Input: {test_case.input_text}")
    
        # Process through unified pipeline
        result = await self.orchestrator.process(
            text=test_case.input_text,
            # Test with production-like settings per CLAUDE.md
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=False,  # Focus on core functionality
            generate_embeddings=False
        )
    
        # Assert processing succeeded
        if test_case.expected_should_process:
            assert result.success, f"Processing should succeed but failed: {result.errors}"
    
        # 1. Language Detection Layer Tests
        assert result.language == test_case.expected_language, \
            f"Expected language {test_case.expected_language}, got {result.language}"
    
        assert result.language_confidence &gt;= test_case.expected_language_confidence_min, \
            f"Language confidence {result.language_confidence} below minimum {test_case.expected_language_confidence_min}"
    
        # 2. Smart Filter Layer Tests
        smart_filter_meta = result.__dict__.get('metadata', {}).get('smart_filter', {})
        if smart_filter_meta:
            detected_signals = smart_filter_meta.get('detected_signals', [])
            for expected_signal in test_case.expected_smart_filter_signals:
                assert expected_signal in detected_signals, \
                    f"Expected smart filter signal '{expected_signal}' not found in {detected_signals}"
    
        # 3. Normalization Layer Tests (THE CORE)
&gt;       assert result.normalized_text == test_case.expected_normalized, \
            f"Expected normalized '{test_case.expected_normalized}', got '{result.normalized_text}'"
E       AssertionError: Expected normalized 'Іваненко Іван Іванович', got 'Агросвіт Іваненко Іван Іванович'
E       assert 'Агросвіт Іва...Іван Іванович' == 'Іваненко Іван Іванович'
E         
E         - Іваненко Іван Іванович
E         + Агросвіт Іваненко Іван Іванович
E         ? +++++++++

tests/integration/test_pipeline_end2end.py:350: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_normalization_flags_behavior" time="0.009"><failure message="AssertionError: Flags should produce different results but all were identical: ['Іван Петрович Сидоренко', 'Іван Петрович Сидоренко', 'Іван Петрович Сидоренко', 'Іван Петрович Сидоренко']&#10;assert 1 &gt; 1&#10; +  where 1 = len({'Іван Петрович Сидоренко'})">self = &lt;tests.integration.test_pipeline_end2end.TestPipelineEnd2End object at 0x13fa79e10&gt;

    async def test_normalization_flags_behavior(self):
        """Test that normalization flags actually change behavior (CLAUDE.md requirement)"""
    
        test_text = "Іван Петрович Сидоренко и ООО компания"
    
        # Test different flag combinations
        flag_combinations = [
            {"remove_stop_words": True, "preserve_names": True, "enable_advanced_features": True},
            {"remove_stop_words": False, "preserve_names": True, "enable_advanced_features": True},
            {"remove_stop_words": True, "preserve_names": False, "enable_advanced_features": True},
            {"remove_stop_words": True, "preserve_names": True, "enable_advanced_features": False},
        ]
    
        results = []
        for flags in flag_combinations:
            result = await self.orchestrator.process(text=test_text, **flags)
            results.append((flags, result.normalized_text, len(result.tokens)))
    
        # Verify flags produce different results
        normalized_results = [r[1] for r in results]
        unique_results = set(normalized_results)
    
&gt;       assert len(unique_results) &gt; 1, \
            f"Flags should produce different results but all were identical: {normalized_results}"
E       AssertionError: Flags should produce different results but all were identical: ['Іван Петрович Сидоренко', 'Іван Петрович Сидоренко', 'Іван Петрович Сидоренко', 'Іван Петрович Сидоренко']
E       assert 1 &gt; 1
E        +  where 1 = len({'Іван Петрович Сидоренко'})

tests/integration/test_pipeline_end2end.py:413: AssertionError</failure></testcase><testcase classname="tests.integration.test_pipeline_end2end.TestPipelineEnd2End" name="test_performance_requirements" time="0.006" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_initials_only" time="0.003" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_english_initials_with_surname" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_mixed_initials_and_full_name" time="0.003" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_russian_organization_ooo" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_ukrainian_organization_tov" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_english_organization_llc" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_organization_with_person_name" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_multiple_organizations" time="0.003" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_person_and_organization_mixed" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_organization_with_quotes" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_initials_with_organization" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_multiple_legal_forms" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_organization_with_numbers" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_foreign_organization" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_initials_without_periods" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_organization_in_sentence" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_mixed_case_organization" time="0.001" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_organization_with_address" time="0.002" /><testcase classname="tests.integration.test_pipeline_initials_orgs.TestPipelineInitialsOrgsCase" name="test_no_unknown_in_normalized_output" time="0.001" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_full_name" time="0.002" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_name_with_apostrophe" time="0.002" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_hyphenated_name" time="0.002" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_mixed_english_ukrainian" time="0.001" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_mixed_english_russian" time="0.002" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_initials" time="0.002" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_name_with_title" time="0.001" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_transliterated_name" time="0.002" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_multiple_english_names" time="0.003" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_name_with_middle_initial" time="0.001" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_compound_surname" time="0.001" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_english_name_case_insensitive" time="0.001" /><testcase classname="tests.integration.test_pipeline_mixed_en.TestPipelineMixedEnglishCases" name="test_three_language_mix" time="0.004" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_empty_text" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_whitespace_only" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_numbers_only" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_punctuation_only" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_stop_words_only" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_random_gibberish" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_special_characters" time="0.003" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_emoji_only" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_very_long_text" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_mixed_scripts_nonsense" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_common_words_not_names" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_dates_and_addresses" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_currencies_and_amounts" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_technical_terms" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_medical_terms" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_country_and_city_names" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_brand_names" time="0.001" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_malformed_input" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_sql_injection_attempt" time="0.002" /><testcase classname="tests.integration.test_pipeline_negative_canaries.TestPipelineNegativeCanaries" name="test_no_unknown_tokens_in_output" time="0.003" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_full_name_with_patronymic" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_full_name_with_patronymic" time="0.003" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_female_name_with_patronymic" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_female_name_with_patronymic" time="0.003" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_double_surname" time="0.004" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_double_surname" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_with_initials" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_with_initials" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_compound_name" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_compound_name" time="0.004" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_with_apostrophe" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_with_apostrophe" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_multiple_ukrainian_names" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_multiple_russian_names" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_with_typos" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_with_typos" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_with_numbers" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_with_numbers" time="0.003" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_with_punctuation" time="0.006" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_with_punctuation" time="0.006" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_with_extra_spaces" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_with_extra_spaces" time="0.002" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_ukrainian_name_case_insensitive" time="0.001" /><testcase classname="tests.integration.test_pipeline_ru_uk_cases.TestPipelineRuUkCases" name="test_russian_name_case_insensitive" time="0.001" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u0410\u043b\u043b\u044b \u0411\u043e\u0440\u0438\u0441\u043e\u0432\u043d\u044b \u041f\u0443\u0433\u0430\u0447\u0435\u0432\u043e\u0439-\u0410\u043b\u043b\u0430 \u0411\u043e\u0440\u0438\u0441\u043e\u0432\u043d\u0430 \u041f\u0443\u0433\u0430\u0447\u0435\u0432\u0430-ru]" time="0.061"><failure message="AssertionError: Ожидалось: {'пугачева', 'алла', 'борисовна'}, получено: {'пугачев', 'аллы', 'борисовн'}&#10;assert {'алла', 'бор...', 'пугачева'} == {'аллы', 'бор...н', 'пугачев'}&#10;  &#10;  Extra items in the left set:&#10;  'пугачева'&#10;  'алла'&#10;  'борисовна'&#10;  Extra items in the right set:&#10;  'пугачев'...&#10;  &#10;  ...Full output truncated (3 lines hidden), use '-vv' to show">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x3142e5cd0&gt;
input_text = 'Аллы Борисовны Пугачевой'
expected_name = 'Алла Борисовна Пугачева', lang = 'ru'

    @pytest.mark.parametrize("input_text, expected_name, lang", role_based_test_cases)
    def test_role_based_slavic_normalization(normalization_service, input_text, expected_name, lang):
        """
        Tests the new role-based normalization logic with specific cases.
        """
        result = normalization_service.normalize(input_text, language=lang)
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_role_based_normalization.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Аллы Борисовн Пугачев', tokens=['Аллы', 'Борисовн', 'Пугачев'], trace=[TokenTrace(toke...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Алла Борисовна Пугачева'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'пугачева', 'алла', 'борисовна'}, получено: {'пугачев', 'аллы', 'борисовн'}
E       assert {'алла', 'бор...', 'пугачева'} == {'аллы', 'бор...н', 'пугачев'}
E         
E         Extra items in the left set:
E         'пугачева'
E         'алла'
E         'борисовна'
E         Extra items in the right set:
E         'пугачев'...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u041f\u0435\u0442\u0440\u0443 \u0427\u0430\u0439\u043a\u043e\u0432\u0441\u043a\u043e\u043c\u0443-\u041f\u0435\u0442\u0440 \u0427\u0430\u0439\u043a\u043e\u0432\u0441\u043a\u0438\u0439-ru]" time="0.083"><failure message="AssertionError: Ожидалось: {'чайковский', 'петр'}, получено: {'чайковском', 'петр'}&#10;assert {'петр', 'чайковский'} == {'петр', 'чайковском'}&#10;  &#10;  Extra items in the left set:&#10;  'чайковский'&#10;  Extra items in the right set:&#10;  'чайковском'&#10;  Use -v to get more diff">normalization_service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x13fbba0d0&gt;
input_text = 'Петру Чайковскому', expected_name = 'Петр Чайковский', lang = 'ru'

    @pytest.mark.parametrize("input_text, expected_name, lang", role_based_test_cases)
    def test_role_based_slavic_normalization(normalization_service, input_text, expected_name, lang):
        """
        Tests the new role-based normalization logic with specific cases.
        """
        result = normalization_service.normalize(input_text, language=lang)
&gt;       assert_normalized_name(result, expected_name)

tests/integration/test_role_based_normalization.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Петр Чайковском', tokens=['Петр', 'Чайковском'], trace=[TokenTrace(token='Петру', role...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Петр Чайковский'

    def assert_normalized_name(result, expected_name):
        """
        Сравнивает нормализованный результат с ожидаемым именем.
        Игнорирует регистр, лишние пробелы и порядок слов.
        Требует точного совпадения наборов токенов.
        """
        # Приводим ожидаемый результат к набору слов в нижнем регистре
        expected_parts = set(expected_name.lower().split())
    
        # Получаем реальные токены из результата
        actual_tokens = {token.lower() for token in result.tokens if token.strip()}
    
        # Проверяем, что наборы токенов в точности совпадают
&gt;       assert expected_parts == actual_tokens, \
            f"Ожидалось: {expected_parts}, получено: {actual_tokens}"
E       AssertionError: Ожидалось: {'чайковский', 'петр'}, получено: {'чайковском', 'петр'}
E       assert {'петр', 'чайковский'} == {'петр', 'чайковском'}
E         
E         Extra items in the left set:
E         'чайковский'
E         Extra items in the right set:
E         'чайковском'
E         Use -v to get more diff

tests/integration/test_full_normalization_suite.py:38: AssertionError</failure></testcase><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u0421\u0435\u0440\u0433\u0456\u0454\u0432\u0456 \u0416\u0430\u0434\u0430\u043d\u0443-\u0421\u0435\u0440\u0433\u0456\u0439 \u0416\u0430\u0434\u0430\u043d-uk]" time="0.062" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u041e\u043a\u0441\u0430\u043d\u0456 \u0417\u0430\u0431\u0443\u0436\u043a\u043e-\u041e\u043a\u0441\u0430\u043d\u0430 \u0417\u0430\u0431\u0443\u0436\u043a\u043e-uk]" time="0.062" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u041f\u0435\u0442\u0440\u0430 \u0418\u0432\u0430\u043d\u043e\u0432\u0430-\u041f\u0435\u0442\u0440\u043e \u0418\u0432\u0430\u043d\u043e\u0432-uk]" time="0.052" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u043e\u0442 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u0430 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447\u0430-\u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447-ru]" time="0.055" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u0434\u043b\u044f \u0406\u0432\u0430\u043d\u0456\u0432\u043d\u0438-\u0406\u0432\u0430\u043d\u0456\u0432\u043d\u0430-uk]" time="0.068" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u0414\u043b\u044f \u0406\u0432\u0430\u043d\u043e\u0432\u0430-\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u0430 \u0421.\u0412.-\u0406\u0432\u0430\u043d\u043e\u0432-\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u043e \u0421. \u0412.-uk]" time="0.736" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[Payment from JOHN DOE-John Doe-en]" time="0.064" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u041e\u043f\u043b\u0430\u0442\u0430 \u0432\u0456\u0434 \u041f\u0435\u0442\u0440\u0430 \u041f\u043e\u0440\u043e\u0448\u0435\u043d\u043a\u0430-\u041f\u0435\u0442\u0440\u043e \u041f\u043e\u0440\u043e\u0448\u0435\u043d\u043a\u043e-uk]" time="0.049" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u0415\u0441\u0435\u043d\u0438\u043d \u0441. \u0430.-\u0415\u0441\u0435\u043d\u0438\u043d \u0421. \u0410.-ru]" time="0.053" /><testcase classname="tests.integration.test_role_based_normalization" name="test_role_based_slavic_normalization[\u043f\u0443\u0448\u043a\u0438\u043d \u0430 \u0441-\u041f\u0443\u0448\u043a\u0438\u043d \u0410. \u0421.-ru]" time="0.045" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_russian_complex_sentence" time="0.065" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_ukrainian_complex_sentence" time="0.050" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_mixed_case_names" time="0.060" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_compound_surnames" time="0.062" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_quoted_names" time="0.096" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_organizations_with_personal_names" time="0.090" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_multiple_persons_same_surname" time="0.066"><failure message="AssertionError: assert 'Владимир Петров' in 'Владимир Анна Петров'&#10; +  where 'Владимир Анна Петров' = NormalizationResult(normalized='Владимир Анна Петров', tokens=['Владимир', 'Анна', 'Петров'], trace=[TokenTrace(token=...re_female': 3, 'score_male': 2, 'gap': 1}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences object at 0x13fb8c9e0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x31ccdc4d0&gt;

    def test_multiple_persons_same_surname(self, service):
        """Test multiple persons with same surname"""
        text = "Владимир и Анна Петровы работают вместе"
        result = service._normalize_sync(text, language="ru")
    
        # Check that both names are normalized with correct gender
&gt;       assert "Владимир Петров" in result.normalized
E       AssertionError: assert 'Владимир Петров' in 'Владимир Анна Петров'
E        +  where 'Владимир Анна Петров' = NormalizationResult(normalized='Владимир Анна Петров', tokens=['Владимир', 'Анна', 'Петров'], trace=[TokenTrace(token=...re_female': 3, 'score_male': 2, 'gap': 1}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/integration/test_ru_uk_sentences.py:97: AssertionError</failure></testcase><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_diminutives_in_context" time="0.081" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_ukrainian_diminutives_in_context" time="0.074" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_english_names_in_ukrainian_context" time="0.046" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_initial_handling_in_sentences" time="0.087" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_patronymic_variations" time="0.071" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_surname_variations" time="1.259"><failure message="AssertionError: assert 'Петрова' in 'Петров Петров Петров Петров'&#10; +  where 'Петров Петров Петров Петров' = NormalizationResult(normalized='Петров Петров Петров Петров', tokens=['Петров', 'Петров', 'Петров', 'Петров'], trace=[...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences object at 0x13fb9b3f0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x31f621050&gt;

    def test_surname_variations(self, service):
        """Test various surname forms"""
        text = "Петров, Петрова, Петровым, Петрову"
        result = service._normalize_sync(text, language="ru")
    
        # Check that surnames are normalized to nominative
        assert "Петров" in result.normalized
&gt;       assert "Петрова" in result.normalized
E       AssertionError: assert 'Петрова' in 'Петров Петров Петров Петров'
E        +  where 'Петров Петров Петров Петров' = NormalizationResult(normalized='Петров Петров Петров Петров', tokens=['Петров', 'Петров', 'Петров', 'Петров'], trace=[...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/integration/test_ru_uk_sentences.py:161: AssertionError</failure></testcase><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_ukrainian_surname_variations" time="0.133" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_organization_legal_forms_filtering" time="0.084"><failure message="AssertionError: assert 'EXAMPLE' in ['ПРИВАТБАНК', 'ТЕСТ']&#10; +  where ['ПРИВАТБАНК', 'ТЕСТ'] = NormalizationResult(normalized='Example', tokens=['Example'], trace=[TokenTrace(token='ПРИВАТБАНК', role='org', rule='...p': 0}}], person_gender=None, gender_confidence=None, organizations=['ПРИВАТБАНК', 'ТЕСТ'], org_core='ПРИВАТБАНК ТЕСТ').organizations">self = &lt;tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences object at 0x13fb2e690&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x31428df50&gt;

    def test_organization_legal_forms_filtering(self, service):
        """Test that legal forms are filtered out"""
        text = "ТОВ 'ПРИВАТБАНК' ООО 'ТЕСТ' LLC 'EXAMPLE'"
        result = service._normalize_sync(text, language="uk")
    
        # Check that legal forms are not in normalized
        assert "ТОВ" not in result.normalized
        assert "ООО" not in result.normalized
        assert "LLC" not in result.normalized
    
        # Check that organization cores are extracted
        assert "ПРИВАТБАНК" in result.organizations
        assert "ТЕСТ" in result.organizations
&gt;       assert "EXAMPLE" in result.organizations
E       AssertionError: assert 'EXAMPLE' in ['ПРИВАТБАНК', 'ТЕСТ']
E        +  where ['ПРИВАТБАНК', 'ТЕСТ'] = NormalizationResult(normalized='Example', tokens=['Example'], trace=[TokenTrace(token='ПРИВАТБАНК', role='org', rule='...p': 0}}], person_gender=None, gender_confidence=None, organizations=['ПРИВАТБАНК', 'ТЕСТ'], org_core='ПРИВАТБАНК ТЕСТ').organizations

tests/integration/test_ru_uk_sentences.py:184: AssertionError</failure></testcase><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_performance_with_long_text" time="0.091"><failure message="AssertionError: assert 'Анна Петровна Сидорова' in 'Петр Иванович Коваленко Анна Петровна Сидоров Владимир Сергеевич Петров Елена Александровна Козлов Михаил Николаевич Смирнов Ольга Владимировна Морозов'&#10; +  where 'Петр Иванович Коваленко Анна Петровна Сидоров Владимир Сергеевич Петров Елена Александровна Козлов Михаил Николаевич Смирнов Ольга Владимировна Морозов' = NormalizationResult(normalized='Петр Иванович Коваленко Анна Петровна Сидоров Владимир Сергеевич Петров Елена Александ...female': 18, 'score_male': 28, 'gap': 10}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences object at 0x13fb2e750&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x31b7fee50&gt;

    def test_performance_with_long_text(self, service):
        """Test performance with longer text"""
        text = " ".join([
            "Петр Иванович Коваленко", "Анна Петровна Сидорова",
            "Владимир Сергеевич Петров", "Елена Александровна Козлова",
            "Михаил Николаевич Смирнов", "Ольга Владимировна Морозова"
        ])
    
        result = service._normalize_sync(text, language="ru")
    
        # Check that all names are normalized
        assert "Петр Иванович Коваленко" in result.normalized
&gt;       assert "Анна Петровна Сидорова" in result.normalized
E       AssertionError: assert 'Анна Петровна Сидорова' in 'Петр Иванович Коваленко Анна Петровна Сидоров Владимир Сергеевич Петров Елена Александровна Козлов Михаил Николаевич Смирнов Ольга Владимировна Морозов'
E        +  where 'Петр Иванович Коваленко Анна Петровна Сидоров Владимир Сергеевич Петров Елена Александровна Козлов Михаил Николаевич Смирнов Ольга Владимировна Морозов' = NormalizationResult(normalized='Петр Иванович Коваленко Анна Петровна Сидоров Владимир Сергеевич Петров Елена Александ...female': 18, 'score_male': 28, 'gap': 10}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/integration/test_ru_uk_sentences.py:198: AssertionError</failure></testcase><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_error_handling_malformed_input" time="0.086" /><testcase classname="tests.integration.test_ru_uk_sentences.TestRussianUkrainianSentences" name="test_confidence_scoring" time="0.104" /><testcase classname="tests.integration.test_simple_normalization" name="test_normalization_directly" time="0.007" /><testcase classname="tests.integration.test_strict_name_extraction" name="test_strict_name_extraction" time="0.001" /><testcase classname="tests.integration.test_ukrainian_morphology_simple" name="test_ukrainian_morphology_simple" time="0.048" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_text_normalization" time="0.072" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_stemming_in_normalization" time="0.082" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_language_detection" time="0.102" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_stop_words_removal" time="0.090" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_unicode_handling" time="0.081" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_mixed_language_text" time="0.100" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_empty_and_short_text" time="0.260" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_special_characters" time="0.145" /><testcase classname="tests.integration.test_ukrainian_normalization.TestUkrainianNormalization" name="test_ukrainian_performance" time="0.093" /><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_warmup_performance" time="6.197" /><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_batch_performance_p95" time="15.081" /><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_repeated_batch_performance" time="4.934" /><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_memory_stability" time="0.049"><skipped type="pytest.skip" message="psutil not available for memory monitoring">/Users/dariapavlova/Desktop/ai-service/tests/performance/test_embeddings_perf.py:170: psutil not available for memory monitoring</skipped></testcase><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_single_vs_batch_performance" time="5.677" /><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_large_batch_performance" time="6.757" /><testcase classname="tests.performance.test_embeddings_perf.TestEmbeddingsPerformance" name="test_empty_and_single_text_performance" time="6.191" /><testcase classname="tests.performance.test_lang_perf.TestLanguageDetectionPerformance" name="test_single_pass_performance" time="0.155" /><testcase classname="tests.performance.test_lang_perf.TestLanguageDetectionPerformance" name="test_debug_details_completeness" time="0.000" /><testcase classname="tests.performance.test_lang_perf.TestLanguageDetectionPerformance" name="test_memory_efficiency" time="0.435" /><testcase classname="tests.performance.test_lang_perf.TestLanguageDetectionPerformance" name="test_edge_case_performance" time="0.001" /><testcase classname="tests.performance.test_lang_perf.TestLanguageDetectionPerformance" name="test_character_counting_accuracy" time="0.000" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_health_check_no_orchestrator" time="0.151" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_health_check_with_orchestrator" time="0.006" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_process_text_endpoint_success" time="0.033" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_process_text_no_orchestrator" time="0.002" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_process_text_internal_error" time="0.004" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_process_text_validation_error" time="0.003" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_normalize_text_endpoint_success" time="0.005" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_process_batch_endpoint_success" time="0.003" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_search_similar_endpoint_success" time="0.005" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_startup_event_success" time="0.002" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_startup_event_failure" time="0.001" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_admin_status_endpoint_unauthorized" time="0.003" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_admin_status_endpoint_invalid_token" time="0.003" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_admin_status_endpoint_success" time="0.003" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_cors_configuration" time="0.002" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_request_validation_models" time="0.000" /><testcase classname="tests.unit.api.test_main_endpoints.TestMainEndpoints" name="test_error_handler_responses" time="0.003" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_high_confidence_match_decision" time="0.003" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_weak_match_decision" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_needs_review_decision" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_no_match_decision" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_insufficient_data_decision" time="0.000" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_evidence_extraction" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_risk_factor_identification" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_context_sensitive_decisions" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_reasoning_generation" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_recommendations_generation" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_batch_decisions" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_threshold_updates" time="0.000" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_decision_statistics" time="0.000"><skipped type="pytest.skip" message="Feature not implemented">/Users/dariapavlova/Desktop/ai-service/tests/unit/core/test_decision_engine.py:204: Feature not implemented</skipped></testcase><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_error_handling" time="0.000"><skipped type="pytest.skip" message="Feature not implemented">/Users/dariapavlova/Desktop/ai-service/tests/unit/core/test_decision_engine.py:222: Feature not implemented</skipped></testcase><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_match_type_determination" time="0.000"><skipped type="pytest.skip" message="Feature not implemented">/Users/dariapavlova/Desktop/ai-service/tests/unit/core/test_decision_engine.py:238: Feature not implemented</skipped></testcase><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngine" name="test_processing_time_tracking" time="0.000"><skipped type="pytest.skip" message="Feature not implemented">/Users/dariapavlova/Desktop/ai-service/tests/unit/core/test_decision_engine.py:260: Feature not implemented</skipped></testcase><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngineIntegration" name="test_real_processing_result_decision" time="0.001" /><testcase classname="tests.unit.core.test_decision_engine.TestDecisionEngineIntegration" name="test_decision_performance" time="0.000"><skipped type="pytest.skip" message="Feature not implemented">/Users/dariapavlova/Desktop/ai-service/tests/unit/core/test_decision_engine.py:281: Feature not implemented</skipped></testcase><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_factory_initialization" time="0.000" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_create_testing_orchestrator_minimal" time="0.003" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_create_testing_orchestrator_full" time="0.002" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_create_production_orchestrator" time="0.002" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_create_orchestrator_custom_config" time="0.002" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_service_initialization_mocking" time="0.150" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_service_initialization_error_handling" time="0.006" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_optional_services_configuration" time="0.002" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_factory_singleton_pattern" time="0.000" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactory" name="test_service_dependency_injection" time="0.004" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactoryIntegration" name="test_real_service_creation" time="0.001" /><testcase classname="tests.unit.core.test_orchestrator_factory.TestOrchestratorFactoryIntegration" name="test_factory_performance" time="0.046" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_initialization" time="0.000" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_default_model_configuration" time="0.000" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_load_model_success" time="3.011" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_load_model_error" time="0.002" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_model_caching" time="0.001" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_encode_single_text" time="7.622" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_encode_multiple_texts" time="5.036" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_encode_with_normalization" time="4.870" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_encode_batch_processing" time="4.855" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_encode_empty_input" time="0.001" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_encode_none_input" time="0.000" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceCore" name="test_embedding_result_format" time="4.164" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceErrorHandling" name="test_model_encode_error" time="0.003" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceErrorHandling" name="test_memory_error_handling" time="0.001" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServicePerformance" name="test_batch_size_optimization" time="4.586" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServicePerformance" name="test_processing_time_tracking" time="6.628" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServicePerformance" name="test_model_cache_efficiency" time="11.887" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceIntegration" name="test_multilingual_support" time="7.612" /><testcase classname="tests.unit.embeddings.test_embedding_service_comprehensive_fixed.TestEmbeddingServiceIntegration" name="test_real_world_embedding_scenarios" time="10.257" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_service_initialization" time="0.006" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_cache_key_generation" time="0.001" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_embedding_caching" time="0.003" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_cache_lru_eviction" time="0.003" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_optimized_embeddings_with_cache" time="0.006" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_optimized_embeddings_without_cache" time="0.001" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_performance_metrics_tracking" time="0.002" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_batch_optimization" time="0.002" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_gpu_availability_check" time="0.001" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_optimized_similarity_search" time="0.034" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_faiss_acceleration" time="0.034" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_numpy_similarity_search" time="0.001" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_cache_clearing" time="0.001" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_cache_warmup" time="0.002" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_error_handling" time="0.341" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_async_optimized_methods" time="0.954" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_performance_under_load" time="0.006" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_metrics_accumulation" time="0.001" /><testcase classname="tests.unit.embeddings.test_optimized_embedding_service.TestOptimizedEmbeddingService" name="test_thread_safety" time="0.013" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_invariant_surnames_unchanged" time="0.236" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_russian_feminine_adjustment" time="0.073" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_russian_masculine_adjustment" time="0.102" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_ukrainian_feminine_adjustment" time="0.069" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_ukrainian_masculine_adjustment" time="0.072" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_insufficient_confidence_gap" time="0.067" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_preserve_original_gendered_form" time="0.074" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_no_matching_endings" time="0.113" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_case_insensitive_matching" time="0.152" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_compound_surnames" time="8.391" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_edge_cases" time="0.139" /><testcase classname="tests.unit.layers.test_adjust_surname_gender.TestAdjustSurnameGender" name="test_confidence_gap_boundary" time="0.155" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_single_person" time="0.088" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_multiple_persons_with_conjunction" time="0.076" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_multiple_persons_with_comma" time="0.090" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_person_with_patronymic" time="0.077" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_person_with_initial" time="0.088" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_skip_non_person_tokens" time="0.092" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_empty_tokens" time="0.159" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_no_person_tokens" time="0.074" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_multiple_separators" time="0.080" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_ukrainian_separators" time="0.080" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_english_separators" time="0.063" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_person_data_structure" time="0.066" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_surname_adjustment_integration" time="0.073" /><testcase classname="tests.unit.layers.test_group_persons.TestGroupPersons" name="test_surname_adjustment_with_high_confidence" time="0.078" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_patronymic_male_clear" time="1.440" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_patronymic_female_clear" time="0.089" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_given_name_male_clear" time="0.089" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_given_name_female_clear" time="0.099" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_surname_male_ending" time="0.091" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_surname_female_ending" time="0.067" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_context_markers_female" time="0.059" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_context_markers_male" time="0.076" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_combined_indicators_strong_female" time="0.066" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_combined_indicators_strong_male" time="0.066" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_uncertain_gender" time="0.092" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_empty_input" time="0.096" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_mixed_indicators_female_wins" time="0.072" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_mixed_indicators_male_wins" time="0.073" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_initial_tokens_ignored" time="0.084" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_ukrainian_surname_endings" time="0.300" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_case_insensitive_matching" time="0.068" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_multiple_patronymics" time="0.083" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_multiple_given_names" time="0.110" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_edge_case_exactly_3_difference" time="0.098" /><testcase classname="tests.unit.layers.test_infer_gender.TestInferGender" name="test_unknown_role_tokens" time="0.110" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_normalization_result_structure" time="4.840" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_token_trace_completeness" time="0.175" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_organizations_core_separation" time="0.114" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_persons_core_structure" time="0.116" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_flag_behavior_real_impact" time="0.141" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_org_acronyms_always_unknown" time="0.214" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_ascii_no_morph_in_cyrillic" time="0.185" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_womens_surnames_preserved" time="1.273" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_serialization_compatibility" time="0.224" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_performance_requirements" time="0.155" /><testcase classname="tests.unit.layers.test_normalization_contracts.TestNormalizationContracts" name="test_error_handling" time="0.081" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_should_process_basic" time="0.011" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_classification_mapping" time="0.004" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_name_signals_extraction" time="0.001" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_company_signals_extraction" time="0.001" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_payment_signals_extraction" time="0.001" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_error_handling_fallback" time="0.003" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_initialization_required" time="0.001" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_signal_names_extraction" time="0.003" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapter" name="test_processing_time_tracking" time="0.001" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapterIntegration" name="test_full_initialization" time="0.023" /><testcase classname="tests.unit.layers.test_smart_filter_adapter.TestSmartFilterAdapterIntegration" name="test_claude_md_compliance" time="0.003" /><testcase classname="tests.unit.monitoring.test_metrics_basic" name="test_orchestrator_with_metrics_service" time="0.017" /><testcase classname="tests.unit.monitoring.test_metrics_basic" name="test_metrics_service_basic_operations" time="0.002" /><testcase classname="tests.unit.monitoring.test_metrics_basic" name="test_metrics_service_initialization" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_service_initialization" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_counter_metric" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_set_gauge_metric" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_record_histogram_metric" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_timer_metric" time="0.016" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_metric_definitions" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_alert_system" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_alert_cooldown" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_metric_cleanup" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_performance_report" time="0.007" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_system_health_check" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_metric_export" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_thread_safety" time="0.138" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_async_operations" time="0.019" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_memory_usage_tracking" time="0.002" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_metric_labels" time="0.000" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_bulk_operations" time="0.001" /><testcase classname="tests.unit.monitoring.test_metrics_service.TestMetricsService" name="test_error_handling" time="0.001" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_successful_processing_metrics" time="0.007" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_validation_failure_metrics" time="0.003" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_smart_filter_skip_metrics" time="0.010" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_normalization_failure_metrics" time="0.015" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_variants_failure_metrics" time="0.005" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_embeddings_failure_metrics" time="0.008" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_decision_failure_metrics" time="0.005" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_slow_processing_metrics" time="0.014" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_exception_handling_metrics" time="0.052" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_active_requests_gauge" time="0.016" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_language_detection_distribution" time="0.006" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_histogram_metrics_accuracy" time="0.005" /><testcase classname="tests.unit.monitoring.test_orchestrator_metrics.TestOrchestratorMetrics" name="test_metrics_without_optional_services" time="0.005" /><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_service_initialization" time="0.006"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:19: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_ukrainian_name_analysis" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:36: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_russian_name_analysis" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:54: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_language_detection_priority" time="0.151" /><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_mixed_language_handling" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:93: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_fallback_behavior" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:119: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_advanced_normalization_pipeline" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:136: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_language_auto_detection" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:151: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_morphology_consistency" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:166: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_integration_morphology.TestMorphologyIntegration" name="test_error_recovery" time="0.000"><skipped type="pytest.skip" message="Test expects AdvancedNormalizationService which no longer exists">/Users/dariapavlova/Desktop/ai-service/tests/unit/morphology/test_integration_morphology.py:182: Test expects AdvancedNormalizationService which no longer exists</skipped></testcase><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_morph_nominal_caching" time="0.076" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_morph_nominal_name_surn_priority" time="0.087" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_ukrainian_surname_enko_indeclinable" time="0.099" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_ukrainian_surname_sky_forms" time="0.089" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_ukrainian_surname_tsky_forms" time="0.068" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_ukrainian_surname_ov_forms" time="0.116" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_russian_diminutives_expansion" time="0.094" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_ukrainian_diminutives_expansion" time="0.132" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_english_nicknames_expansion" time="0.126" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_surname_gender_adjustment_male" time="0.097" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_surname_gender_adjustment_ukrainian" time="0.093" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_compound_surname_gender_adjustment" time="0.087" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_morphology_preserves_case" time="0.062" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_morphology_handles_compound_words" time="0.063" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_diminutives_with_morphology" time="0.077" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_advanced_features_flag_affects_diminutives" time="0.448" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_advanced_features_flag_affects_morphology" time="0.076" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_unknown_diminutive_fallback" time="0.067" /><testcase classname="tests.unit.morphology.test_morph_and_diminutives.TestMorphologyAndDiminutives" name="test_mixed_language_diminutives" time="0.062" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_initialization" time="0.032" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_basic_name" time="0.043" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_feminine_name" time="0.029" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_surname" time="0.037" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_patronymic" time="0.038" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_compound_name" time="0.034" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_empty_input" time="0.042" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_whitespace_input" time="0.026" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_non_russian_text" time="2.845" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_numbers" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_mixed_text" time="0.032" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_all_forms_with_exception" time="0.029" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_diminutives_masculine" time="0.024" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_diminutives_feminine" time="0.029" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_diminutives_unknown_name" time="0.032" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_diminutives_empty_input" time="0.025" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_word_forms_all_cases" time="0.038" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_word_forms_multiple_parses" time="0.037" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_word_forms_inflection_failure" time="0.029" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_get_word_forms_non_noun" time="0.030" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_is_russian_name_valid_names" time="0.028" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_is_russian_name_invalid_names" time="0.059" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_is_russian_name_edge_cases" time="0.034" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_analyze_name_capitalization" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_analyze_name_whitespace_handling" time="0.038" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_analyze_name_empty_input" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_variants_comprehensive" time="0.030" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_variants_deduplication" time="0.032" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test__generate_variants_max_variants_limit" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_batch_process_names" time="0.034" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_batch_process_names_empty_list" time="0.044" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphology" name="test_batch_process_names_with_errors" time="0.037" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphologyIntegration" name="test_real_name_processing_integration" time="0.046" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphologyIntegration" name="test_performance_with_long_name_lists" time="0.057" /><testcase classname="tests.unit.morphology.test_russian_morphology_service.TestRussianMorphologyIntegration" name="test_memory_usage_with_many_variants" time="0.044" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_word_basic" time="0.034" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_gender_detection_male" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_gender_detection_female" time="0.031" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_declensions_generation" time="0.031" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_diminutives_generation" time="0.031" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_variants_generation" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_transliterations_generation" time="0.026" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_language_detection" time="0.040" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_is_russian_name" time="0.035" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_name_complexity" time="0.035" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_phonetic_variants" time="0.043" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_regional_transliterations" time="0.042" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_basic" time="0.052" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_with_language" time="0.045" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_empty_input" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_none_input" time="0.034" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_whitespace_input" time="0.033" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_special_characters" time="0.053" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_numbers" time="0.058" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_mixed_case" time="0.039" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_very_long" time="0.050" /><testcase classname="tests.unit.morphology.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_unicode_characters" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0421\u0435\u0440\u0433\u0456\u0439-masc-uk]" time="0.035" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041e\u043b\u0435\u043d\u0430-femn-uk]" time="0.028" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0412\u043e\u043b\u043e\u0434\u0438\u043c\u0438\u0440-masc-uk]" time="0.032" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0414\u0430\u0440\u0456\u044f-femn-uk]" time="0.026" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041f\u0435\u0442\u0440\u043e-masc-uk]" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0410\u043d\u043d\u0430-femn-uk]" time="0.031" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041c\u0438\u0445\u0430\u0439\u043b\u043e-masc-uk]" time="0.033" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041a\u0430\u0442\u0435\u0440\u0438\u043d\u0430-femn-uk]" time="0.024" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_diminutives_generation" time="0.033" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_transliteration_generation" time="0.024" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u043e-expected_endings0]" time="0.028" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u0406\u0432\u0430\u043d\u0435\u043d\u043a\u043e-expected_endings1]" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u041c\u0435\u043b\u044c\u043d\u0438\u043a-expected_endings2]" time="0.058" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u0428\u0435\u0432\u0447\u0435\u043d\u043a\u043e-expected_endings3]" time="0.051" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_edge_cases_handling[-expected_result0]" time="0.032" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_edge_cases_handling[\u0410-expected_result1]" time="0.032" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_edge_cases_handling[\u0421\u0435\u0440\u0433\u0456\u0439-expected_result2]" time="0.033" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u0421\u0435\u0440\u0433\u0456\u0439-expected_ukrainian_chars0]" time="0.033" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u041e\u043b\u0435\u043a\u0441\u0456\u0439-expected_ukrainian_chars1]" time="0.036" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u0412\u043e\u043b\u043e\u0434\u0438\u043c\u0438\u0440-expected_ukrainian_chars2]" time="2.778" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u0414\u0430\u0440\u0456\u044f-expected_ukrainian_chars3]" time="0.058" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u041f\u0435\u0442\u0440\u043e-expected_ukrainian_chars4]" time="0.045" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_name_complexity_analysis" time="0.033" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_correction_logic" time="0.031" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_basic_functionality" time="0.038" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_empty_name_handling" time="0.032" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_short_name_handling" time="0.034" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_auto_language_detection" time="0.027" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_pymorphy3_initialization_success" time="0.053" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_exceptions_dictionary" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_phonetic_variants_generation" time="0.029" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_regional_transliterations" time="0.027" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_get_all_forms_method" time="0.025" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_is_ukrainian_name_detection" time="0.027" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_complexity_level_calculation" time="0.024" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_basic_transliteration" time="0.036" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_language_detection_internal" time="0.029" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_pymorphy_analysis_failure_handling" time="0.029" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_generate_pymorphy_declensions" time="0.022" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_extract_gender_with_name_tags" time="0.036" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_extract_gender_by_endings" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_apply_regional_transliteration" time="0.044" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_whitespace_name_handling" time="0.026" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_none_name_handling" time="0.029" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_gender_detection_petro" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_gender_detection_daria" time="0.024" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_unknown_name" time="0.052" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_short_name" time="0.026" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_lemma_special_name" time="0.029" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_lemma_unknown_name" time="0.021" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_special_name" time="0.033" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_gender_special_name" time="0.029" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_gender_unknown_name" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_variants_special_name" time="0.026" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_variants_unknown_name" time="0.022" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_diminutives_special_name" time="0.034" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_diminutives_unknown_name" time="0.023" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_basic_functionality" time="0.030" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_with_language_detection" time="0.025" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_empty_string" time="0.022" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_whitespace_only" time="0.023" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_none_input" time="0.026" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_special_characters" time="0.021" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_numbers" time="0.022" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_mixed_case" time="0.025" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_very_long" time="0.021" /><testcase classname="tests.unit.morphology.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_unicode_characters" time="0.021" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_unified_pattern_creation" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_generate_patterns_basic" time="0.004" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_generate_patterns_empty_text" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_document_pattern_extraction" time="0.004" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_contextual_pattern_extraction" time="0.004" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_structured_name_extraction" time="0.001" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_company_pattern_extraction" time="0.004" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_dob_pattern_extraction" time="0.002" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_dictionary_pattern_extraction" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_language_detection" time="0.001" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_pattern_optimization" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_stop_words_filtering" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_multilingual_support" time="0.009" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_export_for_aho_corasick" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_pattern_statistics" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_high_quality_name_validation" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_structured_name_validation" time="0.001" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_company_name_validation" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_performance_with_complex_text" time="0.001" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_legacy_compatibility" time="0.000" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_case_sensitivity_handling" time="0.001" /><testcase classname="tests.unit.patterns.test_unified_pattern_service.TestUnifiedPatternService" name="test_special_characters_handling" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_create_empty_result" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_addresses" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_banking_terms" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_business_types" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_capitalized_names" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_company_signals_empty" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_company_signals_with_keywords" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_financial_services" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_keywords" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_legal_entities" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_detect_registration_numbers" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_extract_detected_keywords" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_get_enhanced_company_analysis" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetectorIntegration" name="test_financial_institution_detection" time="0.002" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetectorIntegration" name="test_multilingual_support" time="0.002" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetectorIntegration" name="test_requirement_banking_terms" time="0.002" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetectorIntegration" name="test_requirement_legal_forms" time="0.001" /><testcase classname="tests.unit.screening.test_company_detector.TestCompanyDetectorIntegration" name="test_requirement_organization_patterns" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_analyze_regular_signals_high_confidence" time="0.002" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_analyze_regular_signals_low_confidence" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_collect_all_signals" time="0.003" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_determine_risk_level" time="0.004" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_get_decision_statistics" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_get_decision_statistics_empty" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_get_detailed_analysis" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_initialization" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_initialization_with_terrorism_detection" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_is_excluded_text" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_make_decision_empty_text" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_make_decision_excluded_text" time="0.002" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_make_regular_decision_thresholds" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_update_thresholds" time="0.001" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionLogic" name="test_update_thresholds_invalid_key" time="0.002" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionResult" name="test_decision_result_creation" time="0.000" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionTypes" name="test_decision_type_values" time="0.000" /><testcase classname="tests.unit.screening.test_decision_logic.TestDecisionTypes" name="test_risk_level_values" time="0.001" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_create_empty_result" time="0.001" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_addresses" time="0.001" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_bank_details" time="0.001" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_contact_info" time="0.001" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_dates" time="0.012" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_document_numbers" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_document_signals_empty" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_document_signals_with_inn" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_detect_inn" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_extract_detected_documents" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetector" name="test_is_valid_date" time="0.001" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetectorIntegration" name="test_comprehensive_document_analysis" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetectorIntegration" name="test_multilingual_document_support" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetectorIntegration" name="test_requirement_address_detection" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetectorIntegration" name="test_requirement_date_detection" time="0.000" /><testcase classname="tests.unit.screening.test_document_detector.TestDocumentDetectorIntegration" name="test_requirement_inn_detection" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_analyze_payment_description" time="0.002" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_date_only_text" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_exclusion_patterns" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_initialization" time="0.000" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_initialization_with_terrorism_detection" time="0.002" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_language_composition_analysis" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_language_detection" time="0.000" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_make_smart_decision" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_service_words_cleaning" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_should_process_text_empty" time="0.000" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_should_process_text_excluded" time="0.000" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_should_process_text_with_signals" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterService" name="test_text_normalization" time="0.000" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterIntegration" name="test_company_detection" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterIntegration" name="test_person_name_detection" time="0.001" /><testcase classname="tests.unit.screening.test_smart_filter_service.TestSmartFilterIntegration" name="test_safe_content_handling" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_create_empty_result" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_detect_activity_patterns" time="0.002" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_detect_financing_patterns" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_detect_organization_patterns" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_detect_terrorism_signals_empty" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_detect_terrorism_signals_excluded_content" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_detect_weapons_patterns" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_determine_risk_level" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_extract_detected_indicators" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_get_risk_assessment" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetector" name="test_is_excluded_content" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_defensive_purpose_only" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_false_positive_prevention" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_pattern_weights_balance" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_risk_escalation_thresholds" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorIntegration" name="test_comprehensive_threat_assessment" time="0.000" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorIntegration" name="test_defensive_system_requirements" time="0.001" /><testcase classname="tests.unit.screening.test_terrorism_detector.TestTerrorismDetectorIntegration" name="test_risk_assessment_workflow" time="0.001" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_proximity_matching_single_person_single_id" time="0.001" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_proximity_matching_multiple_persons_multiple_ids" time="0.001" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_proximity_matching_distance_limits" time="0.001" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_fallback_for_ids_without_position" time="0.001" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_fallback_logic_single_person_single_id" time="0.000" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_no_duplicate_id_assignment" time="0.000" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_assign_id_to_person_method" time="0.000" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_assign_invalid_id_evidence" time="0.000" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_persons_without_names_in_text" time="0.000" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityMatching" name="test_distance_calculation_accuracy" time="0.000" /><testcase classname="tests.unit.signals.test_id_person_proximity_matching.TestIDPersonProximityIntegration" name="test_full_signals_extraction_with_proximity" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_extract_async_success" time="0.004" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_extract_async_without_normalization" time="0.002" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_extract_async_empty_text" time="0.003" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_extract_async_error_handling" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_async_method_uses_thread_pool" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_concurrent_async_calls" time="0.003" /><testcase classname="tests.unit.signals.test_signals_service_async.TestSignalsServiceAsync" name="test_extract_async_with_different_languages" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_initialization" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_signals_basic" time="0.003" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_signals_with_organization" time="0.002" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_signals_with_birthdate" time="0.004" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_signals_with_ids" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_persons_from_normalization_result" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_organizations_from_normalization_result" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_person_ids" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_organization_ids" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_birthdates" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_enrich_persons_with_ids" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_enrich_organizations_with_ids" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_enrich_with_birthdates_proximity_matching" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_calculate_person_confidence" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_calculate_organization_confidence" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_extract_legal_forms" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_person_to_dict_serialization" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_organization_to_dict_serialization" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceCore" name="test_calculate_overall_confidence" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceEdgeCases" name="test_extract_signals_empty_text" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceEdgeCases" name="test_extract_signals_none_normalization" time="0.001" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceEdgeCases" name="test_extract_persons_malformed_core" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceEdgeCases" name="test_confidence_calculation_edge_cases" time="0.000" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceIntegration" name="test_complex_payment_scenario" time="0.003" /><testcase classname="tests.unit.signals.test_signals_service_comprehensive.TestSignalsServiceIntegration" name="test_multilingual_entity_extraction" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_ac_integration_enabled" time="0.005" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_ac_integration_disabled" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_enhanced_ac_search_enabled" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_enhanced_ac_search_disabled" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_enhanced_ac_search_with_matches" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_enhanced_pattern_analysis" time="0.011" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_pattern_confidence_scoring" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_tier_priority_scoring" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_pattern_type_inference" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_processing_recommendations" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_enhanced_analysis_with_ukrainian_text" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_enhanced_analysis_with_english_text" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_max_matches_limit" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_error_handling_invalid_text" time="0.000" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_integration_with_existing_smart_filter" time="0.001" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_performance_with_long_text" time="0.004" /><testcase classname="tests.unit.smart_filter.test_enhanced_smart_filter.TestEnhancedSmartFilter" name="test_async_compatibility" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_should_process_text_async_success" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_should_process_text_async_excluded" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_should_process_text_async_empty_text" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_should_process_text_async_whitespace_only" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_async_method_uses_thread_pool" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_concurrent_async_calls" time="0.002" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_async_error_handling" time="0.001" /><testcase classname="tests.unit.smart_filter.test_smart_filter_service_async.TestSmartFilterServiceAsync" name="test_async_with_different_text_types" time="0.001" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_aggregates_all_variants" time="0.093" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_without_morphology" time="0.066" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_error_handling" time="0.052" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_empty_text" time="0.068" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_language_detection" time="0.062" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_token_variants_structure" time="0.062" /><testcase classname="tests.unit.test_advanced_normalization_unit.TestNormalizationService" name="test_normalize_async_morphology_integration" time="0.110" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_template_builder_initialization" time="0.001" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_create_entity_template" time="0.001" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_create_batch_templates" time="0.001" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_generate_search_patterns" time="0.001" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_calculate_complexity_score" time="0.000" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_template_builder_logging_setup" time="0.000" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_build_templates_with_different_entity_types" time="0.000" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_template_builder_error_handling" time="0.001" /><testcase classname="tests.unit.test_build_templates_script.TestBuildTemplatesScript" name="test_template_generation_performance" time="0.001" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_basic_set_get" time="0.002" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_get_nonexistent_key" time="0.001" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_lru_eviction" time="0.001" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_ttl_expiration" time="1.108" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_statistics" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_get_or_set_cache_hit" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_get_or_set_cache_miss" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_clear_cache" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_exists_method" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_exists_with_expired_key" time="1.102" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_touch_method" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_touch_nonexistent_key" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_cleanup_expired" time="1.104" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_set_max_size" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_get_keys" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_memory_usage_estimation" time="0.000" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_generate_key_method" time="0.004" /><testcase classname="tests.unit.test_cache_service.TestCacheService" name="test_lru_logic_with_access" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_create_empty_result" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_addresses" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_banking_terms" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_business_types" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_capitalized_names" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_company_signals_empty" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_company_signals_with_keywords" time="0.001" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_financial_services" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_keywords" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_legal_entities" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_detect_registration_numbers" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_extract_detected_keywords" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_get_enhanced_company_analysis" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetectorIntegration" name="test_financial_institution_detection" time="0.001" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetectorIntegration" name="test_multilingual_support" time="0.001" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetectorIntegration" name="test_requirement_banking_terms" time="0.001" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetectorIntegration" name="test_requirement_legal_forms" time="0.001" /><testcase classname="tests.unit.test_company_detector.TestCompanyDetectorIntegration" name="test_requirement_organization_patterns" time="0.001" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_low_risk_canary_scenarios" time="0.002" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_medium_risk_canary_scenarios" time="0.000" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_high_risk_canary_scenarios" time="0.000" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_skip_risk_canary_scenarios" time="0.000" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_edge_case_canary_scenarios" time="0.000" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_score_calculation_stability" time="0.001" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_reasons_stability" time="0.000" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_metrics_recording_stability" time="0.001" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_configuration_stability" time="0.001" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_batch_consistency" time="0.000" /><testcase classname="tests.unit.test_decision_canary.TestDecisionCanary" name="test_canary_regression_detection" time="0.000" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_default_config_values" time="0.000" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_thr_high" time="0.013" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_thr_medium" time="0.002" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_weights" time="0.001" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_all_values" time="0.003" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_invalid_values" time="0.002" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_partial_values" time="0.003" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_unified_config_uses_env_overrides" time="0.027" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_decision_engine_uses_unified_config" time="0.001" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_decision_engine_custom_config_overrides_env" time="0.010" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_decision_engine_functionality_with_env_overrides" time="0.000" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_edge_cases" time="0.001" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_config_model_dump_with_env_overrides" time="0.001" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_case_sensitivity" time="0.001" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_env_override_priority" time="0.000" /><testcase classname="tests.unit.test_decision_config_overrides.TestDecisionConfigOverrides" name="test_multiple_instances_consistency" time="0.001" /><testcase classname="tests.unit.test_decision_contracts.TestRiskLevel" name="test_risk_level_values" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestRiskLevel" name="test_risk_level_enumeration" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSmartFilterInfo" name="test_smart_filter_info_creation" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSmartFilterInfo" name="test_smart_filter_info_with_optional" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSmartFilterInfo" name="test_smart_filter_info_serialization" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSignalsInfo" name="test_signals_info_creation" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSignalsInfo" name="test_signals_info_with_optional" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSignalsInfo" name="test_signals_info_serialization" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSimilarityInfo" name="test_similarity_info_creation" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSimilarityInfo" name="test_similarity_info_with_values" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestSimilarityInfo" name="test_similarity_info_serialization" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionInput" name="test_decision_input_creation" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionInput" name="test_decision_input_with_all_fields" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionInput" name="test_decision_input_serialization" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionOutput" name="test_decision_output_creation" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionOutput" name="test_decision_output_with_all_fields" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionOutput" name="test_decision_output_to_dict" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionConfig" name="test_decision_config_defaults" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionConfig" name="test_decision_config_custom_values" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionEngine" name="test_decision_engine_initialization" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionEngine" name="test_decision_engine_with_custom_config" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionEngine" name="test_decision_engine_decide_stub" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionEngine" name="test_decision_engine_high_risk_scenario" time="0.000" /><testcase classname="tests.unit.test_decision_contracts.TestDecisionEngine" name="test_decision_engine_low_risk_scenario" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_none_smartfilter_defaults_to_process_true" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_none_signals_defaults_to_zero_confidence" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_none_similarity_defaults_to_zero_contribution" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_all_none_evidence_results_in_low_risk" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_none_confidence_values_default_to_zero" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_none_boolean_flags_default_to_false" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_none_evidence_dict_defaults_to_empty" time="0.001" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_smartfilter_should_process_none_defaults_to_true" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_mixed_none_values_handled_gracefully" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_empty_text_handled_gracefully" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_very_high_confidence_with_none_other_values" time="0.001" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_skip_decision_with_none_values" time="0.001" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_details_contain_safe_values" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_evidence_strength_indicators_with_none_values" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_score_breakdown_with_none_values" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_reasons_generation_with_none_values" time="0.000" /><testcase classname="tests.unit.test_decision_edges.TestDecisionEngineEdgeCases" name="test_decision_engine_never_raises_exceptions" time="0.000" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_skip_scenario_smartfilter_false" time="0.000" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_high_risk_scenario" time="0.000" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_medium_risk_scenario" time="0.001" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_low_risk_scenario" time="0.000" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_score_calculation_deterministic" time="0.000" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_custom_config_weights" time="0.000" /><testcase classname="tests.unit.test_decision_engine_core.TestDecisionEngineCore" name="test_similarity_none_handling" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_strong_smartfilter_signal_reason" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_person_evidence_strong_reason" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_org_evidence_strong_reason" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_high_vector_similarity_reason" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_id_exact_match_reason" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_dob_match_reason" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_multiple_strong_evidence_reasons" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_moderate_evidence_fallback_reasons" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_low_evidence_no_strong_reasons" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_score_breakdown_in_details" time="0.001" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_normalized_features_in_details" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_evidence_strength_indicators" time="0.001" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_weights_and_thresholds_in_details" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_skip_scenario_reasons" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_reasons_consistency_with_evidence_strength" time="0.000" /><testcase classname="tests.unit.test_decision_explain.TestDecisionExplanation" name="test_contribution_calculation_accuracy" time="0.000" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_analyze_regular_signals_high_confidence" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_analyze_regular_signals_low_confidence" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_collect_all_signals" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_determine_risk_level" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_get_decision_statistics" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_get_decision_statistics_empty" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_get_detailed_analysis" time="0.003" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_initialization" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_initialization_with_terrorism_detection" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_is_excluded_text" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_make_decision_empty_text" time="0.002" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_make_decision_excluded_text" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_make_regular_decision_thresholds" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_update_thresholds" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionLogic" name="test_update_thresholds_invalid_key" time="0.001" /><testcase classname="tests.unit.test_decision_logic.TestDecisionResult" name="test_decision_result_creation" time="0.000" /><testcase classname="tests.unit.test_decision_logic.TestDecisionTypes" name="test_decision_type_values" time="0.000" /><testcase classname="tests.unit.test_decision_logic.TestDecisionTypes" name="test_risk_level_values" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_create_empty_result" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_addresses" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_bank_details" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_contact_info" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_dates" time="0.001" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_document_numbers" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_document_signals_empty" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_document_signals_with_inn" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_detect_inn" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_extract_detected_documents" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetector" name="test_is_valid_date" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetectorIntegration" name="test_comprehensive_document_analysis" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetectorIntegration" name="test_multilingual_document_support" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetectorIntegration" name="test_requirement_address_detection" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetectorIntegration" name="test_requirement_date_detection" time="0.000" /><testcase classname="tests.unit.test_document_detector.TestDocumentDetectorIntegration" name="test_requirement_inn_detection" time="0.000" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingConfig" name="test_default_model_name" time="0.000" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingConfig" name="test_default_device" time="0.000" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingConfig" name="test_default_batch_size" time="0.000" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingConfig" name="test_default_enable_index" time="0.000" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingConfig" name="test_custom_config" time="0.001" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_single_text_encoding" time="12.045" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_multiple_texts_encoding" time="9.702" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_empty_input" time="0.005" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_device_from_config" time="8.150" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_embedding_dimension" time="4.460" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_model_info" time="5.102" /><testcase classname="tests.unit.test_embedding_config.TestEmbeddingService" name="test_lazy_initialization" time="5.264" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_encode_one_returns_384_floats" time="4.384" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_encode_batch_returns_2x384" time="4.336" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_encode_one_empty_text" time="0.001" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_encode_batch_empty_list" time="0.000" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_encode_batch_mixed_valid_empty" time="4.355" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_legacy_encode_method_still_works" time="4.662" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_no_similarity_methods_exist" time="0.002" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_no_indexing_imports" time="0.004" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_enable_index_ignored" time="6.630" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_pure_vector_generation_contract" time="0.004" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_batch_size_from_config" time="0.001" /><testcase classname="tests.unit.test_embedding_contract.TestEmbeddingContract" name="test_device_from_config" time="4.755" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_default_model_works" time="3.266" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_model_switch_to_all_minilm_l6_v2" time="2.787" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_invalid_model_raises_error" time="0.001" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_extra_models_allowlist" time="0.001" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_config_validation_error_messages" time="0.000" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_model_switch_preserves_functionality" time="10.898" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_model_switch_with_batch_processing" time="8.512" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_model_switch_with_preprocessing" time="2.520" /><testcase classname="tests.unit.test_embedding_model_switch.TestEmbeddingModelSwitch" name="test_embedding_dimensions_consistency" time="3.011" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_remove_dates_and_ids_by_default" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_remove_various_date_formats" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_remove_various_id_formats" time="0.001" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_fold_spaces" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_preserve_spaces_when_fold_spaces_false" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_empty_text_handling" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_only_dates_and_ids" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_extract_name_only_method" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_include_attrs_future_flag" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_complex_text_processing" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_organization_names" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_mixed_language_text" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_whitespace_normalization" time="0.000" /><testcase classname="tests.unit.test_embedding_preprocessor.TestEmbeddingPreprocessor" name="test_case_insensitive_removal" time="0.000" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_multilingual_name_triangle_similarity" time="3.308" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_name_vs_noise_low_similarity" time="3.371" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_organization_vs_personal_names_distinction" time="4.131" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_empty_and_whitespace_handling" time="3.605" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_consistency_across_calls" time="3.383" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_embedding_dimensions_consistency" time="3.166" /><testcase classname="tests.unit.test_embeddings_canary_names.TestEmbeddingsCanaryNames" name="test_preprocessing_removes_dates_ids" time="4.101" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_service_initialization" time="0.091" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_ukrainian_name_analysis" time="0.089" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_russian_name_analysis" time="0.046" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_language_detection_priority" time="0.019" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_mixed_language_handling" time="0.088" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_fallback_behavior" time="0.049" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_advanced_normalization_pipeline" time="0.053" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_language_auto_detection" time="0.045" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_morphology_consistency" time="1.334" /><testcase classname="tests.unit.test_integration_morphology.TestMorphologyIntegration" name="test_error_recovery" time="0.059" /><testcase classname="tests.unit.test_lang_canary_random_noise.TestLanguageDetectionCanaryRandomNoise" name="test_random_noise_low_confidence" time="0.007" /><testcase classname="tests.unit.test_lang_canary_random_noise.TestLanguageDetectionCanaryRandomNoise" name="test_noise_patterns_detection" time="0.001" /><testcase classname="tests.unit.test_lang_canary_random_noise.TestLanguageDetectionCanaryRandomNoise" name="test_edge_case_noise_robustness" time="0.000" /><testcase classname="tests.unit.test_lang_canary_random_noise.TestLanguageDetectionCanaryRandomNoise" name="test_reproducible_randomness" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_russian_text_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_ukrainian_text_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_english_text_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_mixed_language_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_unknown_text_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_empty_text_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_whitespace_text_detection" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_ukrainian_specific_characters" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_russian_specific_characters" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_mixed_language_close_ratios" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_config_thresholds_behavior" time="0.001" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_confidence_calculation" time="0.000" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_result_methods" time="0.001" /><testcase classname="tests.unit.test_lang_config_contract.TestLanguageConfigContract" name="test_detailed_analysis_structure" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_short_text_edge_cases" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_acronym_detection_with_confidence_penalty" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_uppercase_text_confidence_penalty" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_numeric_punctuation_dominance" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_normal_text_not_affected" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_mixed_case_acronyms" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_long_words_not_affected" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_edge_case_confidence_ranges" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_empty_and_whitespace_text" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_special_characters_and_unicode" time="0.000" /><testcase classname="tests.unit.test_lang_edge_cases.TestLanguageDetectionEdgeCases" name="test_threshold_boundary_cases" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_ukrainian_priority_detection" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_logic_ambiguous_text" time="0.009" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_empty_text_handling" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_whitespace_only_text" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_quick_patterns_english" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_quick_patterns_russian" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_quick_patterns_ukrainian" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_langdetect_fallback" time="0.009" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_langdetect_exception_handling" time="0.013" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_cyrillic_ukrainian_specific" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_cyrillic_russian_specific" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_cyrillic_patterns" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_latin_only" time="0.002" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_batch_detection" time="0.038" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_detection_statistics" time="0.040" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_reset_statistics" time="0.011" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_supported_languages" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_is_language_supported" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_add_language_mapping" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_add_invalid_language_mapping" time="0.000" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_confidence_scores_limit" time="9.885" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_language_mapping_coverage" time="0.001" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_no_fallback_option" time="0.001" /><testcase classname="tests.unit.test_language_detection_service.TestLanguageDetectionService" name="test_original_detected_language_preservation" time="0.006" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_create_empty_result" time="0.002" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_detect_name_signals_empty" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_detect_name_signals_full_name" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_detect_name_signals_structure" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_detect_names_basic" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_detect_names_empty" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_detect_names_none" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetectorIntegration" name="test_requirement_full_names" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetectorIntegration" name="test_requirement_names_and_surnames" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetectorIntegration" name="test_requirement_patronymic_patterns" time="0.000" /><testcase classname="tests.unit.test_name_detector.TestNameDetectorIntegration" name="test_requirement_surname_patterns" time="0.000" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_russian_names_no_internal_duplicates" time="0.001" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_ukrainian_names_no_internal_duplicates" time="0.001" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_english_names_no_internal_duplicates" time="0.000" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_no_cross_dictionary_duplicates" time="0.000" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_additional_english_names_consistency" time="0.000" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_dictionaries_statistics" time="0.000" /><testcase classname="tests.unit.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_name_data_structure" time="0.001" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_process_basic_functionality" time="0.011" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_process_with_smart_filter_skip" time="0.002" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_process_with_validation_error" time="0.002" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_process_with_language_detection_failure" time="0.005" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_process_with_normalization_failure" time="0.013" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_orchestrator_initialization" time="0.001" /><testcase classname="tests.unit.test_orchestrator_service.TestUnifiedOrchestrator" name="test_orchestrator_without_optional_services" time="0.000" /><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_process_basic_functionality" time="0.005"><failure message="assert False is True&#10; +  where False = UnifiedProcessingResult(original_text='Test text', language='unknown', language_confidence=0.0, normalized_text='', to...=None, processing_time=6.29425048828125e-05, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).success">self = &lt;tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator object at 0x16b752e90&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f229150&gt;

    @pytest.mark.asyncio
    async def test_process_basic_functionality(self, orchestrator_service):
        """Test basic process functionality"""
        # Arrange
        test_text = "Test text"
    
        # Mock all services
        with patch.object(orchestrator_service.validation_service, 'validate_and_sanitize') as mock_validation, \
             patch.object(orchestrator_service.smart_filter_service, 'should_skip') as mock_smart_filter, \
             patch.object(orchestrator_service.language_service, 'detect_language_config_driven') as mock_language, \
             patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.normalization_service, 'normalize') as mock_normalize, \
             patch.object(orchestrator_service.signals_service, 'extract_signals') as mock_signals, \
             patch.object(orchestrator_service.variants_service, 'generate_variants') as mock_variants, \
             patch.object(orchestrator_service.embeddings_service, 'encode') as mock_embeddings, \
             patch.object(orchestrator_service.decision_engine, 'make_decision') as mock_decision:
    
            # Setup mocks
            mock_validation.return_value = {'valid': True, 'errors': []}
            mock_smart_filter.return_value = False  # Don't skip
            mock_language.return_value = Mock(language='en', confidence=0.9)
            mock_unicode.return_value = {'normalized': 'test text'}
    
            # Mock normalization result
            mock_normalize_result = Mock()
            mock_normalize_result.normalized = 'test text'
            mock_normalize_result.tokens = ['test', 'text']
            mock_normalize_result.trace = [TokenTrace(token='test', role='given', rule='capitalize', output='test')]
            mock_normalize_result.success = True
            mock_normalize.return_value = mock_normalize_result
    
            # Mock signals result
            mock_signals_result = Mock()
            mock_signals_result.persons = []
            mock_signals_result.organizations = []
            mock_signals_result.confidence = 0.5
            mock_signals.return_value = mock_signals_result
    
            mock_variants.return_value = ['test text', 'test']
            mock_embeddings.return_value = [0.1] * 384  # 384-dimensional embedding
            mock_decision_result = Mock()
            mock_decision_result.risk_level = 'low'
            mock_decision_result.confidence = 0.8
            mock_decision.return_value = mock_decision_result
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert isinstance(result, UnifiedProcessingResult)
&gt;           assert result.success is True
E           assert False is True
E            +  where False = UnifiedProcessingResult(original_text='Test text', language='unknown', language_confidence=0.0, normalized_text='', to...=None, processing_time=6.29425048828125e-05, success=False, errors=["object Mock can't be used in 'await' expression"]).success

tests/unit/test_orchestrator_service_fixed.py:98: AssertionError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_process_with_smart_filter_skip" time="0.002"><failure message="assert False is True&#10; +  where False = UnifiedProcessingResult(original_text='Test text', language='unknown', language_confidence=0.0, normalized_text='', to...None, processing_time=0.0003268718719482422, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).success">self = &lt;tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator object at 0x16b752d50&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f229ae0&gt;

    @pytest.mark.asyncio
    async def test_process_with_smart_filter_skip(self, orchestrator_service):
        """Test process when smart filter decides to skip"""
        # Arrange
        test_text = "Test text"
    
        with patch.object(orchestrator_service.validation_service, 'validate_text') as mock_validation, \
             patch.object(orchestrator_service.smart_filter_service, 'should_skip') as mock_smart_filter:
    
            mock_validation.return_value = {'valid': True, 'errors': []}
            mock_smart_filter.return_value = True  # Skip processing
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert isinstance(result, UnifiedProcessingResult)
&gt;           assert result.success is True
E           assert False is True
E            +  where False = UnifiedProcessingResult(original_text='Test text', language='unknown', language_confidence=0.0, normalized_text='', to...None, processing_time=0.0003268718719482422, success=False, errors=["object Mock can't be used in 'await' expression"]).success

tests/unit/test_orchestrator_service_fixed.py:126: AssertionError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_process_with_validation_error" time="0.003"><failure message="assert 'Invalid input' in [&quot;object Mock can't be used in 'await' expression&quot;]&#10; +  where [&quot;object Mock can't be used in 'await' expression&quot;] = UnifiedProcessingResult(original_text='Invalid text', language='unknown', language_confidence=0.0, normalized_text='',...None, processing_time=0.0003559589385986328, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).errors">self = &lt;tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator object at 0x16b75a520&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f22a470&gt;

    @pytest.mark.asyncio
    async def test_process_with_validation_error(self, orchestrator_service):
        """Test process with validation error"""
        # Arrange
        test_text = "Invalid text"
    
        with patch.object(orchestrator_service.validation_service, 'validate_text') as mock_validation:
            mock_validation.return_value = {'valid': False, 'errors': ['Invalid input']}
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert isinstance(result, UnifiedProcessingResult)
            assert result.success is False
&gt;           assert 'Invalid input' in result.errors
E           assert 'Invalid input' in ["object Mock can't be used in 'await' expression"]
E            +  where ["object Mock can't be used in 'await' expression"] = UnifiedProcessingResult(original_text='Invalid text', language='unknown', language_confidence=0.0, normalized_text='',...None, processing_time=0.0003559589385986328, success=False, errors=["object Mock can't be used in 'await' expression"]).errors

tests/unit/test_orchestrator_service_fixed.py:145: AssertionError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_process_with_language_detection_failure" time="0.002" /><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_process_with_normalization_failure" time="0.002" /><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_orchestrator_initialization" time="0.000" /><testcase classname="tests.unit.test_orchestrator_service_fixed.TestUnifiedOrchestrator" name="test_orchestrator_without_optional_services" time="0.000" /><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_basic_functionality" time="0.002"><failure message="AssertionError: assert 'Test text' == 'test text'&#10;  &#10;  - test text&#10;  ? ^&#10;  + Test text&#10;  ? ^">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b753110&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f22bdf0&gt;

    @pytest.mark.asyncio
    async def test_process_basic_functionality(self, orchestrator_service):
        """Test basic process functionality"""
        # Arrange
        test_text = "Test text"
    
        # Mock all services
        with patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.language_service, 'detect_language', new_callable=AsyncMock) as mock_language, \
             patch.object(orchestrator_service.normalization_service, 'normalize', new_callable=AsyncMock) as mock_normalize, \
             patch.object(orchestrator_service.variants_service, 'generate_variants', new_callable=AsyncMock) as mock_variants:
    
            mock_unicode.return_value = {'normalized': 'test text'}
            mock_language.return_value = {'language': 'en', 'confidence': 0.9}
            mock_normalize.return_value = {'normalized': 'test text'}
            mock_variants.return_value = {'variants': ['test text', 'test']}
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert isinstance(result, UnifiedProcessingResult)
            assert result.success is True
            assert result.original_text == test_text
&gt;           assert result.normalized_text == 'test text'
E           AssertionError: assert 'Test text' == 'test text'
E             
E             - test text
E             ? ^
E             + Test text
E             ? ^

tests/unit/test_orchestrator_service_old.py:41: AssertionError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_with_cache_hit" time="0.002"><failure message="TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b752fd0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c0050&gt;

    @pytest.mark.asyncio
    async def test_process_with_cache_hit(self, orchestrator_service):
        """Test process with cache hit"""
        # Arrange
        test_text = "Cached text"
&gt;       cached_result = UnifiedProcessingResult(
            original_text=test_text,
            normalized_text="cached text",
            language="en",
            language_confidence=0.9,
            variants=["cached", "text"],
            processing_time=0.001
        )
E       TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'

tests/unit/test_orchestrator_service_old.py:52: TypeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_with_cache_miss" time="0.002"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'cache_service'. Did you mean: 'unicode_service'?">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b75a650&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c08d0&gt;

    @pytest.mark.asyncio
    async def test_process_with_cache_miss(self, orchestrator_service):
        """Test process with cache miss"""
        # Arrange
        test_text = "Uncached text"
    
        # Mock services
&gt;       with patch.object(orchestrator_service.cache_service, 'get') as mock_get, \
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch.object(orchestrator_service.cache_service, 'set') as mock_set, \
             patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.language_service, 'detect_language') as mock_language, \
             patch.object(orchestrator_service.normalization_service, 'normalize') as mock_normalize:
E            AttributeError: 'UnifiedOrchestrator' object has no attribute 'cache_service'. Did you mean: 'unicode_service'?

tests/unit/test_orchestrator_service_old.py:79: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_with_embeddings" time="0.002"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'embedding_service'. Did you mean: 'embeddings_service'?">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b75a780&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c1150&gt;

    @pytest.mark.asyncio
    async def test_process_with_embeddings(self, orchestrator_service):
        """Test process with embeddings generation"""
        # Arrange
        test_text = "Test for embeddings"
    
        with patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.language_service, 'detect_language') as mock_language, \
             patch.object(orchestrator_service.normalization_service, 'normalize') as mock_normalize, \
&gt;            patch.object(orchestrator_service.embedding_service, 'get_embeddings') as mock_embeddings:
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E            AttributeError: 'UnifiedOrchestrator' object has no attribute 'embedding_service'. Did you mean: 'embeddings_service'?

tests/unit/test_orchestrator_service_old.py:107: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_error_handling" time="0.007"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7cf410&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c19d0&gt;

    @pytest.mark.asyncio
    async def test_process_error_handling(self, orchestrator_service):
        """Test error handling in process"""
        # Arrange
        test_text = "Error test"
    
        with patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode:
            mock_unicode.side_effect = Exception("Unicode service error")
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert result.success is False
            assert len(result.errors) &gt; 0
            assert "Unicode service error" in result.errors[0]
            assert result.processing_time &gt; 0
&gt;           assert orchestrator_service.processing_stats['failed'] == 1
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'

tests/unit/test_orchestrator_service_old.py:143: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_batch" time="0.001"><failure message="TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b76e580&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c2360&gt;

    @pytest.mark.asyncio
    async def test_process_batch(self, orchestrator_service):
        """Test batch processing"""
        # Arrange
        texts = ["Text 1", "Text 2", "Text 3"]
    
        # Mock process to return successful results
        with patch.object(orchestrator_service, 'process') as mock_process:
            mock_results = [
&gt;               UnifiedProcessingResult(
                    original_text=text,
                    normalized_text=text.lower(),
                    language="en",
                    language_confidence=0.9,
                    variants=[text.lower()],
                    processing_time=0.1
                ) for text in texts
            ]
E           TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'

tests/unit/test_orchestrator_service_old.py:154: TypeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_batch_with_exceptions" time="0.001"><failure message="TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b76e690&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c2be0&gt;

    @pytest.mark.asyncio
    async def test_process_batch_with_exceptions(self, orchestrator_service):
        """Test batch processing with exceptions"""
        # Arrange
        texts = ["Good text", "Bad text"]
    
        with patch.object(orchestrator_service, 'process') as mock_process:
            # First successful, second with error
            mock_process.side_effect = [
&gt;               UnifiedProcessingResult(
                    original_text="Good text",
                    normalized_text="good text",
                    language="en",
                    language_confidence=0.9,
                    variants=["good text"]
                ),
                Exception("Processing error")
            ]
E           TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'

tests/unit/test_orchestrator_service_old.py:182: TypeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_search_similar_names_with_embeddings" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'embedding_service'. Did you mean: 'embeddings_service'?">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b766650&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f22bbd0&gt;

    @pytest.mark.asyncio
    async def test_search_similar_names_with_embeddings(self, orchestrator_service):
        """Test similar names search using embeddings"""
        # Arrange
        query = "John Smith"
        candidates = ["Jon Smith", "John Smyth", "Jane Smith", "Bob Johnson"]
    
&gt;       with patch.object(orchestrator_service.embedding_service, 'find_similar_texts') as mock_search:
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'embedding_service'. Did you mean: 'embeddings_service'?

tests/unit/test_orchestrator_service_old.py:208: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_search_similar_names_fallback" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'embedding_service'. Did you mean: 'embeddings_service'?">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b766750&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f22b350&gt;

    @pytest.mark.asyncio
    async def test_search_similar_names_fallback(self, orchestrator_service):
        """Test fallback similar names search"""
        # Arrange
        query = "John Smith"
        candidates = ["Jon Smith", "John Smyth"]
    
&gt;       with patch.object(orchestrator_service.embedding_service, 'find_similar_texts') as mock_search, \
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch.object(orchestrator_service.variants_service, 'find_best_matches') as mock_fallback:
E            AttributeError: 'UnifiedOrchestrator' object has no attribute 'embedding_service'. Did you mean: 'embeddings_service'?

tests/unit/test_orchestrator_service_old.py:238: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_analyze_text_complexity" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'signal_service'. Did you mean: 'signals_service'?">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b5466c0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f22a140&gt;

    @pytest.mark.asyncio
    async def test_analyze_text_complexity(self, orchestrator_service):
        """Test text complexity analysis"""
        # Arrange
        test_text = "Complex text for analysis"
    
        with patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.language_service, 'detect_language') as mock_language, \
&gt;            patch.object(orchestrator_service.signal_service, 'get_name_signals') as mock_signals:
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E            AttributeError: 'UnifiedOrchestrator' object has no attribute 'signal_service'. Did you mean: 'signals_service'?

tests/unit/test_orchestrator_service_old.py:265: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_get_processing_stats" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b5467b0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56f2298c0&gt;

    def test_get_processing_stats(self, orchestrator_service):
        """Test processing statistics retrieval"""
        # Arrange
        # Simulate some activity
&gt;       orchestrator_service.processing_stats['total_processed'] = 10
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'

tests/unit/test_orchestrator_service_old.py:304: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_clear_cache" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'clear_cache'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7c6350&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c2690&gt;

    def test_clear_cache(self, orchestrator_service):
        """Test cache clearing"""
        # Act
&gt;       orchestrator_service.clear_cache()
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'clear_cache'

tests/unit/test_orchestrator_service_old.py:324: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_reset_stats" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7c5a90&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c2140&gt;

    def test_reset_stats(self, orchestrator_service):
        """Test statistics reset"""
        # Arrange
&gt;       orchestrator_service.processing_stats['total_processed'] = 5
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'

tests/unit/test_orchestrator_service_old.py:333: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_generate_cache_key" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute '_generate_cache_key'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b4fbd40&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c1480&gt;

    def test_generate_cache_key(self, orchestrator_service):
        """Test cache key generation"""
        # Act
&gt;       key1 = orchestrator_service._generate_cache_key("test", True, False)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute '_generate_cache_key'

tests/unit/test_orchestrator_service_old.py:346: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_update_stats" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7e5010&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c0c00&gt;

    def test_update_stats(self, orchestrator_service):
        """Test statistics update"""
        # Arrange
&gt;       initial_processed = orchestrator_service.processing_stats['total_processed']
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'processing_stats'

tests/unit/test_orchestrator_service_old.py:359: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_calculate_complexity_score" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute '_calculate_complexity_score'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7e50d0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c0380&gt;

    def test_calculate_complexity_score(self, orchestrator_service):
        """Test complexity score calculation"""
        # Arrange
        unicode_complexity = {'confidence': 0.8}
        language_complexity = {'confidence': 0.9}
        name_complexity = {'confidence': 0.7}
    
        # Act
&gt;       score = orchestrator_service._calculate_complexity_score(
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            unicode_complexity,
            language_complexity,
            name_complexity
        )
E       AttributeError: 'UnifiedOrchestrator' object has no attribute '_calculate_complexity_score'

tests/unit/test_orchestrator_service_old.py:381: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_generate_complexity_recommendations" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute '_generate_complexity_recommendations'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b53f330&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c3460&gt;

    def test_generate_complexity_recommendations(self, orchestrator_service):
        """Test complexity recommendations generation"""
        # Act
&gt;       low_recommendations = orchestrator_service._generate_complexity_recommendations(0.2)
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute '_generate_complexity_recommendations'

tests/unit/test_orchestrator_service_old.py:394: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_force_reprocess_ignores_cache" time="0.001"><failure message="TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b53f1d0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c3ce0&gt;

    @pytest.mark.asyncio
    async def test_force_reprocess_ignores_cache(self, orchestrator_service):
        """Test that force_reprocess ignores cache"""
        # Arrange
        test_text = "Force reprocess test"
&gt;       cached_result = UnifiedProcessingResult(
            original_text=test_text,
            normalized_text="old cached result",
            language="en",
            language_confidence=0.5,
            variants=["old"]
        )
E       TypeError: UnifiedProcessingResult.__init__() missing 3 required positional arguments: 'tokens', 'trace', and 'signals'

tests/unit/test_orchestrator_service_old.py:415: TypeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_orchestrator_initialization" time="0.001"><failure message="AttributeError: 'UnifiedOrchestrator' object has no attribute 'cache_service'. Did you mean: 'unicode_service'?">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7d0eb0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x3fe6f85a0&gt;

    def test_orchestrator_initialization(self, orchestrator_service):
        """Test orchestrator initialization"""
        # Act - use the fixture instead of creating new instance
        orchestrator = orchestrator_service
    
        # Assert
&gt;       assert orchestrator.cache_service.max_size == 100  # From fixture
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'UnifiedOrchestrator' object has no attribute 'cache_service'. Did you mean: 'unicode_service'?

tests/unit/test_orchestrator_service_old.py:449: AttributeError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_language_service_failure" time="0.003"><failure message="AssertionError: assert 'uk' == 'en'&#10;  &#10;  - en&#10;  + uk">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b7d0690&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c3ac0&gt;

    @pytest.mark.asyncio
    async def test_process_language_service_failure(self, orchestrator_service):
        """Test resilience to language_service.detect_language failure"""
        # Arrange
        test_text = "Test text for language service failure"
    
        # Mock language_service.detect_language returns None
        with patch.object(orchestrator_service.language_service, 'detect_language') as mock_language, \
             patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.normalization_service, 'normalize') as mock_normalize:
    
            mock_unicode.return_value = {'normalized': test_text}
            mock_language.return_value = None  # Language service failure
            mock_normalize.return_value = {'normalized': test_text}
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert isinstance(result, UnifiedProcessingResult)
            # Check that we have either a successful result or an error
            if result.success:
&gt;               assert result.language == 'en'  # Should use fallback
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AssertionError: assert 'uk' == 'en'
E                 
E                 - en
E                 + uk

tests/unit/test_orchestrator_service_old.py:489: AssertionError</failure></testcase><testcase classname="tests.unit.test_orchestrator_service_old.TestOrchestratorService" name="test_process_normalization_service_exception" time="0.002"><failure message="AssertionError: assert True is False&#10; +  where True = UnifiedProcessingResult(original_text='Test text for normalization service exception', language='uk', language_confide...19be0&gt;, variants=None, embeddings=None, decision=None, processing_time=0.00011014938354492188, success=True, errors=[]).success">self = &lt;tests.unit.test_orchestrator_service_old.TestOrchestratorService object at 0x16b8089e0&gt;
orchestrator_service = &lt;src.ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4ff5c3240&gt;

    @pytest.mark.asyncio
    async def test_process_normalization_service_exception(self, orchestrator_service):
        """Test resilience to normalization_service.normalize exception"""
        # Arrange
        test_text = "Test text for normalization service exception"
    
        # Mock normalization_service.normalize throws exception
        with patch.object(orchestrator_service.unicode_service, 'normalize_text') as mock_unicode, \
             patch.object(orchestrator_service.language_service, 'detect_language') as mock_language, \
             patch.object(orchestrator_service.normalization_service, 'normalize') as mock_normalize:
    
            mock_unicode.return_value = {'normalized': test_text}
            mock_language.return_value = {'language': 'en', 'confidence': 0.9}
            mock_normalize.side_effect = Exception("Normalization service error")
    
            # Act
            result = await orchestrator_service.process(test_text)
    
            # Assert
            assert isinstance(result, UnifiedProcessingResult)
&gt;           assert result.success is False
E           AssertionError: assert True is False
E            +  where True = UnifiedProcessingResult(original_text='Test text for normalization service exception', language='uk', language_confide...19be0&gt;, variants=None, embeddings=None, decision=None, processing_time=0.00011014938354492188, success=True, errors=[]).success

tests/unit/test_orchestrator_service_old.py:518: AssertionError</failure></testcase><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_name_pattern_creation" time="0.001" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_generate_patterns_basic" time="0.005" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_generate_patterns_empty_text" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_generate_patterns_ukrainian" time="0.004" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_generate_patterns_compound_name" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_pattern_confidence_scoring" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_pattern_types_variety" time="0.001" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_pattern_metadata_inclusion" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_special_characters_handling" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_case_sensitivity_handling" time="0.000"><failure message="assert 0 &gt; 0&#10; +  where 0 = len([])">self = &lt;tests.unit.test_pattern_service.TestPatternService object at 0x16b546b70&gt;
pattern_service = &lt;src.ai_service.layers.patterns.unified_pattern_service.UnifiedPatternService object at 0x3fcbce8e0&gt;

    def test_case_sensitivity_handling(self, pattern_service):
        """Test case sensitivity handling"""
        # Act
        upper_patterns = pattern_service.generate_patterns("JOHN SMITH", "en")
        lower_patterns = pattern_service.generate_patterns("john smith", "en")
        mixed_patterns = pattern_service.generate_patterns("John Smith", "en")
    
        # Assert
        for patterns in [upper_patterns, lower_patterns, mixed_patterns]:
&gt;           assert len(patterns) &gt; 0
E           assert 0 &gt; 0
E            +  where 0 = len([])

tests/unit/test_pattern_service.py:192: AssertionError</failure></testcase><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_multilingual_pattern_generation" time="0.003" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_performance_with_long_names" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_error_handling_invalid_language" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_pattern_uniqueness" time="0.001" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_confidence_ordering" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_empty_and_whitespace_handling" time="0.000" /><testcase classname="tests.unit.test_pattern_service.TestPatternService" name="test_numeric_and_special_content" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_format_processing_result_with_decision" time="0.001" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_format_processing_result_without_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_format_error_response" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_extract_token_variants" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_extract_token_variants_empty_trace" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_risk_level_with_decision" time="0.001" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_risk_level_without_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_risk_score_with_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_risk_score_without_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_decision_reasons_with_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_decision_reasons_without_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_decision_details_with_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_get_decision_details_without_decision" time="0.001" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_extract_smart_filter_info_with_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_extract_smart_filter_info_without_decision" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_extract_signals_summary_with_data" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_extract_signals_summary_without_data" time="0.000" /><testcase classname="tests.unit.test_response_formatter.TestResponseFormatter" name="test_response_structure_completeness" time="0.002" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_python_version_valid" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_python_version_invalid" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_poetry_available" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_poetry_not_available" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_dependencies_success" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_dependencies_failure" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_dependencies_exception" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_spacy_models_all_available" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_spacy_models_some_missing_auto_install_success" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_check_spacy_models_all_missing_no_auto_install" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_run_service_success" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_run_service_no_service_file" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_run_service_exception" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_main_all_checks_pass" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_main_python_check_fails" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_main_poetry_check_fails" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_main_dependencies_check_fails" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScript" name="test_main_models_check_fails" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScriptIntegration" name="test_script_imports_successfully" time="0.000" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScriptIntegration" name="test_script_has_main_guard" time="0.001" /><testcase classname="tests.unit.test_run_service_script.TestRunServiceScriptIntegration" name="test_checks_list_structure" time="0.000" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_word_basic" time="0.050"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'Сергей', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer object at 0x16b753d90&gt;

    def test_analyze_word_basic(self):
        """Test basic analyze_word functionality"""
        # Mock pymorphy3 response
        mock_parse = Mock()
        mock_parse.normal_form = "Сергей"
        mock_parse.score = 1.0
    
        self.mock_pymorphy.parse.return_value = [mock_parse]
    
        result = self.analyzer.analyze_word('Сергей')
    
        # Check result structure
        assert isinstance(result, list)
        assert len(result) &gt; 0
&gt;       assert isinstance(result[0], MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'Сергей', ...}, MorphologicalAnalysis)

tests/unit/test_russian_morphology_unit.py:63: AssertionError</failure></testcase><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_gender_detection_male" time="0.042" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_gender_detection_female" time="0.033" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_declensions_generation" time="0.028" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_diminutives_generation" time="0.033" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_variants_generation" time="0.035" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_transliterations_generation" time="0.028" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_language_detection" time="0.033" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_is_russian_name" time="0.025"><failure message="AssertionError: assert False == True&#10; +  where False = is_known_word('Сергей')&#10; +    where is_known_word = &lt;src.ai_service.layers.normalization.morphology.russian_morphology.RussianMorphologyAnalyzer object at 0x4ff45d050&gt;.is_known_word&#10; +      where &lt;src.ai_service.layers.normalization.morphology.russian_morphology.RussianMorphologyAnalyzer object at 0x4ff45d050&gt; = &lt;tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer object at 0x16b767550&gt;.analyzer">self = &lt;tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer object at 0x16b767550&gt;

    def test_is_russian_name(self):
        """Test is_russian_name detection"""
        # Test known Russian names
&gt;       assert self.analyzer.is_known_word('Сергей') == True
E       AssertionError: assert False == True
E        +  where False = is_known_word('Сергей')
E        +    where is_known_word = &lt;src.ai_service.layers.normalization.morphology.russian_morphology.RussianMorphologyAnalyzer object at 0x4ff45d050&gt;.is_known_word
E        +      where &lt;src.ai_service.layers.normalization.morphology.russian_morphology.RussianMorphologyAnalyzer object at 0x4ff45d050&gt; = &lt;tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer object at 0x16b767550&gt;.analyzer

tests/unit/test_russian_morphology_unit.py:184: AssertionError</failure></testcase><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_name_complexity" time="0.027" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_phonetic_variants" time="0.028" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_regional_transliterations" time="0.031" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_basic" time="0.024"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'Сергей', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer object at 0x16b78a6d0&gt;

    def test_analyze_name_basic(self):
        """Test basic analyze_name functionality"""
        test_name = "Сергей"
    
        result = self.analyzer.analyze_word(test_name)
    
        # Should return analysis result
        assert isinstance(result, list)
        assert len(result) &gt; 0
        if result:  # If there are results
&gt;           assert isinstance(result[0], MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'Сергей', ...}, MorphologicalAnalysis)

tests/unit/test_russian_morphology_unit.py:250: AssertionError</failure></testcase><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_with_language" time="0.026"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'Сергей', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer object at 0x16b7f18b0&gt;

    def test_analyze_name_with_language(self):
        """Test analyze_name with language parameter"""
        test_name = "Сергей"
    
        # Note: analyze_word doesn't take language parameter
        result = self.analyzer.analyze_word(test_name)
    
        # Should return analysis result
        assert isinstance(result, list)
        assert len(result) &gt; 0
        if result:  # If there are results
&gt;           assert isinstance(result[0], MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'Сергей', ...}, MorphologicalAnalysis)

tests/unit/test_russian_morphology_unit.py:263: AssertionError</failure></testcase><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_empty_input" time="0.032" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_none_input" time="0.049" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_whitespace_input" time="0.023" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_special_characters" time="0.024" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_numbers" time="0.036" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_mixed_case" time="0.036" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_very_long" time="0.031" /><testcase classname="tests.unit.test_russian_morphology_unit.TestRussianMorphologyAnalyzer" name="test_analyze_name_unicode_characters" time="0.031" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_analyze_payment_description" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_date_only_text" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_exclusion_patterns" time="0.000" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_initialization" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_initialization_with_terrorism_detection" time="0.001"><failure message="AttributeError: &lt;module 'ai_service.layers.smart_filter.smart_filter_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/smart_filter/smart_filter_service.py'&gt; does not have the attribute 'SignalService'">self = &lt;tests.unit.test_smart_filter_service.TestSmartFilterService testMethod=test_initialization_with_terrorism_detection&gt;

    def test_initialization_with_terrorism_detection(self):
        """Test service initialization with terrorism detection enabled"""
&gt;       with patch('ai_service.layers.smart_filter.smart_filter_service.SignalService'):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_smart_filter_service.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x4ff520d60&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x4ff520d60&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'ai_service.layers.smart_filter.smart_filter_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/smart_filter/smart_filter_service.py'&gt; does not have the attribute 'SignalService'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_language_composition_analysis" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_language_detection" time="0.000" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_make_smart_decision" time="0.001"><failure message="AttributeError: &lt;module 'ai_service.layers.smart_filter.smart_filter_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/smart_filter/smart_filter_service.py'&gt; does not have the attribute 'SignalService'">self = &lt;tests.unit.test_smart_filter_service.TestSmartFilterService testMethod=test_make_smart_decision&gt;
mock_decision_logic = &lt;MagicMock name='DecisionLogic' id='22819632000'&gt;

    @patch('ai_service.layers.smart_filter.smart_filter_service.DecisionLogic')
    def test_make_smart_decision(self, mock_decision_logic):
        """Test smart decision making"""
        # Mock decision result
        mock_decision_result = MagicMock()
        mock_decision_result.decision = DecisionType.FULL_SEARCH
        mock_decision_result.confidence = 0.8
        mock_decision_result.risk_level = RiskLevel.MEDIUM
        mock_decision_result.reasoning = "Test reasoning"
        mock_decision_result.recommendations = ["Test recommendation"]
        mock_decision_result.requires_escalation = False
        mock_decision_result.processing_time = 0.001
        mock_decision_result.detected_signals = {}
        mock_decision_result.metadata = {}
    
        mock_decision_logic.return_value.make_decision.return_value = mock_decision_result
    
&gt;       with patch('ai_service.layers.smart_filter.smart_filter_service.SignalService'):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_smart_filter_service.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x4ff521860&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x4ff521860&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'ai_service.layers.smart_filter.smart_filter_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/smart_filter/smart_filter_service.py'&gt; does not have the attribute 'SignalService'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_service_words_cleaning" time="0.001"><failure message="AssertionError: 'оплата за консультацію Петров Іван' == 'оплата за консультацію Петров Іван'">self = &lt;tests.unit.test_smart_filter_service.TestSmartFilterService testMethod=test_service_words_cleaning&gt;

    def test_service_words_cleaning(self):
        """Test service words cleaning"""
        text_with_service_words = "оплата за консультацію Петров Іван"
        cleaned = self.smart_filter._clean_service_words(text_with_service_words)
    
        # Should remove "оплата за" from the beginning
&gt;       self.assertNotEqual(cleaned, text_with_service_words)
E       AssertionError: 'оплата за консультацію Петров Іван' == 'оплата за консультацію Петров Іван'

tests/unit/test_smart_filter_service.py:195: AssertionError</failure></testcase><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_should_process_text_empty" time="0.000" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_should_process_text_excluded" time="0.001"><failure message="AssertionError: 'исключен' not found in 'Text excluded from processing (service information only)'">self = &lt;tests.unit.test_smart_filter_service.TestSmartFilterService testMethod=test_should_process_text_excluded&gt;

    def test_should_process_text_excluded(self):
        """Test processing excluded text"""
        # Mock the exclusion check
        with patch.object(self.smart_filter, '_is_excluded_text', return_value=True):
            result = self.smart_filter.should_process_text("оплата")
    
            self.assertFalse(result.should_process)
&gt;           self.assertIn("исключен", result.processing_recommendation)
E           AssertionError: 'исключен' not found in 'Text excluded from processing (service information only)'

tests/unit/test_smart_filter_service.py:59: AssertionError</failure></testcase><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_should_process_text_with_signals" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterService" name="test_text_normalization" time="0.000" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterIntegration" name="test_company_detection" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterIntegration" name="test_person_name_detection" time="0.001" /><testcase classname="tests.unit.test_smart_filter_service.TestSmartFilterIntegration" name="test_safe_content_handling" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_1_ac_disabled_petrov_no_context" time="0.000" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_2_ac_enabled_with_document_pattern" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_3_ac_enabled_nasa_no_trigger" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_4_ac_enabled_petrov_with_context" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_5_ac_verification_in_name_detector" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_6_confidence_comparison_with_without_ac" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_7_adapter_integration_ac_disabled" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_8_adapter_integration_ac_enabled" time="0.001" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_9_config_flag_behavior" time="0.000" /><testcase classname="tests.unit.test_smartfilter_aho.TestSmartFilterAhoCorasickIntegration" name="test_scenario_10_edge_cases" time="0.002" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_template_creation" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_entity_template_initialization" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_entity_template_to_dict" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_entity_template_to_dict_with_numpy_embeddings" time="0.001" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_get_search_keywords" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_get_high_confidence_patterns" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_build_templates_batch" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_build_templates_batch_with_embeddings" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_build_templates_batch_error_handling" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_calculate_complexity_score" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_get_templates_statistics" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_get_templates_statistics_empty" time="0.001" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_export_templates_for_aho_corasick" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_template_builder_error_handling" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_complexity_score_edge_cases" time="0.000" /><testcase classname="tests.unit.test_template_builder.TestTemplateBuilder" name="test_template_post_init" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_create_empty_result" time="0.001" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_detect_activity_patterns" time="0.001" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_detect_financing_patterns" time="0.001" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_detect_organization_patterns" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_detect_terrorism_signals_empty" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_detect_terrorism_signals_excluded_content" time="0.001" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_detect_weapons_patterns" time="0.001" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_determine_risk_level" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_extract_detected_indicators" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_get_risk_assessment" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_initialization" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetector" name="test_is_excluded_content" time="0.001" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_defensive_purpose_only" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_false_positive_prevention" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_pattern_weights_balance" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorSafety" name="test_risk_escalation_thresholds" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorIntegration" name="test_comprehensive_threat_assessment" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorIntegration" name="test_defensive_system_requirements" time="0.000" /><testcase classname="tests.unit.test_terrorism_detector.TestTerrorismDetectorIntegration" name="test_risk_assessment_workflow" time="0.000" /><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0421\u0435\u0440\u0433\u0456\u0439-masc-uk]" time="0.038"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b87f610&gt;
name = 'Сергій', expected_gender = 'masc', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041e\u043b\u0435\u043d\u0430-femn-uk]" time="0.020"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'олена', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b87f750&gt;
name = 'Олена', expected_gender = 'femn', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'олена', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0412\u043e\u043b\u043e\u0434\u0438\u043c\u0438\u0440-masc-uk]" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'володимир', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8a0640&gt;
name = 'Володимир', expected_gender = 'masc', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'володимир', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0414\u0430\u0440\u0456\u044f-femn-uk]" time="0.044"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'дарія', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8a0770&gt;
name = 'Дарія', expected_gender = 'femn', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'дарія', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041f\u0435\u0442\u0440\u043e-masc-uk]" time="0.020"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8d8a70&gt;
name = 'Петро', expected_gender = 'masc', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u0410\u043d\u043d\u0430-femn-uk]" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'анна', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8b06b0&gt;
name = 'Анна', expected_gender = 'femn', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'анна', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041c\u0438\u0445\u0430\u0439\u043b\u043e-masc-uk]" time="0.020"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'михайло', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8b07c0&gt;
name = 'Михайло', expected_gender = 'masc', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'михайло', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_detection_for_ukrainian_names[\u041a\u0430\u0442\u0435\u0440\u0438\u043d\u0430-femn-uk]" time="0.035"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'катерина', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8cc250&gt;
name = 'Катерина', expected_gender = 'femn', expected_language = 'uk'

    @pytest.mark.parametrize("name,expected_gender,expected_language", [
        ("Сергій", "masc", "uk"),
        ("Олена", "femn", "uk"),
        ("Володимир", "masc", "uk"),
        ("Дарія", "femn", "uk"),
        ("Петро", "masc", "uk"),
        ("Анна", "femn", "uk"),
        ("Михайло", "masc", "uk"),
        ("Катерина", "femn", "uk"),
    ])
    def test_gender_detection_for_ukrainian_names(self, name, expected_gender, expected_language):
        """Parameterized test for gender detection of Ukrainian names"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'катерина', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:37: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_diminutives_generation" time="0.034"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8cc350&gt;

    def test_diminutives_generation(self):
        """Test generation of diminutive forms"""
        # Act
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:257: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_transliteration_generation" time="0.023"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8b85f0&gt;

    def test_transliteration_generation(self):
        """Test generation of transliterations"""
        # Act
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:268: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u043e-expected_endings0]" time="0.039"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'masc', 'lemma': 'петренко', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8b88c0&gt;
name = 'Петренко', expected_endings = ['ко']

    @pytest.mark.parametrize("name,expected_endings", [
        ("Петренко", ["ко"]),
        ("Іваненко", ["енко"]),
        ("Мельник", ["ник"]),
        ("Шевченко", ["енко"]),
    ])
    def test_ukrainian_surname_endings(self, name, expected_endings):
        """Parameterized test for Ukrainian surname endings"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'masc', 'lemma': 'петренко', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:86: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u0406\u0432\u0430\u043d\u0435\u043d\u043a\u043e-expected_endings1]" time="0.030"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'masc', 'lemma': 'іваненко', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8aba10&gt;
name = 'Іваненко', expected_endings = ['енко']

    @pytest.mark.parametrize("name,expected_endings", [
        ("Петренко", ["ко"]),
        ("Іваненко", ["енко"]),
        ("Мельник", ["ник"]),
        ("Шевченко", ["енко"]),
    ])
    def test_ukrainian_surname_endings(self, name, expected_endings):
        """Parameterized test for Ukrainian surname endings"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'masc', 'lemma': 'іваненко', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:86: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u041c\u0435\u043b\u044c\u043d\u0438\u043a-expected_endings2]" time="0.023"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'мельник', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8abbd0&gt;
name = 'Мельник', expected_endings = ['ник']

    @pytest.mark.parametrize("name,expected_endings", [
        ("Петренко", ["ко"]),
        ("Іваненко", ["енко"]),
        ("Мельник", ["ник"]),
        ("Шевченко", ["енко"]),
    ])
    def test_ukrainian_surname_endings(self, name, expected_endings):
        """Parameterized test for Ukrainian surname endings"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'мельник', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:86: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_surname_endings[\u0428\u0435\u0432\u0447\u0435\u043d\u043a\u043e-expected_endings3]" time="0.062"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'masc', 'lemma': 'шевченко', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b7f3ba0&gt;
name = 'Шевченко', expected_endings = ['енко']

    @pytest.mark.parametrize("name,expected_endings", [
        ("Петренко", ["ко"]),
        ("Іваненко", ["енко"]),
        ("Мельник", ["ник"]),
        ("Шевченко", ["енко"]),
    ])
    def test_ukrainian_surname_endings(self, name, expected_endings):
        """Parameterized test for Ukrainian surname endings"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'masc', 'lemma': 'шевченко', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:86: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_edge_cases_handling[-expected_result0]" time="0.019" /><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_edge_cases_handling[\u0410-expected_result1]" time="0.024"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.1, 'gender': None, 'lemma': 'А', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b7e7590&gt;
input_name = 'А', expected_result = {'name': 'А', 'total_forms': 1}

    @pytest.mark.parametrize("input_name,expected_result", [
        ("", {'name': '', 'total_forms': 0}),
        ("А", {'name': 'А', 'total_forms': 1}),
        ("Сергій", {'name': 'Сергій', 'total_forms': 0}),  # Will check after analysis
    ])
    def test_edge_cases_handling(self, input_name, expected_result):
        """Parameterized test for edge cases handling"""
        # Act
        results = self.analyzer.analyze_word(input_name)
        if input_name:  # If name is not empty
            assert len(results) &gt; 0
            result = results[0]
    
            # Assert
&gt;           assert isinstance(result, MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.1, 'gender': None, 'lemma': 'А', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:103: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_edge_cases_handling[\u0421\u0435\u0440\u0433\u0456\u0439-expected_result2]" time="0.033"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b87b490&gt;
input_name = 'Сергій', expected_result = {'name': 'Сергій', 'total_forms': 0}

    @pytest.mark.parametrize("input_name,expected_result", [
        ("", {'name': '', 'total_forms': 0}),
        ("А", {'name': 'А', 'total_forms': 1}),
        ("Сергій", {'name': 'Сергій', 'total_forms': 0}),  # Will check after analysis
    ])
    def test_edge_cases_handling(self, input_name, expected_result):
        """Parameterized test for edge cases handling"""
        # Act
        results = self.analyzer.analyze_word(input_name)
        if input_name:  # If name is not empty
            assert len(results) &gt; 0
            result = results[0]
    
            # Assert
&gt;           assert isinstance(result, MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:103: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u0421\u0435\u0440\u0433\u0456\u0439-expected_ukrainian_chars0]" time="0.021"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b87b6a0&gt;
name = 'Сергій', expected_ukrainian_chars = ['і']

    @pytest.mark.parametrize("name,expected_ukrainian_chars", [
        ("Сергій", ["і"]),
        ("Олексій", ["і"]),
        ("Володимир", []),  # Does not contain Ukrainian symbols
        ("Дарія", ["і"]),
        ("Петро", []),  # Does not contain Ukrainian symbols
    ])
    def test_ukrainian_character_detection(self, name, expected_ukrainian_chars):
        """Parameterized test for Ukrainian character detection"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:121: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u041e\u043b\u0435\u043a\u0441\u0456\u0439-expected_ukrainian_chars1]" time="0.034"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'олексій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8d6030&gt;
name = 'Олексій', expected_ukrainian_chars = ['і']

    @pytest.mark.parametrize("name,expected_ukrainian_chars", [
        ("Сергій", ["і"]),
        ("Олексій", ["і"]),
        ("Володимир", []),  # Does not contain Ukrainian symbols
        ("Дарія", ["і"]),
        ("Петро", []),  # Does not contain Ukrainian symbols
    ])
    def test_ukrainian_character_detection(self, name, expected_ukrainian_chars):
        """Parameterized test for Ukrainian character detection"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'олексій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:121: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u0412\u043e\u043b\u043e\u0434\u0438\u043c\u0438\u0440-expected_ukrainian_chars2]" time="0.027"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'володимир', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8d5ef0&gt;
name = 'Володимир', expected_ukrainian_chars = []

    @pytest.mark.parametrize("name,expected_ukrainian_chars", [
        ("Сергій", ["і"]),
        ("Олексій", ["і"]),
        ("Володимир", []),  # Does not contain Ukrainian symbols
        ("Дарія", ["і"]),
        ("Петро", []),  # Does not contain Ukrainian symbols
    ])
    def test_ukrainian_character_detection(self, name, expected_ukrainian_chars):
        """Parameterized test for Ukrainian character detection"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'володимир', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:121: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u0414\u0430\u0440\u0456\u044f-expected_ukrainian_chars3]" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'дарія', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b862a80&gt;
name = 'Дарія', expected_ukrainian_chars = ['і']

    @pytest.mark.parametrize("name,expected_ukrainian_chars", [
        ("Сергій", ["і"]),
        ("Олексій", ["і"]),
        ("Володимир", []),  # Does not contain Ukrainian symbols
        ("Дарія", ["і"]),
        ("Петро", []),  # Does not contain Ukrainian symbols
    ])
    def test_ukrainian_character_detection(self, name, expected_ukrainian_chars):
        """Parameterized test for Ukrainian character detection"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'дарія', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:121: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_ukrainian_character_detection[\u041f\u0435\u0442\u0440\u043e-expected_ukrainian_chars4]" time="0.026"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8a5c50&gt;
name = 'Петро', expected_ukrainian_chars = []

    @pytest.mark.parametrize("name,expected_ukrainian_chars", [
        ("Сергій", ["і"]),
        ("Олексій", ["і"]),
        ("Володимир", []),  # Does not contain Ukrainian symbols
        ("Дарія", ["і"]),
        ("Петро", []),  # Does not contain Ukrainian symbols
    ])
    def test_ukrainian_character_detection(self, name, expected_ukrainian_chars):
        """Parameterized test for Ukrainian character detection"""
        # Act
        results = self.analyzer.analyze_word(name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:121: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_name_complexity_analysis" time="0.023"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8f0d50&gt;

    def test_name_complexity_analysis(self):
        """Test name complexity analysis"""
        # Act
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:339: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_correction_logic" time="0.026"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b7ef690&gt;

    def test_gender_correction_logic(self):
        """Critical test: checking gender correction logic"""
        # Act
        results = self.analyzer.analyze_word("Петро")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:166: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_basic_functionality" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b855320&gt;

    def test_analyze_name_basic_functionality(self):
        """Test basic functionality of name analysis"""
        # Act
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:177: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_empty_name_handling" time="0.026" /><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_short_name_handling" time="0.020"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.1, 'gender': None, 'lemma': 'А', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b86b110&gt;

    def test_short_name_handling(self):
        """Test handling of too short name"""
        # Act
        results = self.analyzer.analyze_word("А")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.1, 'gender': None, 'lemma': 'А', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:199: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_auto_language_detection" time="0.027"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b887610&gt;

    def test_auto_language_detection(self):
        """Test automatic language detection"""
        # Arrange
        ukrainian_name = "Сергій"  # Contains Ukrainian letter 'і'
        russian_name = "Сергей"   # Contains Russian letter 'е'
    
        # Act
        uk_results = self.analyzer.analyze_word(ukrainian_name)
        ru_results = self.analyzer.analyze_word(russian_name)
        assert len(uk_results) &gt; 0
        assert len(ru_results) &gt; 0
        uk_result = uk_results[0]
        ru_result = ru_results[0]
    
        # Assert
&gt;       assert isinstance(uk_result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:217: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_pymorphy3_initialization_success" time="0.047" /><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_gender_exceptions_dictionary" time="0.030"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b887480&gt;

    def test_gender_exceptions_dictionary(self):
        """Test gender exceptions dictionary"""
        # Act &amp; Assert
        # Check male names
        for male_name in ['Петро', 'Іван', 'Сергій', 'Володимир']:
            results = self.analyzer.analyze_word(male_name)
            assert len(results) &gt; 0
            result = results[0]
&gt;           assert isinstance(result, MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:238: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_phonetic_variants_generation" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8874d0&gt;

    def test_phonetic_variants_generation(self):
        """Test generation of phonetic variants"""
        # Arrange
        name_with_phonetic_patterns = "Сергій"  # Contains 'г' which can be replaced
    
        # Act
        results = self.analyzer.analyze_word(name_with_phonetic_patterns)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:282: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_regional_transliterations" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8875c0&gt;

    def test_regional_transliterations(self):
        """Test regional transliterations"""
        # Arrange
        ukrainian_name = "Сергій"  # Contains Ukrainian letter 'і'
    
        # Act
        results = self.analyzer.analyze_word(ukrainian_name)
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:296: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_get_all_forms_method" time="0.021"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0780&gt;

    def test_get_all_forms_method(self):
        """Test method for getting all name forms"""
        # Act
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:307: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_is_ukrainian_name_detection" time="0.025"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0910&gt;

    def test_is_ukrainian_name_detection(self):
        """Test Ukrainian name detection"""
        # Act &amp; Assert
        results1 = self.analyzer.analyze_word("Сергій")
        results2 = self.analyzer.analyze_word("Богдан")
        results3 = self.analyzer.analyze_word("Іваненко")
        assert len(results1) &gt; 0
        assert len(results2) &gt; 0
        assert len(results3) &gt; 0
        result1 = results1[0]
        result2 = results2[0]
        result3 = results3[0]
    
        # Assert
&gt;       assert isinstance(result1, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:324: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_complexity_level_calculation" time="0.033"><failure message="AttributeError: 'dict' object has no attribute 'confidence'">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0960&gt;

    def test_complexity_level_calculation(self):
        """Test complexity level calculation"""
        # Act &amp; Assert - using real analysis methods
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
&gt;       assert result.confidence &gt;= 0.0
               ^^^^^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'confidence'

tests/unit/test_ukrainian_morphology.py:348: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_basic_transliteration" time="0.021"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e09b0&gt;

    def test_basic_transliteration(self):
        """Test basic transliteration"""
        # Act - using real analysis method
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:359: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_language_detection_internal" time="0.032"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0a00&gt;

    def test_language_detection_internal(self):
        """Test internal language detection"""
        # Act &amp; Assert - using real analysis methods
        results1 = self.analyzer.analyze_word("Сергій")
        results2 = self.analyzer.analyze_word("Сергей")
        assert len(results1) &gt; 0
        assert len(results2) &gt; 0
        result1 = results1[0]
        result2 = results2[0]
    
        # Check that analysis works for both variants
&gt;       assert isinstance(result1, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:373: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_pymorphy_analysis_failure_handling" time="0.021"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'тест', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0a50&gt;
mock_pymorphy = &lt;MagicMock name='_analyze_with_pymorphy' id='24573182368'&gt;

    @patch.object(UkrainianMorphologyAnalyzer, '_analyze_with_pymorphy')
    def test_pymorphy_analysis_failure_handling(self, mock_pymorphy):
        """Test handling of pymorphy analysis error"""
        # Arrange
        mock_pymorphy.side_effect = Exception("Pymorphy analysis failed")
    
        # Act
        results = self.analyzer.analyze_word("Тест")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
        # Should work even with pymorphy error
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'тест', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:389: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_generate_pymorphy_declensions" time="0.041"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0aa0&gt;

    def test_generate_pymorphy_declensions(self):
        """Test generation of declensions via pymorphy3"""
        # Act - using real analysis method
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:400: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_extract_gender_with_name_tags" time="0.024"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'femn', 'lemma': 'дарья', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0af0&gt;

    def test_extract_gender_with_name_tags(self):
        """Test extraction of gender with name tags"""
        # Act - using real analysis method
        results = self.analyzer.analyze_word("Дарья")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': 'femn', 'lemma': 'дарья', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:411: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_extract_gender_by_endings" time="0.023"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'новий', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0b40&gt;

    def test_extract_gender_by_endings(self):
        """Test gender determination by endings"""
        # Act - using real analysis methods
        results1 = self.analyzer.analyze_word("Новий")
        results2 = self.analyzer.analyze_word("Нова")
        assert len(results1) &gt; 0
        assert len(results2) &gt; 0
        result1 = results1[0]
        result2 = results2[0]
    
        # Assert
&gt;       assert isinstance(result1, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'новий', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:425: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_apply_regional_transliteration" time="0.074"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0b90&gt;

    def test_apply_regional_transliteration(self):
        """Test application of regional transliteration"""
        # Act - using real analysis method
        results = self.analyzer.analyze_word("Сергій")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:438: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_whitespace_name_handling" time="0.022"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer object at 0x16b8e0be0&gt;

    def test_whitespace_name_handling(self):
        """Test handling of names with whitespace"""
        # Act
        results = self.analyzer.analyze_word("  Сергій  ")
        assert len(results) &gt; 0
        result = results[0]
    
        # Assert
&gt;       assert isinstance(result, MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'сергій', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology.py:449: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology.TestUkrainianMorphologyAnalyzer" name="test_none_name_handling" time="0.050" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_gender_detection_petro" time="0.092"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b87f890&gt;

    def test_analyze_word_gender_detection_petro(self):
        """Test that analyze_word correctly determines gender for "Петро" """
        # Mock pymorphy3 response
        mock_parse = Mock()
        mock_parse.normal_form = "Петро"
        mock_parse.score = 1.0
    
        self.mock_pymorphy.parse.return_value = [mock_parse]
    
        result = self.analyzer.analyze_word('Петро')
    
        # Check result structure
        assert isinstance(result, list)
        assert len(result) &gt; 0
&gt;       assert isinstance(result[0], MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology_unit.py:63: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_gender_detection_daria" time="0.026"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'дарія', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b87f9d0&gt;

    def test_analyze_word_gender_detection_daria(self):
        """Test that analyze_word correctly determines gender for "Дарія" """
        # Mock pymorphy3 response
        mock_parse = Mock()
        mock_parse.normal_form = "Дарія"
        mock_parse.score = 1.0
    
        self.mock_pymorphy.parse.return_value = [mock_parse]
    
        result = self.analyzer.analyze_word('Дарія')
    
        # Check result structure
        assert isinstance(result, list)
        assert len(result) &gt; 0
&gt;       assert isinstance(result[0], MorphologicalAnalysis)
E       AssertionError: assert False
E        +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'femn', 'lemma': 'дарія', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology_unit.py:79: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_unknown_name" time="0.048"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'тест', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8a09d0&gt;

    def test_analyze_word_unknown_name(self):
        """Test analysis of unknown name"""
        # Mock pymorphy3 response for unknown name
        mock_parse = Mock()
        mock_parse.normal_form = "Тест"
        mock_parse.score = 0.5
    
        self.mock_pymorphy.parse.return_value = [mock_parse]
    
        result = self.analyzer.analyze_word("Тест")
    
        # Should return fallback analysis
        assert isinstance(result, list)
        assert len(result) &gt; 0
        if result:  # If there are results
&gt;           assert isinstance(result[0], MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'тест', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology_unit.py:96: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_word_short_name" time="0.197"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'абвгд', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8a08a0&gt;

    def test_analyze_word_short_name(self):
        """Test analysis of short name"""
        result = self.analyzer.analyze_word("Абвгд")
    
        # Should return fallback analysis for short names
        assert isinstance(result, list)
        assert len(result) &gt; 0
        if result:  # If there are results
&gt;           assert isinstance(result[0], MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.3, 'gender': None, 'lemma': 'абвгд', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology_unit.py:106: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_lemma_special_name" time="0.104" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_lemma_unknown_name" time="0.039" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_is_known_word_special_name" time="0.042"><failure message="assert False is True">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8b0c00&gt;

    def test_is_known_word_special_name(self):
        """Test is_known_word for special name"""
        test_name = "Петро"
    
        result = self.analyzer.is_known_word(test_name)
    
        # Should return True for special names
&gt;       assert result is True
E       assert False is True

tests/unit/test_ukrainian_morphology_unit.py:147: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_is_known_word_unknown_name" time="0.110" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_gender_special_name" time="0.049"><failure message="AttributeError: 'dict' object has no attribute 'gender'">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8cc750&gt;

    def test_get_gender_special_name(self):
        """Test gender detection for special name"""
        test_name = "Петро"
    
        results = self.analyzer.analyze_word(test_name)
        assert len(results) &gt; 0
    
        result = results[0]
        # Should return correct gender for special names
&gt;       assert result.gender == 'masc'  # Petro is masculine
               ^^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'gender'

tests/unit/test_ukrainian_morphology_unit.py:174: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_gender_unknown_name" time="0.052"><failure message="AttributeError: 'dict' object has no attribute 'lemma'">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8b8aa0&gt;

    def test_get_gender_unknown_name(self):
        """Test gender detection for unknown name"""
        test_name = "Тест"
    
        results = self.analyzer.analyze_word(test_name)
        # May return empty results for unknown words
        if len(results) &gt; 0:
            result = results[0]
            # Should return analysis result, gender may be None for unknown words
&gt;           assert isinstance(result.lemma, str)
                              ^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'lemma'

tests/unit/test_ukrainian_morphology_unit.py:185: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_variants_special_name" time="0.037"><failure message="AttributeError: 'dict' object has no attribute 'lemma'">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8b8b90&gt;

    def test_get_variants_special_name(self):
        """Test getting variants for special name"""
        test_name = "Петро"
    
        results = self.analyzer.analyze_word(test_name)
        # May return empty results for unknown words
        if len(results) &gt; 0:
            result = results[0]
            # Should return analysis result with lemma and gender
&gt;           assert isinstance(result.lemma, str)
                              ^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'lemma'

tests/unit/test_ukrainian_morphology_unit.py:198: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_variants_unknown_name" time="0.043"><failure message="AttributeError: 'dict' object has no attribute 'lemma'">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8f7a10&gt;

    def test_get_variants_unknown_name(self):
        """Test getting variants for unknown name"""
        test_name = "Тест"
    
        results = self.analyzer.analyze_word(test_name)
        assert len(results) &gt; 0
    
        result = results[0]
        # Should return analysis result with lemma
&gt;       assert isinstance(result.lemma, str)
                          ^^^^^^^^^^^^
E       AttributeError: 'dict' object has no attribute 'lemma'

tests/unit/test_ukrainian_morphology_unit.py:211: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_diminutives_special_name" time="0.044"><failure message="AttributeError: 'dict' object has no attribute 'lemma'">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b8f7cb0&gt;

    def test_get_diminutives_special_name(self):
        """Test getting diminutives for special name"""
        test_name = "Петро"
    
        results = self.analyzer.analyze_word(test_name)
        # May return empty results for unknown words
        if len(results) &gt; 0:
            result = results[0]
            # Should return analysis result with lemma and gender
&gt;           assert isinstance(result.lemma, str)
                              ^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'lemma'

tests/unit/test_ukrainian_morphology_unit.py:223: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_get_diminutives_unknown_name" time="0.103"><failure message="AttributeError: 'dict' object has no attribute 'lemma'">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b7f3ee0&gt;

    def test_get_diminutives_unknown_name(self):
        """Test getting diminutives for unknown name"""
        test_name = "Тест"
    
        results = self.analyzer.analyze_word(test_name)
        # May return empty results for unknown words
        if len(results) &gt; 0:
            result = results[0]
            # Should return analysis result with lemma
&gt;           assert isinstance(result.lemma, str)
                              ^^^^^^^^^^^^
E           AttributeError: 'dict' object has no attribute 'lemma'

tests/unit/test_ukrainian_morphology_unit.py:237: AttributeError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_basic_functionality" time="0.063"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b7e77d0&gt;

    def test_analyze_name_basic_functionality(self):
        """Test basic analyze_name functionality"""
        test_name = "Петро"
    
        result = self.analyzer.analyze_word(test_name)
    
        # Should return analysis result
        assert isinstance(result, list)
        # May return empty results for unknown words
        if len(result) &gt; 0:
&gt;           assert isinstance(result[0], MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology_unit.py:250: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_with_language_detection" time="0.066"><failure message="AssertionError: assert False&#10; +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)">self = &lt;tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer object at 0x16b7e7890&gt;

    def test_analyze_name_with_language_detection(self):
        """Test analyze_name with language detection"""
        test_name = "Петро"
    
        result = self.analyzer.analyze_word(test_name)
    
        # Should return analysis result
        assert isinstance(result, list)
        # May return empty results for unknown words
        if len(result) &gt; 0:
&gt;           assert isinstance(result[0], MorphologicalAnalysis)
E           AssertionError: assert False
E            +  where False = isinstance({'case': None, 'confidence': 0.8, 'gender': 'masc', 'lemma': 'петро', ...}, MorphologicalAnalysis)

tests/unit/test_ukrainian_morphology_unit.py:262: AssertionError</failure></testcase><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_empty_string" time="0.526" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_whitespace_only" time="0.065" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_none_input" time="0.152" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_special_characters" time="0.054" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_numbers" time="0.055" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_mixed_case" time="0.025" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_very_long" time="0.023" /><testcase classname="tests.unit.test_ukrainian_morphology_unit.TestUkrainianMorphologyAnalyzer" name="test_analyze_name_unicode_characters" time="0.027" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_aggressive_normalization_sao_paulo" time="0.008" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_cyrillic_processing" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_empty_text_handling" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_none_text_handling" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_complex_mappings_applied" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_confidence_calculation" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_batch_normalization" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_similarity_score" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_encoding_issues_detection" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_final_cleanup" time="0.001"><failure message="AssertionError: assert 'Multiple spaces' == 'multiple spaces'&#10;  &#10;  - multiple spaces&#10;  ? ^&#10;  + Multiple spaces&#10;  ? ^">self = &lt;tests.unit.test_unicode_service.TestUnicodeService object at 0x16b8b9130&gt;
unicode_service = &lt;src.ai_service.layers.unicode.unicode_service.UnicodeService object at 0x3feca2ff0&gt;

    def test_final_cleanup(self, unicode_service):
        """Test final text cleanup"""
        # Arrange
        messy_text = "  Multiple   spaces  \t\n  "
    
        # Act
        result = unicode_service.normalize_text(messy_text)
    
        # Assert
        normalized = result['normalized']
&gt;       assert normalized == "multiple spaces"  # Should be cleaned and converted to lowercase
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'Multiple spaces' == 'multiple spaces'
E         
E         - multiple spaces
E         ? ^
E         + Multiple spaces
E         ? ^

tests/unit/test_unicode_service.py:181: AssertionError</failure></testcase><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_preserve_chars_functionality" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_unicode_normalization_nfd_nfkc" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_ascii_folding_failure_handling" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_unicode_normalization_failure_handling" time="0.002"><failure message="AttributeError: module 'src.ai_service.services' has no attribute 'unicode_service'">args = (&lt;tests.unit.test_unicode_service.TestUnicodeService object at 0x16b938050&gt;,)
keywargs = {'unicode_service': &lt;src.ai_service.layers.unicode.unicode_service.UnicodeService object at 0x3fec39790&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib._GeneratorContextManager object at 0x16b907690&gt;

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
&gt;           return next(self.gen)
                   ^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x16b87be30&gt;
patched = &lt;function TestUnicodeService.test_unicode_normalization_failure_handling at 0x16b90fce0&gt;
args = (&lt;tests.unit.test_unicode_service.TestUnicodeService object at 0x16b938050&gt;,)
keywargs = {'unicode_service': &lt;src.ai_service.layers.unicode.unicode_service.UnicodeService object at 0x3fec39790&gt;}

    @contextlib.contextmanager
    def decoration_helper(self, patched, args, keywargs):
        extra_args = []
        with contextlib.ExitStack() as exit_stack:
            for patching in patched.patchings:
&gt;               arg = exit_stack.enter_context(patching)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;contextlib.ExitStack object at 0x3fec8e030&gt;
cm = &lt;unittest.mock._patch object at 0x16b87be30&gt;

    def enter_context(self, cm):
        """Enters the supplied context manager.
    
        If successful, also pushes its __exit__ method as a callback and
        returns the result of the __enter__ method.
        """
        # We look up the special methods on the type to match the with
        # statement.
        cls = type(cm)
        try:
            _enter = cls.__enter__
            _exit = cls.__exit__
        except AttributeError:
            raise TypeError(f"'{cls.__module__}.{cls.__qualname__}' object does "
                            f"not support the context manager protocol") from None
&gt;       result = _enter(cm)
                 ^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x16b87be30&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
&gt;       self.target = self.getter()
                      ^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1481: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.ai_service.services.unicode_service.unicodedata'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.ai_service.services' has no attribute 'unicode_service'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_length_metadata" time="0.000" /><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_case_normalization" time="0.000"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in method islower of str object at 0x3fecb42f0&gt;()&#10; +    where &lt;built-in method islower of str object at 0x3fecb42f0&gt; = 'MiXeD CaSe TeXt'.islower">self = &lt;tests.unit.test_unicode_service.TestUnicodeService object at 0x16b93c110&gt;
unicode_service = &lt;src.ai_service.layers.unicode.unicode_service.UnicodeService object at 0x4ce87bef0&gt;

    def test_case_normalization(self, unicode_service):
        """Test case normalization"""
        # Arrange
        mixed_case_text = "MiXeD CaSe TeXt"
    
        # Act
        result = unicode_service.normalize_text(mixed_case_text)
    
        # Assert
&gt;       assert result['normalized'].islower()
E       AssertionError: assert False
E        +  where False = &lt;built-in method islower of str object at 0x3fecb42f0&gt;()
E        +    where &lt;built-in method islower of str object at 0x3fecb42f0&gt; = 'MiXeD CaSe TeXt'.islower

tests/unit/test_unicode_service.py:265: AssertionError</failure></testcase><testcase classname="tests.unit.test_unicode_service.TestUnicodeService" name="test_german_umlauts_handling" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestTokenTrace" name="test_token_trace_creation" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestTokenTrace" name="test_token_trace_with_morphology" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestTokenTrace" name="test_token_trace_serialization" time="0.002" /><testcase classname="tests.unit.test_unified_contracts.TestNormalizationResult" name="test_normalization_result_basic" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestNormalizationResult" name="test_normalization_result_with_metadata" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestNormalizationResult" name="test_normalization_result_serialization" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestSignalsContracts" name="test_signals_person" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestSignalsContracts" name="test_signals_organization" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestSignalsContracts" name="test_signals_result" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestSmartFilterResult" name="test_smart_filter_result_basic" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestSmartFilterResult" name="test_smart_filter_classifications" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestUnifiedProcessingResult" name="test_unified_result_complete" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestUnifiedProcessingResult" name="test_unified_result_serialization" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestUnifiedProcessingResult" name="test_unified_result_backward_compatibility" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestProcessingContext" name="test_processing_context_basic" time="0.000" /><testcase classname="tests.unit.test_unified_contracts.TestContractCompatibility" name="test_contract_chain_compatibility" time="0.000" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_complete_pipeline" time="0.005"><failure message="NameError: name 'UnifiedUnifiedProcessingResult' is not defined">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b954f50&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4fd0b1230&gt;
mock_services = {'embeddings_service': &lt;Mock id='22275849392'&gt;, 'language_service': &lt;Mock id='17114115312'&gt;, 'normalization_service': &lt;Mock id='17114116992'&gt;, 'signals_service': &lt;Mock id='17114117664'&gt;, ...}

    async def test_complete_pipeline(self, orchestrator, mock_services):
        """Test complete 9-layer pipeline execution"""
    
        result = await orchestrator.process(
            text="Test input Іван Петров",
            remove_stop_words=True,
            preserve_names=True,
            enable_advanced_features=True,
            generate_variants=True,
            generate_embeddings=True
        )
    
        # Verify result structure
&gt;       assert isinstance(result, UnifiedUnifiedProcessingResult)
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       NameError: name 'UnifiedUnifiedProcessingResult' is not defined

tests/unit/test_unified_orchestrator.py:137: NameError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_normalization_flags_passed_correctly" time="0.002"><failure message="TypeError: 'NoneType' object is not subscriptable">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b954cd0&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56d8641f0&gt;
mock_services = {'embeddings_service': &lt;Mock id='17152625360'&gt;, 'language_service': &lt;Mock id='17152633760'&gt;, 'normalization_service': &lt;Mock id='17152635776'&gt;, 'signals_service': &lt;Mock id='17152636784'&gt;, ...}

    async def test_normalization_flags_passed_correctly(self, orchestrator, mock_services):
        """Test that normalization flags are passed correctly to the service"""
    
        await orchestrator.process(
            text="Test",
            remove_stop_words=False,
            preserve_names=False,
            enable_advanced_features=False
        )
    
        # Verify normalization service received correct flags
        call_args = mock_services["normalization_service"].normalize_async.call_args
&gt;       assert call_args[1]["remove_stop_words"] is False
               ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/unit/test_unified_orchestrator.py:171: TypeError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_smart_filter_skip_behavior" time="0.002" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_optional_services_disabled" time="0.003"><failure message="assert False is True&#10; +  where False = UnifiedProcessingResult(original_text='Test', language=&lt;Mock name='mock.detect_language_config_driven().language' id='...None, processing_time=0.0004811286926269531, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).success">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b8a1940&gt;
mock_services = {'embeddings_service': &lt;Mock id='20545357536'&gt;, 'language_service': &lt;Mock id='17152866160'&gt;, 'normalization_service': &lt;Mock id='20545355856'&gt;, 'signals_service': &lt;Mock id='20545368624'&gt;, ...}

    async def test_optional_services_disabled(self, mock_services):
        """Test orchestrator with optional services disabled"""
    
        orchestrator = UnifiedOrchestrator(
            validation_service=mock_services["validation_service"],
            language_service=mock_services["language_service"],
            unicode_service=mock_services["unicode_service"],
            normalization_service=mock_services["normalization_service"],
            signals_service=mock_services["signals_service"],
            # No optional services
            enable_smart_filter=False,
            enable_variants=False,
            enable_embeddings=False
        )
    
        result = await orchestrator.process(text="Test")
    
        # Core processing should work
&gt;       assert result.success is True
E       assert False is True
E        +  where False = UnifiedProcessingResult(original_text='Test', language=&lt;Mock name='mock.detect_language_config_driven().language' id='...None, processing_time=0.0004811286926269531, success=False, errors=["object Mock can't be used in 'await' expression"]).success

tests/unit/test_unified_orchestrator.py:220: AssertionError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_error_handling" time="0.003"><failure message="assert 'Normalization failed' in '[&quot;object Mock can\'t be used in \'await\' expression&quot;]'&#10; +  where '[&quot;object Mock can\'t be used in \'await\' expression&quot;]' = str([&quot;object Mock can't be used in 'await' expression&quot;])&#10; +    where [&quot;object Mock can't be used in 'await' expression&quot;] = UnifiedProcessingResult(original_text='Test', language='unknown', language_confidence=0.0, normalized_text='', tokens=...None, processing_time=8.606910705566406e-05, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).errors">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b9530b0&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56d8654a0&gt;
mock_services = {'embeddings_service': &lt;Mock id='20545365936'&gt;, 'language_service': &lt;Mock id='17152859104'&gt;, 'normalization_service': &lt;Mock id='17152624352'&gt;, 'signals_service': &lt;Mock id='20545369632'&gt;, ...}

    async def test_error_handling(self, orchestrator, mock_services):
        """Test error handling in the pipeline"""
    
        # Make normalization service fail
        mock_services["normalization_service"].normalize_async = AsyncMock(
            side_effect=Exception("Normalization failed")
        )
    
        result = await orchestrator.process(text="Test")
    
        # Should handle error gracefully
        assert result.success is False
        assert len(result.errors) &gt; 0
&gt;       assert "Normalization failed" in str(result.errors)
E       assert 'Normalization failed' in '["object Mock can\'t be used in \'await\' expression"]'
E        +  where '["object Mock can\'t be used in \'await\' expression"]' = str(["object Mock can't be used in 'await' expression"])
E        +    where ["object Mock can't be used in 'await' expression"] = UnifiedProcessingResult(original_text='Test', language='unknown', language_confidence=0.0, normalized_text='', tokens=...None, processing_time=8.606910705566406e-05, success=False, errors=["object Mock can't be used in 'await' expression"]).errors

tests/unit/test_unified_orchestrator.py:244: AssertionError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_performance_warning" time="0.003"><failure message="assert False is True&#10; +  where False = UnifiedProcessingResult(original_text='Test', language='unknown', language_confidence=0.0, normalized_text='', tokens=...None, processing_time=8.916854858398438e-05, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).success">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b8b1480&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x56e2e5160&gt;
mock_services = {'embeddings_service': &lt;Mock id='6102462352'&gt;, 'language_service': &lt;Mock id='20545366608'&gt;, 'normalization_service': &lt;Mock id='20545362240'&gt;, 'signals_service': &lt;Mock id='20545358880'&gt;, ...}

    async def test_performance_warning(self, orchestrator, mock_services):
        """Test performance warning for slow processing"""
    
        # Make normalization artificially slow
        import asyncio
        async def slow_normalize(*args, **kwargs):
            await asyncio.sleep(0.15)  # 150ms - above 100ms threshold
            return NormalizationResult(
                normalized="test",
                tokens=["test"],
                trace=[],
                success=True
            )
    
        mock_services["normalization_service"].normalize_async = slow_normalize
    
        result = await orchestrator.process(text="Test")
    
        # Should complete but be slow
&gt;       assert result.success is True
E       assert False is True
E        +  where False = UnifiedProcessingResult(original_text='Test', language='unknown', language_confidence=0.0, normalized_text='', tokens=...None, processing_time=8.916854858398438e-05, success=False, errors=["object Mock can't be used in 'await' expression"]).success

tests/unit/test_unified_orchestrator.py:265: AssertionError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_backward_compatibility_methods" time="0.003" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_signals_integration" time="0.003"><failure message="assert None is not None">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b8cc850&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x3fcb79710&gt;
mock_services = {'embeddings_service': &lt;Mock id='17152864816'&gt;, 'language_service': &lt;Mock id='17152855072'&gt;, 'normalization_service': &lt;Mock id='17152857088'&gt;, 'signals_service': &lt;Mock id='17152862464'&gt;, ...}

    async def test_signals_integration(self, orchestrator, mock_services):
        """Test signals service integration with normalization results"""
    
        result = await orchestrator.process(text="Test")
    
        # Verify signals service received normalization result
        call_args = mock_services["signals_service"].extract_signals.call_args
&gt;       assert call_args is not None  # Service was called
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert None is not None

tests/unit/test_unified_orchestrator.py:300: AssertionError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_trace_preservation" time="0.002"><failure message="assert 0 == 2&#10; +  where 0 = len([])&#10; +    where [] = UnifiedProcessingResult(original_text='Test', language='unknown', language_confidence=0.0, normalized_text='', tokens=...None, processing_time=7.891654968261719e-05, success=False, errors=[&quot;object Mock can't be used in 'await' expression&quot;]).trace">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b8ccd50&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x3fcb7ad00&gt;
mock_services = {'embeddings_service': &lt;Mock id='20545363920'&gt;, 'language_service': &lt;Mock id='20545356192'&gt;, 'normalization_service': &lt;Mock id='20545360560'&gt;, 'signals_service': &lt;Mock id='20545363584'&gt;, ...}

    async def test_trace_preservation(self, orchestrator, mock_services):
        """Test that token traces are preserved through the pipeline"""
    
        result = await orchestrator.process(text="Test")
    
        # Verify traces are preserved
&gt;       assert len(result.trace) == 2
E       assert 0 == 2
E        +  where 0 = len([])
E        +    where [] = UnifiedProcessingResult(original_text='Test', language='unknown', language_confidence=0.0, normalized_text='', tokens=...None, processing_time=7.891654968261719e-05, success=False, errors=["object Mock can't be used in 'await' expression"]).trace

tests/unit/test_unified_orchestrator.py:311: AssertionError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_language_hint" time="0.002"><failure message="TypeError: 'NoneType' object is not subscriptable">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b8b99a0&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4d7dea000&gt;
mock_services = {'embeddings_service': &lt;Mock id='17152637456'&gt;, 'language_service': &lt;Mock id='17152624016'&gt;, 'normalization_service': &lt;Mock id='17152633088'&gt;, 'signals_service': &lt;Mock id='17152624688'&gt;, ...}

    async def test_language_hint(self, orchestrator, mock_services):
        """Test language hint override"""
    
        await orchestrator.process(
            text="Test",
            language_hint="en"
        )
    
        # Should use hint instead of detection
        call_args = mock_services["normalization_service"].normalize_async.call_args
&gt;       assert call_args[1]["language"] == "en"
               ^^^^^^^^^^^^
E       TypeError: 'NoneType' object is not subscriptable

tests/unit/test_unified_orchestrator.py:327: TypeError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator" name="test_result_serialization" time="0.002"><failure message="AssertionError: assert '' == 'Іван Петров'&#10;  &#10;  - Іван Петров">self = &lt;tests.unit.test_unified_orchestrator.TestUnifiedOrchestrator object at 0x16b8b98b0&gt;
orchestrator = &lt;ai_service.core.unified_orchestrator.UnifiedOrchestrator object at 0x4d7debee0&gt;
mock_services = {'embeddings_service': &lt;Mock id='17114105568'&gt;, 'language_service': &lt;Mock id='20810430320'&gt;, 'normalization_service': &lt;Mock id='20540831936'&gt;, 'signals_service': &lt;Mock id='17114118000'&gt;, ...}

    async def test_result_serialization(self, orchestrator, mock_services):
        """Test that result can be serialized to dict"""
    
        result = await orchestrator.process(text="Test")
    
        data = result.to_dict()
    
        assert isinstance(data, dict)
        assert data["original_text"] == "Test"
&gt;       assert data["normalized_text"] == "Іван Петров"
E       AssertionError: assert '' == 'Іван Петров'
E         
E         - Іван Петров

tests/unit/test_unified_orchestrator.py:338: AssertionError</failure></testcase><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_valid_services" time="0.001" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_none_validation_service" time="0.002" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_none_language_service" time="0.002" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_none_unicode_service" time="0.001" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_none_normalization_service" time="0.002" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_none_signals_service" time="0.002" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorConstructor" name="test_constructor_with_optional_services_none" time="0.001" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorEdgeCases" name="test_empty_input" time="0.002" /><testcase classname="tests.unit.test_unified_orchestrator.TestUnifiedOrchestratorEdgeCases" name="test_service_initialization_failure" time="0.002" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_transliteration_variants_grigoriy" time="0.034" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_compound_surname_processing" time="0.037" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_basic_transliteration_functionality" time="0.044" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_multiple_transliteration_standards" time="0.033" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_phonetic_variants_generation" time="0.052" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_visual_similarities_generation" time="0.062" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_typo_variants_generation" time="0.036" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_comprehensive_variants_generation" time="0.035" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_empty_text_handling" time="0.032" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_none_text_handling" time="0.034" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_max_variants_limit" time="0.038" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_language_specific_processing" time="0.028" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_find_best_matches_functionality" time="0.033" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_similarity_calculation" time="0.025" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_keyboard_layout_variants" time="0.031" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_morphological_variants_integration" time="0.028" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_morphological_variants_mocked" time="0.031" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_processing_statistics" time="0.024" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_duplicate_removal" time="0.028" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_case_preservation_and_normalization" time="0.044" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_special_characters_handling" time="0.027" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_performance_with_long_names" time="0.031" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_error_handling_in_transliteration" time="0.030" /><testcase classname="tests.unit.test_variant_generation_service.TestVariantGenerationService" name="test_variant_scores_match_config" time="0.057" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_remove_stop_words_false" time="0.072" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_remove_stop_words_true" time="0.061" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_preserve_names_false" time="0.052" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_preserve_names_true" time="0.055" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_enable_advanced_features_false_slavic" time="0.057" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_enable_advanced_features_true_slavic" time="0.092" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_enable_advanced_features_false_english" time="0.048" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_enable_advanced_features_true_english" time="0.055" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_initial_cleanup_still_works_with_flags" time="0.049" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_all_flags_false" time="0.053" /><testcase classname="tests.unit.text_processing.test_flags_behavior.TestFlagsBehavior" name="test_all_flags_true" time="0.061" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_ukrainian_priority_detection" time="0.001" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_logic_ambiguous_text" time="0.011" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_empty_text_handling" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_whitespace_only_text" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_quick_patterns_english" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_quick_patterns_russian" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_quick_patterns_ukrainian" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_langdetect_fallback" time="0.004" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_langdetect_exception_handling" time="0.007" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_cyrillic_ukrainian_specific" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_cyrillic_russian_specific" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_cyrillic_patterns" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_fallback_latin_only" time="0.001" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_batch_detection" time="0.028" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_detection_statistics" time="0.039" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_reset_statistics" time="0.007" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_supported_languages" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_is_language_supported" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_add_language_mapping" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_add_invalid_language_mapping" time="0.000" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_confidence_scores_limit" time="10.195" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_language_mapping_coverage" time="0.002" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_no_fallback_option" time="0.006" /><testcase classname="tests.unit.text_processing.test_language_detection_service.TestLanguageDetectionService" name="test_original_detected_language_preservation" time="0.008" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u041e\u043f\u043b\u0430\u0442\u0430 \u0437\u0430 \u043f\u043e\u0441\u043b\u0443\u0433\u0438, \u043f\u043b\u0430\u0442\u043d\u0438\u043a \u041f\u0435\u0442\u0440\u0438\u043a \u041f.-\u041f\u0435\u0442\u0440\u043e \u041f.]" time="0.158" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0414\u043b\u044f \u041f\u0435\u0442\u0440\u0443\u0441\u044f \u0406\u0432\u0430\u043d\u043e\u0432\u0430, \u0437\u0430 \u0440\u0435\u043c\u043e\u043d\u0442-\u041f\u0435\u0442\u0440\u043e \u0406\u0432\u0430\u043d\u043e\u0432]" time="0.002" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u041f\u0435\u0440\u0435\u043a\u0430\u0437 \u0432\u0456\u0434 \u0412\u043e\u0432\u0447\u0438\u043a\u0430 \u0417\u0435\u043b\u0435\u043d\u0441\u044c\u043a\u043e\u0433\u043e \u0412. \u041e.-\u0412\u043e\u043b\u043e\u0434\u0438\u043c\u0438\u0440 \u0417\u0435\u043b\u0435\u043d\u0441\u044c\u043a\u0438\u0439 \u0412. \u041e.]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u041f\u043e\u0434\u0430\u0440\u0443\u043d\u043e\u043a \u0434\u043b\u044f \u0414\u0430\u0448\u0435\u043d\u044c\u043a\u0438 \u041a\u0432\u0456\u0442\u043a\u043e\u0432\u043e\u0457-\u0414\u0430\u0440\u0456\u044f \u041a\u0432\u0456\u0442\u043a\u043e\u0432\u0430]" time="0.002" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0412\u0456\u0434 \u0421\u0430\u0448\u043a\u0430 \u041f\u043e\u043b\u043e\u0436\u0438\u043d\u0441\u044c\u043a\u043e\u0433\u043e \u0437\u0430 \u043a\u0432\u0438\u0442\u043a\u0438-\u041e\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u041f\u043e\u043b\u043e\u0436\u0438\u043d\u0441\u044c\u043a\u0438\u0439]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0414\u043b\u044f \u0416\u0435\u043d\u0456 \u0413\u0430\u043b\u0438\u0447\u0430 \u0437 \u0433\u0440\u0443\u043f\u0438 O.Torvald-\u0404\u0432\u0433\u0435\u043d \u0413\u0430\u043b\u0438\u0447]" time="0.003"><failure message="AssertionError: Expected 'Євген Галич', but got 'Євген Галич З.'&#10;assert 'Євген Галич З.' == 'Євген Галич'&#10;  &#10;  - Євген Галич&#10;  + Євген Галич З.&#10;  ?            +++">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Для Жені Галича з групи O.Torvald', expected_name = 'Євген Галич'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Євген Галич З.', tokens=['Євген', 'Галич', 'З.'], trace=[TokenTrace(token='Жені', role...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Євген Галич'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Євген Галич', but got 'Євген Галич З.'
E       assert 'Євген Галич З.' == 'Євген Галич'
E         
E         - Євген Галич
E         + Євген Галич З.
E         ?            +++

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0414\u044f\u043a\u0443\u0454\u043c\u043e \u0421\u0435\u0440\u0433\u0456\u0454\u0432\u0456 \u0416\u0430\u0434\u0430\u043d\u0443 \u0437\u0430 \u0442\u0432\u043e\u0440\u0447\u0456\u0441\u0442\u044c-\u0421\u0435\u0440\u0433\u0456\u0439 \u0416\u0430\u0434\u0430\u043d]" time="0.004" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0417\u0443\u0441\u0442\u0440\u0456\u0447 \u0437 \u041b\u0456\u043d\u043e\u044e \u041a\u043e\u0441\u0442\u0435\u043d\u043a\u043e-\u041b\u0456\u043d\u0430 \u041a\u043e\u0441\u0442\u0435\u043d\u043a\u043e]" time="0.002"><failure message="AssertionError: Expected 'Ліна Костенко', but got 'З. Ліна Костенко'&#10;assert 'З. Ліна Костенко' == 'Ліна Костенко'&#10;  &#10;  - Ліна Костенко&#10;  + З. Ліна Костенко&#10;  ? +++">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Зустріч з Ліною Костенко', expected_name = 'Ліна Костенко'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='З. Ліна Костенко', tokens=['З.', 'Ліна', 'Костенко'], trace=[TokenTrace(token='з', rol...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Ліна Костенко'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Ліна Костенко', but got 'З. Ліна Костенко'
E       assert 'З. Ліна Костенко' == 'Ліна Костенко'
E         
E         - Ліна Костенко
E         + З. Ліна Костенко
E         ? +++

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u041f\u043e\u0434\u0430\u0440\u0443\u043d\u043e\u043a \u0434\u043b\u044f \u041e\u043a\u0441\u0430\u043d\u0438 \u0417\u0430\u0431\u0443\u0436\u043a\u043e-\u041e\u043a\u0441\u0430\u043d\u0430 \u0417\u0430\u0431\u0443\u0436\u043a\u043e]" time="0.003" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0420\u043e\u0437\u043c\u043e\u0432\u043b\u044f\u0432 \u0437 \u0412\u0430\u043b\u0435\u0440\u0456\u0454\u043c \u0417\u0430\u043b\u0443\u0436\u043d\u0438\u043c-\u0412\u0430\u043b\u0435\u0440\u0456\u0439 \u0417\u0430\u043b\u0443\u0436\u043d\u0438\u0439]" time="0.003"><failure message="AssertionError: Expected 'Валерій Залужний', but got 'З. Валерій Залужний'&#10;assert 'З. Валерій Залужний' == 'Валерій Залужний'&#10;  &#10;  - Валерій Залужний&#10;  + З. Валерій Залужний&#10;  ? +++">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Розмовляв з Валерієм Залужним', expected_name = 'Валерій Залужний'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='З. Валерій Залужний', tokens=['З.', 'Валерій', 'Залужний'], trace=[TokenTrace(token='з...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Валерій Залужний'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Валерій Залужний', but got 'З. Валерій Залужний'
E       assert 'З. Валерій Залужний' == 'Валерій Залужний'
E         
E         - Валерій Залужний
E         + З. Валерій Залужний
E         ? +++

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u041f\u043b\u0442\u0456\u0436 \u0432\u0456\u0434 \u0412'\u044f\u0447\u0435\u0441\u043b\u0430\u0432\u0430 \u0432\u0430\u043a\u0430\u0440\u0447\u0443\u043a\u0430 (\u043e\u043a\u0435\u0430\u043d \u0435\u043b\u044c\u0437\u0438)-\u0412'\u044f\u0447\u0435\u0441\u043b\u0430\u0432 \u0412\u0430\u043a\u0430\u0440\u0447\u0443\u043a]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u041f\u0435\u0440\u0435\u043a\u0430\u0437 \u041e\u041b\u0415\u0413\u0423 \u0421\u041a\u0420\u0418\u041f\u0426\u0406-\u041e\u043b\u0435\u0433 \u0421\u043a\u0440\u0438\u043f\u043a\u0430]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_ukrainian_full_normalization[\u0414\u043b\u044f \u0406\u0432\u0430\u043d\u043e\u0432\u0430-\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u0430 \u0421.\u0412.-\u0406\u0432\u0430\u043d\u043e\u0432-\u041f\u0435\u0442\u0440\u0435\u043d\u043a\u043e \u0421.\u0412.]" time="0.001"><failure message="AssertionError: Expected 'Іванов-Петренко С.В.', but got 'Іванов-Петренко С. В.'&#10;assert 'Іванов-Петренко С. В.' == 'Іванов-Петренко С.В.'&#10;  &#10;  - Іванов-Петренко С.В.&#10;  + Іванов-Петренко С. В.&#10;  ?                   +">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Для Іванова-Петренка С.В.', expected_name = 'Іванов-Петренко С.В.'

    @pytest.mark.parametrize("input_text, expected_name", ukrainian_test_cases)
    def test_ukrainian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию украинских имен."""
        result = normalization_service.normalize(input_text, language="uk")
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Іванов-Петренко С. В.', tokens=['Іванов-Петренко', 'С.', 'В.'], trace=[TokenTrace(toke...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Іванов-Петренко С.В.'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Іванов-Петренко С.В.', but got 'Іванов-Петренко С. В.'
E       assert 'Іванов-Петренко С. В.' == 'Іванов-Петренко С.В.'
E         
E         - Іванов-Петренко С.В.
E         + Іванов-Петренко С. В.
E         ?                   +

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u043e\u0442 \u0421\u0430\u0448\u0438 \u041f\u0443\u0448\u043a\u0438\u043d\u0430 \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447\u0430-\u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 \u041f\u0443\u0448\u043a\u0438\u043d \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440\u043e\u0432\u0438\u0447]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u041e\u043f\u043b\u0430\u0442\u0430 \u0434\u043b\u044f \u0412\u043e\u043b\u043e\u0434\u0438 \u0412\u044b\u0441\u043e\u0446\u043a\u043e\u0433\u043e-\u0412\u043b\u0430\u0434\u0438\u043c\u0438\u0440 \u0412\u044b\u0441\u043e\u0446\u043a\u0438\u0439]" time="0.097" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u041f\u043b\u0430\u0442\u0451\u0436 \u043e\u0442 \u0414\u0438\u043c\u044b \u041c\u0435\u0434\u0432\u0435\u0434\u0435\u0432\u0430-\u0414\u043c\u0438\u0442\u0440\u0438\u0439 \u041c\u0435\u0434\u0432\u0435\u0434\u0435\u0432]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u0414\u043b\u044f \u0410\u043b\u043b\u044b \u0411\u043e\u0440\u0438\u0441\u043e\u0432\u043d\u044b \u041f\u0443\u0433\u0430\u0447\u0435\u0432\u043e\u0439-\u0410\u043b\u043b\u0430 \u0411\u043e\u0440\u0438\u0441\u043e\u0432\u043d\u0430 \u041f\u0443\u0433\u0430\u0447\u0435\u0432\u0430]" time="0.002"><failure message="AssertionError: Expected 'Алла Борисовна Пугачева', but got 'Аллы Борисовн Пугачев'&#10;assert 'Аллы Борисовн Пугачев' == 'Алла Борисовна Пугачева'&#10;  &#10;  - Алла Борисовна Пугачева&#10;  ?    ^         -        -&#10;  + Аллы Борисовн Пугачев&#10;  ?    ^">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Для Аллы Борисовны Пугачевой'
expected_name = 'Алла Борисовна Пугачева'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
    
        # Debug output for failing cases
        if "Высоцкого" in input_text:
            print(f"\nDEBUG - Input: '{input_text}'")
            print(f"DEBUG - Expected: '{expected_name}'")
            print(f"DEBUG - Actual: '{result.normalized}'")
    
            # Force create a fresh service to bypass any caching issues
            from ai_service.layers.normalization.normalization_service import NormalizationService
            fresh_service = NormalizationService()
    
            # Test with fresh service
            fresh_result = fresh_service.normalize(input_text, language="ru")
            print(f"DEBUG - Fresh service result: '{fresh_result.normalized}'")
    
            # Test morphology with fresh service
            fresh_morph_test = fresh_service._morph_nominal('Высоцкого', 'ru')
            print(f"DEBUG - Fresh _morph_nominal('Высоцкого', 'ru') = '{fresh_morph_test}'")
    
            fresh_ru_morph = fresh_service._get_morph('ru')
            if fresh_ru_morph:
                print(f"DEBUG - Fresh ru_morph available: {fresh_ru_morph.morph_analyzer is not None}")
                if fresh_ru_morph.morph_analyzer:
                    print(f"DEBUG - Fresh ru_morph type: {type(fresh_ru_morph.morph_analyzer)}")
                else:
                    # Test direct pymorphy3 initialization in test environment
                    print("DEBUG - Testing direct pymorphy3 in test env:")
                    import sys
                    print(f"DEBUG - Python executable: {sys.executable}")
                    print(f"DEBUG - Python path length: {len(sys.path)}")
                    try:
                        import pymorphy3
                        test_analyzer = pymorphy3.MorphAnalyzer(lang="ru")
                        test_parses = test_analyzer.parse('Высоцкого')
                        print(f"DEBUG - Direct pymorphy3 works: {len(test_parses)} parses")
                        print(f"DEBUG - Direct result: {test_parses[0].normal_form if test_parses else 'No parses'}")
                    except Exception as e:
                        print(f"DEBUG - Direct pymorphy3 error: {e}")
                        print(f"DEBUG - Type of error: {type(e)}")
                        import traceback
                        print(f"DEBUG - Traceback: {traceback.format_exc()}")
            else:
                print("DEBUG - Fresh ru_morph is None!")
    
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Аллы Борисовн Пугачев', tokens=['Аллы', 'Борисовн', 'Пугачев'], trace=[TokenTrace(toke...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Алла Борисовна Пугачева'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Алла Борисовна Пугачева', but got 'Аллы Борисовн Пугачев'
E       assert 'Аллы Борисовн Пугачев' == 'Алла Борисовна Пугачева'
E         
E         - Алла Борисовна Пугачева
E         ?    ^         -        -
E         + Аллы Борисовн Пугачев
E         ?    ^

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u0411\u043b\u0430\u0433\u043e\u0434\u0430\u0440\u043d\u043e\u0441\u0442\u044c \u041f\u0435\u0442\u0440\u0443 \u0427\u0430\u0439\u043a\u043e\u0432\u0441\u043a\u043e\u043c\u0443-\u041f\u0435\u0442\u0440 \u0427\u0430\u0439\u043a\u043e\u0432\u0441\u043a\u0438\u0439]" time="0.002"><failure message="AssertionError: Expected 'Петр Чайковский', but got 'Петр Чайковском'&#10;assert 'Петр Чайковском' == 'Петр Чайковский'&#10;  &#10;  - Петр Чайковский&#10;  ?              ^^&#10;  + Петр Чайковском&#10;  ?              ^^">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Благодарность Петру Чайковскому'
expected_name = 'Петр Чайковский'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
    
        # Debug output for failing cases
        if "Высоцкого" in input_text:
            print(f"\nDEBUG - Input: '{input_text}'")
            print(f"DEBUG - Expected: '{expected_name}'")
            print(f"DEBUG - Actual: '{result.normalized}'")
    
            # Force create a fresh service to bypass any caching issues
            from ai_service.layers.normalization.normalization_service import NormalizationService
            fresh_service = NormalizationService()
    
            # Test with fresh service
            fresh_result = fresh_service.normalize(input_text, language="ru")
            print(f"DEBUG - Fresh service result: '{fresh_result.normalized}'")
    
            # Test morphology with fresh service
            fresh_morph_test = fresh_service._morph_nominal('Высоцкого', 'ru')
            print(f"DEBUG - Fresh _morph_nominal('Высоцкого', 'ru') = '{fresh_morph_test}'")
    
            fresh_ru_morph = fresh_service._get_morph('ru')
            if fresh_ru_morph:
                print(f"DEBUG - Fresh ru_morph available: {fresh_ru_morph.morph_analyzer is not None}")
                if fresh_ru_morph.morph_analyzer:
                    print(f"DEBUG - Fresh ru_morph type: {type(fresh_ru_morph.morph_analyzer)}")
                else:
                    # Test direct pymorphy3 initialization in test environment
                    print("DEBUG - Testing direct pymorphy3 in test env:")
                    import sys
                    print(f"DEBUG - Python executable: {sys.executable}")
                    print(f"DEBUG - Python path length: {len(sys.path)}")
                    try:
                        import pymorphy3
                        test_analyzer = pymorphy3.MorphAnalyzer(lang="ru")
                        test_parses = test_analyzer.parse('Высоцкого')
                        print(f"DEBUG - Direct pymorphy3 works: {len(test_parses)} parses")
                        print(f"DEBUG - Direct result: {test_parses[0].normal_form if test_parses else 'No parses'}")
                    except Exception as e:
                        print(f"DEBUG - Direct pymorphy3 error: {e}")
                        print(f"DEBUG - Type of error: {type(e)}")
                        import traceback
                        print(f"DEBUG - Traceback: {traceback.format_exc()}")
            else:
                print("DEBUG - Fresh ru_morph is None!")
    
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Петр Чайковском', tokens=['Петр', 'Чайковском'], trace=[TokenTrace(token='Петру', role...re_female': 0, 'score_male': 3, 'gap': 3}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Петр Чайковский'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Петр Чайковский', but got 'Петр Чайковском'
E       assert 'Петр Чайковском' == 'Петр Чайковский'
E         
E         - Петр Чайковский
E         ?              ^^
E         + Петр Чайковском
E         ?              ^^

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u0412\u0441\u0442\u0440\u0435\u0447\u0430 \u0441 \u0410\u043d\u043d\u043e\u0439 \u0410\u0445\u043c\u0430\u0442\u043e\u0432\u043e\u0439-\u0410\u043d\u043d\u0430 \u0410\u0445\u043c\u0430\u0442\u043e\u0432\u0430]" time="0.002"><failure message="AssertionError: Expected 'Анна Ахматова', but got 'С. Анна Ахматова'&#10;assert 'С. Анна Ахматова' == 'Анна Ахматова'&#10;  &#10;  - Анна Ахматова&#10;  + С. Анна Ахматова&#10;  ? +++">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Встреча с Анной Ахматовой', expected_name = 'Анна Ахматова'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
    
        # Debug output for failing cases
        if "Высоцкого" in input_text:
            print(f"\nDEBUG - Input: '{input_text}'")
            print(f"DEBUG - Expected: '{expected_name}'")
            print(f"DEBUG - Actual: '{result.normalized}'")
    
            # Force create a fresh service to bypass any caching issues
            from ai_service.layers.normalization.normalization_service import NormalizationService
            fresh_service = NormalizationService()
    
            # Test with fresh service
            fresh_result = fresh_service.normalize(input_text, language="ru")
            print(f"DEBUG - Fresh service result: '{fresh_result.normalized}'")
    
            # Test morphology with fresh service
            fresh_morph_test = fresh_service._morph_nominal('Высоцкого', 'ru')
            print(f"DEBUG - Fresh _morph_nominal('Высоцкого', 'ru') = '{fresh_morph_test}'")
    
            fresh_ru_morph = fresh_service._get_morph('ru')
            if fresh_ru_morph:
                print(f"DEBUG - Fresh ru_morph available: {fresh_ru_morph.morph_analyzer is not None}")
                if fresh_ru_morph.morph_analyzer:
                    print(f"DEBUG - Fresh ru_morph type: {type(fresh_ru_morph.morph_analyzer)}")
                else:
                    # Test direct pymorphy3 initialization in test environment
                    print("DEBUG - Testing direct pymorphy3 in test env:")
                    import sys
                    print(f"DEBUG - Python executable: {sys.executable}")
                    print(f"DEBUG - Python path length: {len(sys.path)}")
                    try:
                        import pymorphy3
                        test_analyzer = pymorphy3.MorphAnalyzer(lang="ru")
                        test_parses = test_analyzer.parse('Высоцкого')
                        print(f"DEBUG - Direct pymorphy3 works: {len(test_parses)} parses")
                        print(f"DEBUG - Direct result: {test_parses[0].normal_form if test_parses else 'No parses'}")
                    except Exception as e:
                        print(f"DEBUG - Direct pymorphy3 error: {e}")
                        print(f"DEBUG - Type of error: {type(e)}")
                        import traceback
                        print(f"DEBUG - Traceback: {traceback.format_exc()}")
            else:
                print("DEBUG - Fresh ru_morph is None!")
    
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='С. Анна Ахматова', tokens=['С.', 'Анна', 'Ахматова'], trace=[TokenTrace(token='с', rol...re_female': 5, 'score_male': 0, 'gap': 5}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Анна Ахматова'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Анна Ахматова', but got 'С. Анна Ахматова'
E       assert 'С. Анна Ахматова' == 'Анна Ахматова'
E         
E         - Анна Ахматова
E         + С. Анна Ахматова
E         ? +++

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u041f\u0435\u0440\u0435\u0432\u043e\u0434 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0418\u0432\u0430\u043d\u0443 \u0411\u0443\u043d\u0438\u043d\u0443-\u0418\u0432\u0430\u043d \u0411\u0443\u043d\u0438\u043d]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e \u0434\u043b\u044f \u0415\u0441\u0435\u043d\u0438\u043d\u0430 \u0421. \u0410.-\u0415\u0441\u0435\u043d\u0438\u043d \u0421. \u0410.]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_russian_full_normalization[\u0417\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043e\u0442 \u041b\u0435\u0440\u043c\u043e\u043d\u0442\u043e\u0432\u0430 \u041c.\u042e.-\u041b\u0435\u0440\u043c\u043e\u043d\u0442\u043e\u0432 \u041c.\u042e.]" time="0.001"><failure message="AssertionError: Expected 'Лермонтов М.Ю.', but got 'Лермонтов М. Ю.'&#10;assert 'Лермонтов М. Ю.' == 'Лермонтов М.Ю.'&#10;  &#10;  - Лермонтов М.Ю.&#10;  + Лермонтов М. Ю.&#10;  ?             +">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Зачисление от Лермонтова М.Ю.', expected_name = 'Лермонтов М.Ю.'

    @pytest.mark.parametrize("input_text, expected_name", russian_test_cases)
    def test_russian_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию русских имен."""
        result = normalization_service.normalize(input_text, language="ru")
    
        # Debug output for failing cases
        if "Высоцкого" in input_text:
            print(f"\nDEBUG - Input: '{input_text}'")
            print(f"DEBUG - Expected: '{expected_name}'")
            print(f"DEBUG - Actual: '{result.normalized}'")
    
            # Force create a fresh service to bypass any caching issues
            from ai_service.layers.normalization.normalization_service import NormalizationService
            fresh_service = NormalizationService()
    
            # Test with fresh service
            fresh_result = fresh_service.normalize(input_text, language="ru")
            print(f"DEBUG - Fresh service result: '{fresh_result.normalized}'")
    
            # Test morphology with fresh service
            fresh_morph_test = fresh_service._morph_nominal('Высоцкого', 'ru')
            print(f"DEBUG - Fresh _morph_nominal('Высоцкого', 'ru') = '{fresh_morph_test}'")
    
            fresh_ru_morph = fresh_service._get_morph('ru')
            if fresh_ru_morph:
                print(f"DEBUG - Fresh ru_morph available: {fresh_ru_morph.morph_analyzer is not None}")
                if fresh_ru_morph.morph_analyzer:
                    print(f"DEBUG - Fresh ru_morph type: {type(fresh_ru_morph.morph_analyzer)}")
                else:
                    # Test direct pymorphy3 initialization in test environment
                    print("DEBUG - Testing direct pymorphy3 in test env:")
                    import sys
                    print(f"DEBUG - Python executable: {sys.executable}")
                    print(f"DEBUG - Python path length: {len(sys.path)}")
                    try:
                        import pymorphy3
                        test_analyzer = pymorphy3.MorphAnalyzer(lang="ru")
                        test_parses = test_analyzer.parse('Высоцкого')
                        print(f"DEBUG - Direct pymorphy3 works: {len(test_parses)} parses")
                        print(f"DEBUG - Direct result: {test_parses[0].normal_form if test_parses else 'No parses'}")
                    except Exception as e:
                        print(f"DEBUG - Direct pymorphy3 error: {e}")
                        print(f"DEBUG - Type of error: {type(e)}")
                        import traceback
                        print(f"DEBUG - Traceback: {traceback.format_exc()}")
            else:
                print("DEBUG - Fresh ru_morph is None!")
    
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Лермонтов М. Ю.', tokens=['Лермонтов', 'М.', 'Ю.'], trace=[TokenTrace(token='Лермонтов...re_female': 0, 'score_male': 2, 'gap': 2}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Лермонтов М.Ю.'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Лермонтов М.Ю.', but got 'Лермонтов М. Ю.'
E       assert 'Лермонтов М. Ю.' == 'Лермонтов М.Ю.'
E         
E         - Лермонтов М.Ю.
E         + Лермонтов М. Ю.
E         ?             +

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[Payment from John Fitzgerald Kennedy-John Fitzgerald Kennedy]" time="0.000" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[Transfer to Stephen E. King for services-Stephen E. King]" time="0.000" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[For Mr. Sherlock Holmes, Baker st. 221b-Sherlock Holmes]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[Refund to Ms. Joanna Rowling-Joanna Rowling]" time="0.000" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[From Bill Gates for charity-William Gates]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[For Liz Truss, former PM-Elizabeth Truss]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[Payment from Mike Johnson-Michael Johnson]" time="0.000" /><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[Sent to ELON MUSK for X corp-Elon Musk]" time="0.003"><failure message="AssertionError: Expected 'Elon Musk', but got 'Elon Musk X'&#10;assert 'Elon Musk X' == 'Elon Musk'&#10;  &#10;  - Elon Musk&#10;  + Elon Musk X&#10;  ?          ++">normalization_service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5befb97d0&gt;
input_text = 'Sent to ELON MUSK for X corp', expected_name = 'Elon Musk'

    @pytest.mark.parametrize("input_text, expected_name", english_test_cases)
    def test_english_full_normalization(normalization_service, input_text, expected_name):
        """Проверяет полную нормализацию английских имен."""
        result = normalization_service.normalize(input_text, language="en")
&gt;       assert_normalized_name(result, expected_name)

tests/unit/text_processing/test_normalization_logic.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = NormalizationResult(normalized='Elon Musk X', tokens=['Elon', 'Musk', 'X'], trace=[TokenTrace(token='ELON', role='give...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')
expected_name = 'Elon Musk'

    def assert_normalized_name(result: NormalizationResult, expected_name: str):
        """
        Asserts that the normalized result string equals the expected name.
        This is a strict assertion.
        """
&gt;       assert result.normalized == expected_name, f"Expected '{expected_name}', but got '{result.normalized}'"
E       AssertionError: Expected 'Elon Musk', but got 'Elon Musk X'
E       assert 'Elon Musk X' == 'Elon Musk'
E         
E         - Elon Musk
E         + Elon Musk X
E         ?          ++

tests/unit/text_processing/test_normalization_logic.py:18: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_logic" name="test_english_full_normalization[For BARACK H. OBAMA, invoice 123-Barack H. Obama]" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_result_fields.TestNormalizationResultFields" name="test_normalization_result_metadata_fields" time="0.088" /><testcase classname="tests.unit.text_processing.test_normalization_result_fields.TestNormalizationResultFields" name="test_normalization_result_tokens" time="0.079" /><testcase classname="tests.unit.text_processing.test_normalization_result_fields.TestNormalizationResultFields" name="test_normalization_result_extra_fields_allowed" time="0.096" /><testcase classname="tests.unit.text_processing.test_normalization_result_fields.TestNormalizationResultFields" name="test_normalization_result_basic_serialization" time="0.059"><failure message="TypeError: asdict() should be called on dataclass instances">self = &lt;tests.unit.text_processing.test_normalization_result_fields.TestNormalizationResultFields object at 0x16b8a3bb0&gt;
service = &lt;src.ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c3e92250&gt;

    def test_normalization_result_basic_serialization(self, service):
        """Test that NormalizationResult can be converted to dict."""
        text = "Переказ коштів на ім'я Петро Іванович Коваленко"
        result = service.normalize(text, language="uk")
    
        # Test conversion to dict using dataclasses.asdict
        import dataclasses
&gt;       result_dict = dataclasses.asdict(result)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/text_processing/test_normalization_result_fields.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

obj = NormalizationResult(normalized='Петро Іванович Коваленко', tokens=['Петро', 'Іванович', 'Коваленко'], trace=[TokenTrac...re_female': 0, 'score_male': 6, 'gap': 6}}], person_gender=None, gender_confidence=None, organizations=[], org_core='')

    def asdict(obj, *, dict_factory=dict):
        """Return the fields of a dataclass instance as a new dictionary mapping
        field names to field values.
    
        Example usage::
    
          @dataclass
          class C:
              x: int
              y: int
    
          c = C(1, 2)
          assert asdict(c) == {'x': 1, 'y': 2}
    
        If given, 'dict_factory' will be used instead of built-in dict.
        The function applies recursively to field values that are
        dataclass instances. This will also look into built-in containers:
        tuples, lists, and dicts. Other objects are copied with 'copy.deepcopy()'.
        """
        if not _is_dataclass_instance(obj):
&gt;           raise TypeError("asdict() should be called on dataclass instances")
E           TypeError: asdict() should be called on dataclass instances

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/dataclasses.py:1358: TypeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_initialization" time="0.071" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_english_text" time="0.077" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_russian_text" time="0.056" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_ukrainian_text" time="0.054" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_fallback" time="0.065" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_auto_language_detection" time="0.093" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_person_names" time="0.053" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_russian_names" time="0.085" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_ukrainian_names" time="0.067" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_initials" time="4.128" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_empty_text" time="0.060" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_whitespace_only" time="0.065" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_special_characters" time="0.075" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_numbers" time="0.104" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_sync_method" time="0.083" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_async_method" time="0.075" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_flags" time="0.059" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_error_handling" time="0.062" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_result_structure" time="0.054" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_with_complex_text" time="0.069" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_russian_complex_text" time="0.072"><failure message="AssertionError: assert 'Анна' in 'Иван Петров Анны Смирнов'&#10; +  where 'Иван Петров Анны Смирнов' = NormalizationResult(normalized='Иван Петров Анны Смирнов', tokens=['Иван', 'Петров', 'Анны', 'Смирнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service.TestNormalizationService object at 0x16b9f4a70&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x56edbe650&gt;

    def test_normalize_russian_complex_text(self, service):
        """Test normalization with complex Russian text"""
        text = "Перевод средств на имя Ивана Петрова от Анны Смирновой"
        result = service.normalize(text, language="ru")
    
        assert result.success
        assert "Иван" in result.normalized
        assert "Петров" in result.normalized
&gt;       assert "Анна" in result.normalized
E       AssertionError: assert 'Анна' in 'Иван Петров Анны Смирнов'
E        +  where 'Иван Петров Анны Смирнов' = NormalizationResult(normalized='Иван Петров Анны Смирнов', tokens=['Иван', 'Петров', 'Анны', 'Смирнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service.py:226: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationService" name="test_normalize_ukrainian_complex_text" time="0.074"><failure message="AssertionError: assert 'Анна' in 'Іван Петров Анни Смірнов'&#10; +  where 'Іван Петров Анни Смірнов' = NormalizationResult(normalized='Іван Петров Анни Смірнов', tokens=['Іван', 'Петров', 'Анни', 'Смірнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service.TestNormalizationService object at 0x16ba15e50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c44a8a50&gt;

    def test_normalize_ukrainian_complex_text(self, service):
        """Test normalization with complex Ukrainian text"""
        text = "Переказ коштів на ім'я Івана Петрова від Анни Смірнової"
        result = service.normalize(text, language="uk")
    
        assert result.success
        assert "Іван" in result.normalized
        assert "Петров" in result.normalized
&gt;       assert "Анна" in result.normalized
E       AssertionError: assert 'Анна' in 'Іван Петров Анни Смірнов'
E        +  where 'Іван Петров Анни Смірнов' = NormalizationResult(normalized='Іван Петров Анни Смірнов', tokens=['Іван', 'Петров', 'Анни', 'Смірнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service.py:237: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationServiceConfiguration" name="test_service_has_required_attributes" time="0.067" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationServiceConfiguration" name="test_service_has_required_methods" time="0.080" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationServiceConfiguration" name="test_morph_analyzers_initialization" time="0.075" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationServiceConfiguration" name="test_name_dictionaries_initialization" time="0.059" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationServiceConfiguration" name="test_diminutive_maps_initialization" time="0.054" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationResult" name="test_normalization_result_creation" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_service.TestNormalizationResult" name="test_normalization_result_error_case" time="0.000" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_initialization" time="0.074" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_english_text" time="0.070"><failure message="AssertionError: assert 'Hello world' in 'Hello World'&#10; +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16b9574d0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16ba16bd0&gt;

    def test_normalize_english_text(self, service):
        """Test normalization of English text"""
        result = service.normalize("Hello world", language="en")
    
        assert result.success
&gt;       assert "Hello world" in result.normalized
E       AssertionError: assert 'Hello world' in 'Hello World'
E        +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:48: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_russian_text" time="0.063"><failure message="AssertionError: assert 'Привет' in ''&#10; +  where '' = NormalizationResult(normalized='', tokens=[], trace=[], errors=[], language='ru', confidence=1.0, original_length=10, ..._core=[], organizations_core=[], persons=[], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16ba00770&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c5e6d9d0&gt;

    def test_normalize_russian_text(self, service):
        """Test normalization of Russian text"""
        result = service.normalize("Привет мир", language="ru")
    
        assert result.success
&gt;       assert "Привет" in result.normalized
E       AssertionError: assert 'Привет' in ''
E        +  where '' = NormalizationResult(normalized='', tokens=[], trace=[], errors=[], language='ru', confidence=1.0, original_length=10, ..._core=[], organizations_core=[], persons=[], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:56: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_ukrainian_text" time="0.062" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_fallback" time="0.062"><failure message="AssertionError: assert 'Hello world' in 'Hello World'&#10; +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16ba0cdd0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4fe4e1dd0&gt;

    def test_normalize_with_fallback(self, service):
        """Test normalization with fallback behavior"""
        result = service.normalize("Hello world", language="en")
    
        assert result.success
&gt;       assert "Hello world" in result.normalized
E       AssertionError: assert 'Hello world' in 'Hello World'
E        +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:72: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_auto_language_detection" time="0.062"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for NormalizationResult&#10;language&#10;  Input should be a valid string [type=string_type, input_value=&lt;Mock name='LanguageDetec...guage' id='24612044880'&gt;, input_type=Mock]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/string_type">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16ba28380&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4fe4e1ed0&gt;

    def test_normalize_with_auto_language_detection(self, service):
        """Test normalization with automatic language detection"""
&gt;       result = service.normalize("Hello world", language="auto")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/text_processing/test_normalization_service_fixed.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4fe4e1ed0&gt;, 'Hello world')
kwargs = {'language': 'auto'}, start_time = 1757965758.751371
execution_time = 0.003823995590209961

    @functools.wraps(func)
    def wrapper(*args, **kwargs) -&gt; Any:
        start_time = time.time()
        try:
&gt;           result = func(*args, **kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^

src/ai_service/utils/performance.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4fe4e1ed0&gt;, 'Hello world')
kwargs = {'language': 'auto'}

    @functools.wraps(func)
    def wrapper(*args, **kwargs) -&gt; Any:
        # Basic memory monitoring without psutil dependency
        # Just track large input sizes for now
        try:
            # Check if first argument is a string and monitor its size
            if args and isinstance(args[0], str) and len(args[0]) &gt; 1000:
                logger.info(f"Processing large input: {len(args[0])} characters")
    
&gt;           return func(*args, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^

src/ai_service/utils/performance.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4fe4e1ed0&gt;
text = 'Hello world', language = 'auto', remove_stop_words = True
preserve_names = True, enable_advanced_features = True

    @monitor_performance("normalize")
    @monitor_memory_usage
    def normalize(
        self,
        text: str,
        language: str = "auto",
        remove_stop_words: bool = True,
        preserve_names: bool = True,
        enable_advanced_features: bool = True,
    ) -&gt; NormalizationResult:
        """
        Normalize name text using morphological pipeline
    
        Args:
            text: Input text containing person names
            language: Language code or 'auto' for detection
            remove_stop_words: If False, skip STOP_ALL filtering
            preserve_names: If False, be more aggressive with separators
            enable_advanced_features: If False, skip morphology and advanced features
    
        Returns:
            NormalizationResult with normalized text and trace
        """
&gt;       return self._normalize_sync(
            text, language, remove_stop_words, preserve_names, enable_advanced_features
        )

src/ai_service/layers/normalization/normalization_service.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4fe4e1ed0&gt;
text = 'Hello world'
language = &lt;Mock name='LanguageDetectionService().detect_language_config_driven().language' id='24612044880'&gt;
remove_stop_words = True, preserve_names = True, enable_advanced_features = True

    def _normalize_sync(
        self,
        text: str,
        language: str = "auto",
        remove_stop_words: bool = True,
        preserve_names: bool = True,
        enable_advanced_features: bool = True,
    ) -&gt; NormalizationResult:
        """
        Normalize name text using morphological pipeline
    
        Args:
            text: Input text containing person names
            language: Language code or 'auto' for detection
            remove_stop_words: If False, skip STOP_ALL filtering
            preserve_names: If False, be more aggressive with separators
            enable_advanced_features: If False, skip morphology and advanced features
    
        Returns:
            NormalizationResult with normalized text and trace
        """
        start_time = time.time()
        errors = []
    
        # Input validation
        if not isinstance(text, str):
            errors.append("Input must be a string")
            return self._create_error_result(text, errors, start_time)
    
        if len(text) &gt; 10000:  # Max length from config
            errors.append(f"Input too long: {len(text)} characters (max 10,000)")
            return self._create_error_result(text, errors, start_time)
    
        # Validate Unicode normalization
        try:
            # Test if string can be properly normalized
            unicodedata.normalize("NFC", text)
        except Exception as e:
            errors.append(f"Invalid Unicode input: {e}")
            return self._create_error_result(text, errors, start_time)
    
        try:
            # Language detection
            if language == "auto":
                from ...config import LANGUAGE_CONFIG
                lang_result = self.language_service.detect_language_config_driven(text, LANGUAGE_CONFIG)
                language = lang_result.language
                confidence = lang_result.confidence
            else:
                confidence = 1.0
    
            # Step 1: Strip noise and tokenize
            tokens = self._strip_noise_and_tokenize(
                text, language, remove_stop_words, preserve_names
            )
    
            # Step 2: Tag roles
            tagged_tokens = self._tag_roles(tokens, language)
            original_tagged_tokens = (
                tagged_tokens.copy()
            )  # Keep original for organization processing
    
            # Step 3: Normalize by role
            if language == "en":
                normalized_tokens, traces = self._normalize_english_tokens(
                    tagged_tokens, language, enable_advanced_features
                )
            elif language == "mixed":
                normalized_tokens, traces = self._normalize_mixed_tokens(
                    tagged_tokens, language, enable_advanced_features
                )
            else:
                normalized_tokens, traces = self._normalize_slavic_tokens(
                    tagged_tokens, language, enable_advanced_features
                )
    
            # Step 4: Separate personal and organization tokens
            person_tokens = []
            org_tokens = []
    
            for token in normalized_tokens:
                if token.startswith("__ORG__"):
                    org_tokens.append(token[7:])  # Remove "__ORG__" prefix
                else:
                    person_tokens.append(token)
    
            # Step 5: Reconstruct personal text with multiple persons detection
            normalized_text = self._reconstruct_text_with_multiple_persons(
                person_tokens, traces, language
            )
    
            # Step 6: Group organization tokens into phrases
            organizations = []
            if org_tokens:
                # Treat each org token as a separate organization
                for token in org_tokens:
                    if token:  # Skip empty tokens
                        organizations.append(token)
    
            processing_time = time.time() - start_time
    
            result = NormalizationResult(
                normalized=normalized_text,
                tokens=person_tokens,
                trace=traces,
                errors=errors,
                language=language,
                confidence=confidence,
                original_length=len(text),
                normalized_length=len(normalized_text),
                token_count=len(person_tokens),
                processing_time=processing_time,
                success=len(errors) == 0,
            )
    
            # Add organization fields
            result.organizations = organizations
            result.org_core = " ".join(organizations) if organizations else ""
            result.organizations_core = organizations  # For signals service
    
            # Group persons and add to result
            # Use original tagged tokens before normalization to preserve separators
            persons = self.group_persons_with_normalized_tokens(original_tagged_tokens, normalized_tokens, traces)
            result.persons = persons
    
            # Extract persons_core for signals service (list of token lists)
            persons_core = []
            if person_tokens:  # person_tokens is the list of normalized person tokens
                persons_core = [person_tokens]  # Wrap in list since it's one person
            result.persons_core = persons_core
    
            return result
    
        except Exception as e:
            self.logger.error(f"Normalization failed: {e}")
            errors.append(str(e))
    
            # Graceful degradation - return capitalized input
            fallback_text = self._graceful_fallback(text)
            processing_time = time.time() - start_time
    
&gt;           return NormalizationResult(
                normalized=fallback_text,
                tokens=[fallback_text] if fallback_text else [],
                trace=[],
                errors=errors,
                language=language,
                confidence=0.0,
                original_length=len(text),
                normalized_length=len(fallback_text),
                token_count=1 if fallback_text else 0,
                processing_time=processing_time,
                success=False,
            )
E           pydantic_core._pydantic_core.ValidationError: 1 validation error for NormalizationResult
E           language
E             Input should be a valid string [type=string_type, input_value=&lt;Mock name='LanguageDetec...guage' id='24612044880'&gt;, input_type=Mock]
E               For further information visit https://errors.pydantic.dev/2.11/v/string_type

src/ai_service/layers/normalization/normalization_service.py:568: ValidationError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_person_names" time="0.052" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_russian_names" time="0.069" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_ukrainian_names" time="0.049" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_initials" time="0.059" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_empty_text" time="0.096" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_whitespace_only" time="0.076" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_special_characters" time="0.060"><failure message="assert &quot;O'Connor&quot; in &quot;O'connor&quot;&#10; +  where &quot;O'connor&quot; = NormalizationResult(normalized=&quot;O'connor&quot;, tokens=[&quot;O'connor&quot;], trace=[TokenTrace(token=&quot;O'Connor&quot;, role='given', rule...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16ba12b30&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c4198950&gt;

    def test_normalize_with_special_characters(self, service):
        """Test normalization with special characters"""
        result = service.normalize("O'Connor", language="en")
    
        assert result.success
&gt;       assert "O'Connor" in result.normalized
E       assert "O'Connor" in "O'connor"
E        +  where "O'connor" = NormalizationResult(normalized="O'connor", tokens=["O'connor"], trace=[TokenTrace(token="O'Connor", role='given', rule...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:132: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_numbers" time="0.076" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_sync_method" time="0.088"><failure message="AssertionError: assert 'Hello world' in 'Hello World'&#10; +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16b93ee10&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c0ad0ed0&gt;

    def test_normalize_sync_method(self, service):
        """Test normalize_sync method"""
        result = service.normalize_sync("Hello world", language="en")
    
        assert result.success
&gt;       assert "Hello world" in result.normalized
E       AssertionError: assert 'Hello world' in 'Hello World'
E        +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:147: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_async_method" time="0.063"><failure message="AssertionError: assert 'Hello world' in 'Hello World'&#10; +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16b93eed0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c4a390d0&gt;

    def test_normalize_async_method(self, service):
        """Test normalize_async method"""
        import asyncio
    
        async def run_test():
            result = await service.normalize_async("Hello world", language="en")
            assert result.success
            assert "Hello world" in result.normalized
    
&gt;       asyncio.run(run_test())

tests/unit/text_processing/test_normalization_service_fixed.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

main = &lt;coroutine object TestNormalizationService.test_normalize_async_method.&lt;locals&gt;.run_test at 0x5c56a4dc0&gt;

    def run(main, *, debug=None, loop_factory=None):
        """Execute the coroutine and return the result.
    
        This function runs the passed coroutine, taking care of
        managing the asyncio event loop, finalizing asynchronous
        generators and closing the default executor.
    
        This function cannot be called when another asyncio event loop is
        running in the same thread.
    
        If debug is True, the event loop will be run in debug mode.
        If loop_factory is passed, it is used for new event loop creation.
    
        This function always creates a new event loop and closes it at the end.
        It should be used as a main entry point for asyncio programs, and should
        ideally only be called once.
    
        The executor is given a timeout duration of 5 minutes to shutdown.
        If the executor hasn't finished within that duration, a warning is
        emitted and the executor is closed.
    
        Example:
    
            async def main():
                await asyncio.sleep(1)
                print('hello')
    
            asyncio.run(main())
        """
        if events._get_running_loop() is not None:
            # fail fast with short traceback
            raise RuntimeError(
                "asyncio.run() cannot be called from a running event loop")
    
        with Runner(debug=debug, loop_factory=loop_factory) as runner:
&gt;           return runner.run(main)
                   ^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/runners.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;asyncio.runners.Runner object at 0x5c5642b50&gt;
coro = &lt;coroutine object TestNormalizationService.test_normalize_async_method.&lt;locals&gt;.run_test at 0x5c56a4dc0&gt;

    def run(self, coro, *, context=None):
        """Run a coroutine inside the embedded event loop."""
        if not coroutines.iscoroutine(coro):
            raise ValueError("a coroutine was expected, got {!r}".format(coro))
    
        if events._get_running_loop() is not None:
            # fail fast with short traceback
            raise RuntimeError(
                "Runner.run() cannot be called from a running event loop")
    
        self._lazy_init()
    
        if context is None:
            context = self._context
        task = self._loop.create_task(coro, context=context)
    
        if (threading.current_thread() is threading.main_thread()
            and signal.getsignal(signal.SIGINT) is signal.default_int_handler
        ):
            sigint_handler = functools.partial(self._on_sigint, main_task=task)
            try:
                signal.signal(signal.SIGINT, sigint_handler)
            except ValueError:
                # `signal.signal` may throw if `threading.main_thread` does
                # not support signals (e.g. embedded interpreter with signals
                # not registered - see gh-91880)
                sigint_handler = None
        else:
            sigint_handler = None
    
        self._interrupt_count = 0
        try:
&gt;           return self._loop.run_until_complete(task)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/runners.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_UnixSelectorEventLoop running=False closed=True debug=False&gt;
future = &lt;Task finished name='Task-995' coro=&lt;TestNormalizationService.test_normalize_async_method.&lt;locals&gt;.run_test() done, de... 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized")&gt;

    def run_until_complete(self, future):
        """Run until the Future is done.
    
        If the argument is a coroutine, it is wrapped in a Task.
    
        WARNING: It would be disastrous to call run_until_complete()
        with the same coroutine twice -- it would wrap it in two
        different Tasks and that can't be good.
    
        Return the Future's result, or raise its exception.
        """
        self._check_closed()
        self._check_running()
    
        new_task = not futures.isfuture(future)
        future = tasks.ensure_future(future, loop=self)
        if new_task:
            # An exception is raised if the future didn't complete, so there
            # is no need to log the "destroy pending task" message
            future._log_destroy_pending = False
    
        future.add_done_callback(_run_until_complete_cb)
        try:
            self.run_forever()
        except:
            if new_task and future.done() and not future.cancelled():
                # The coroutine raised a BaseException. Consume the exception
                # to not log a warning, the caller doesn't have access to the
                # local task.
                future.exception()
            raise
        finally:
            future.remove_done_callback(_run_until_complete_cb)
        if not future.done():
            raise RuntimeError('Event loop stopped before Future completed.')
    
&gt;       return future.result()
               ^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/asyncio/base_events.py:725: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def run_test():
        result = await service.normalize_async("Hello world", language="en")
        assert result.success
&gt;       assert "Hello world" in result.normalized
E       AssertionError: assert 'Hello world' in 'Hello World'
E        +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:156: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_flags" time="0.060"><failure message="AssertionError: assert 'Hello world' in 'Hello World'&#10; +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16b9f97b0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c576c3d0&gt;

    def test_normalize_with_flags(self, service):
        """Test normalization with different flags"""
        result = service.normalize(
            "Hello world",
            language="en",
            remove_stop_words=False,
            preserve_names=True,
            enable_advanced_features=True
        )
    
        assert result.success
&gt;       assert "Hello world" in result.normalized
E       AssertionError: assert 'Hello world' in 'Hello World'
E        +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:171: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_error_handling" time="0.066" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_result_structure" time="0.086" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_with_complex_text" time="0.067" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_russian_complex_text" time="0.056"><failure message="AssertionError: assert 'Анна' in 'Иван Петров Анны Смирнов'&#10; +  where 'Иван Петров Анны Смирнов' = NormalizationResult(normalized='Иван Петров Анны Смирнов', tokens=['Иван', 'Петров', 'Анны', 'Смирнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16b9f5910&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c576c5d0&gt;

    def test_normalize_russian_complex_text(self, service):
        """Test normalization with complex Russian text"""
        text = "Перевод средств на имя Ивана Петрова от Анны Смирновой"
        result = service.normalize(text, language="ru")
    
        assert result.success
        assert "Иван" in result.normalized
        assert "Петров" in result.normalized
&gt;       assert "Анна" in result.normalized
E       AssertionError: assert 'Анна' in 'Иван Петров Анны Смирнов'
E        +  where 'Иван Петров Анны Смирнов' = NormalizationResult(normalized='Иван Петров Анны Смирнов', tokens=['Иван', 'Петров', 'Анны', 'Смирнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:216: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService" name="test_normalize_ukrainian_complex_text" time="0.072"><failure message="AssertionError: assert 'Анна' in 'Іван Петров Анни Смірнов'&#10; +  where 'Іван Петров Анни Смірнов' = NormalizationResult(normalized='Іван Петров Анни Смірнов', tokens=['Іван', 'Петров', 'Анни', 'Смірнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationService object at 0x16ba2ec50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c6f7aed0&gt;

    def test_normalize_ukrainian_complex_text(self, service):
        """Test normalization with complex Ukrainian text"""
        text = "Переказ коштів на ім'я Івана Петрова від Анни Смірнової"
        result = service.normalize(text, language="uk")
    
        assert result.success
        assert "Іван" in result.normalized
        assert "Петров" in result.normalized
&gt;       assert "Анна" in result.normalized
E       AssertionError: assert 'Анна' in 'Іван Петров Анни Смірнов'
E        +  where 'Іван Петров Анни Смірнов' = NormalizationResult(normalized='Іван Петров Анни Смірнов', tokens=['Іван', 'Петров', 'Анни', 'Смірнов'], trace=[TokenT...re_female': 0, 'score_male': 7, 'gap': 7}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_fixed.py:227: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationServiceConfiguration" name="test_service_has_required_attributes" time="0.094" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationServiceConfiguration" name="test_service_has_required_methods" time="0.082" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationServiceConfiguration" name="test_morph_analyzers_initialization" time="0.061" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationServiceConfiguration" name="test_name_dictionaries_initialization" time="0.101" /><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationServiceConfiguration" name="test_diminutive_maps_initialization" time="0.049"><failure message="AssertionError: assert 'en' in {'ru': {'алекс': 'Александр', 'алекса': 'Александра', 'алина': 'Алина', 'алис': 'Алиса', ...}, 'uk': {'алекс': 'Олександр', 'алекса': 'Олександра', 'алина': 'Алина', 'алка': 'Алла', ...}}&#10; +  where {'ru': {'алекс': 'Александр', 'алекса': 'Александра', 'алина': 'Алина', 'алис': 'Алиса', ...}, 'uk': {'алекс': 'Олександр', 'алекса': 'Олександра', 'алина': 'Алина', 'алка': 'Алла', ...}} = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c9412150&gt;.diminutive_maps">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationServiceConfiguration object at 0x16ba3d7f0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c9412150&gt;

    def test_diminutive_maps_initialization(self, service):
        """Test that diminutive maps are properly initialized"""
        assert isinstance(service.diminutive_maps, dict)
        # Should have maps for supported languages
&gt;       assert 'en' in service.diminutive_maps
E       AssertionError: assert 'en' in {'ru': {'алекс': 'Александр', 'алекса': 'Александра', 'алина': 'Алина', 'алис': 'Алиса', ...}, 'uk': {'алекс': 'Олександр', 'алекса': 'Олександра', 'алина': 'Алина', 'алка': 'Алла', ...}}
E        +  where {'ru': {'алекс': 'Александр', 'алекса': 'Александра', 'алина': 'Алина', 'алис': 'Алиса', ...}, 'uk': {'алекс': 'Олександр', 'алекса': 'Олександра', 'алина': 'Алина', 'алка': 'Алла', ...}} = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c9412150&gt;.diminutive_maps

tests/unit/text_processing/test_normalization_service_fixed.py:292: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationResult" name="test_normalization_result_creation" time="0.000"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for NormalizationResult&#10;normalized&#10;  Field required [type=missing, input_value={'original_text': 'test',...ss': True, 'errors': []}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationResult object at 0x16b957b10&gt;

    def test_normalization_result_creation(self):
        """Test NormalizationResult creation"""
        from ai_service.contracts.base_contracts import NormalizationResult
    
&gt;       result = NormalizationResult(
            original_text="test",
            language="en",
            language_confidence=0.9,
            normalized_text="test",
            tokens=["test"],
            trace=[],
            signals=None,
            variants=None,
            embeddings=None,
            decision=None,
            processing_time=0.1,
            success=True,
            errors=[]
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for NormalizationResult
E       normalized
E         Field required [type=missing, input_value={'original_text': 'test',...ss': True, 'errors': []}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/missing

tests/unit/text_processing/test_normalization_service_fixed.py:304: ValidationError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationResult" name="test_normalization_result_error_case" time="0.000"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for NormalizationResult&#10;normalized&#10;  Field required [type=missing, input_value={'original_text': 'test',...errors': ['Test error']}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing">self = &lt;tests.unit.text_processing.test_normalization_service_fixed.TestNormalizationResult object at 0x16b957c50&gt;

    def test_normalization_result_error_case(self):
        """Test NormalizationResult error case"""
        from ai_service.contracts.base_contracts import NormalizationResult
    
&gt;       result = NormalizationResult(
            original_text="test",
            language="en",
            language_confidence=0.9,
            normalized_text="",
            tokens=[],
            trace=[],
            signals=None,
            variants=None,
            embeddings=None,
            decision=None,
            processing_time=0.1,
            success=False,
            errors=["Test error"]
        )
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for NormalizationResult
E       normalized
E         Field required [type=missing, input_value={'original_text': 'test',...errors': ['Test error']}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.11/v/missing

tests/unit/text_processing/test_normalization_service_fixed.py:328: ValidationError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_initialization" time="0.054" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_english_text" time="3.243"><failure message="AssertionError: assert 'Hello world' in 'Hello World'&#10; +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16b957d90&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16ba2f9d0&gt;

    def test_normalize_english_text(self, service):
        """Test normalization of English text"""
        result = service.normalize("Hello world", language="en")
    
        assert result.success
&gt;       assert "Hello world" in result.normalized
E       AssertionError: assert 'Hello world' in 'Hello World'
E        +  where 'Hello World' = NormalizationResult(normalized='Hello World', tokens=['Hello', 'World'], trace=[TokenTrace(token='Hello', role='given'...re_female': 0, 'score_male': 0, 'gap': 0}}], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_old.py:49: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_russian_text" time="0.062"><failure message="AssertionError: assert 'Привет' in ''&#10; +  where '' = NormalizationResult(normalized='', tokens=[], trace=[], errors=[], language='ru', confidence=1.0, original_length=10, ..._core=[], organizations_core=[], persons=[], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba00d60&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5ca1384d0&gt;

    def test_normalize_russian_text(self, service):
        """Test normalization of Russian text"""
        result = service.normalize("Привет мир", language="ru")
    
        assert result.success
&gt;       assert "Привет" in result.normalized
E       AssertionError: assert 'Привет' in ''
E        +  where '' = NormalizationResult(normalized='', tokens=[], trace=[], errors=[], language='ru', confidence=1.0, original_length=10, ..._core=[], organizations_core=[], persons=[], person_gender=None, gender_confidence=None, organizations=[], org_core='').normalized

tests/unit/text_processing/test_normalization_service_old.py:57: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_ukrainian_text" time="0.055" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_tokenize_text_fallback_to_nltk" time="0.045"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba3ef90&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5ca138550&gt;

    def test_tokenize_text_fallback_to_nltk(self, service):
        """Test tokenization fallback to NLTK when SpaCy model not available"""
        # Set spacy model to None to force fallback
&gt;       service.language_configs['en']['spacy_model'] = None
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:71: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_tokenize_text_basic_fallback" time="0.061"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba285a0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c972b2d0&gt;

    def test_tokenize_text_basic_fallback(self, service):
        """Test tokenization basic fallback when neither SpaCy nor NLTK available"""
        # Set both spacy model and NLTK to None to force basic fallback
&gt;       service.language_configs['en']['spacy_model'] = None
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:84: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_remove_stop_words_english" time="0.047"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba286b0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c419afd0&gt;

    def test_remove_stop_words_english(self, service):
        """Test stop words removal for English"""
        # Mock stop words directly in language_configs
&gt;       service.language_configs['en']['stop_words'] = {"the", "is", "a", "an"}
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:95: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_remove_stop_words_russian" time="0.048"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba24b50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4ff4453d0&gt;

    def test_remove_stop_words_russian(self, service):
        """Test stop words removal for Russian"""
        # Mock stop words directly in language_configs
&gt;       service.language_configs['ru']['stop_words'] = {"и", "в", "на", "с"}
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:105: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_remove_stop_words_fallback" time="0.044"><failure message="AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute '_nltk_stopwords'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba24c50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x4896e77d0&gt;

    def test_remove_stop_words_fallback(self, service):
        """Test stop words removal fallback when NLTK not available"""
&gt;       with patch('src.ai_service.layers.normalization.normalization_service._nltk_stopwords', None):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/text_processing/test_normalization_service_old.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c3c8b8b0&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c3c8b8b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute '_nltk_stopwords'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_stemming_english" time="0.046"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16b8bbc50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c61f7b50&gt;

    def test_apply_stemming_english(self, service):
        """Test stemming for English"""
        # Mock the stemmer in the language config directly
        mock_stemmer = Mock()
        mock_stemmer.stem.side_effect = ["run", "jump", "sleep"]
&gt;       service.language_configs['en']['stemmer'] = mock_stemmer
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:127: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_stemming_russian" time="0.050"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16b8bb6b0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c0f50ad0&gt;

    def test_apply_stemming_russian(self, service):
        """Test stemming for Russian"""
        # Mock the stemmer in the language config directly
        mock_stemmer = Mock()
        mock_stemmer.stem.side_effect = ["бег", "прыжк", "сп"]
&gt;       service.language_configs['ru']['stemmer'] = mock_stemmer
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:140: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_stemming_ukrainian" time="0.044"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba12f90&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x56e4fb150&gt;

    def test_apply_stemming_ukrainian(self, service):
        """Test stemming for Ukrainian"""
        # Mock the stemmer in the language config directly
        mock_stemmer = Mock()
        mock_stemmer.stem.side_effect = ["біг", "стрибк", "сп"]
&gt;       service.language_configs['uk']['stemmer'] = mock_stemmer
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:153: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_stemming_fallback" time="0.046"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16ba12a50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x56d925550&gt;

    def test_apply_stemming_fallback(self, service):
        """Test stemming fallback when stemmers not available"""
        # Set stemmer to None in language config
&gt;       service.language_configs['en']['stemmer'] = None
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:164: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_lemmatization_english" time="0.060"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16b93b930&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x56d9256d0&gt;

    def test_apply_lemmatization_english(self, service):
        """Test lemmatization for English"""
        # Mock the SpaCy model in language config directly
        mock_nlp = Mock()
        mock_token1 = Mock()
        mock_token1.lemma_ = "run"
        mock_token1.is_space = False
        mock_token2 = Mock()
        mock_token2.lemma_ = "jump"
        mock_token2.is_space = False
    
        mock_doc = Mock()
        mock_doc.__iter__ = Mock(return_value=iter([mock_token1, mock_token2]))
        mock_nlp.return_value = mock_doc
    
&gt;       service.language_configs['en']['spacy_model'] = mock_nlp
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:187: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_lemmatization_russian" time="0.049"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16b93f650&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5ba95cd50&gt;

    def test_apply_lemmatization_russian(self, service):
        """Test lemmatization for Russian"""
        # Mock the SpaCy model in language config directly
        mock_nlp = Mock()
        mock_token1 = Mock()
        mock_token1.lemma_ = "бегать"
        mock_token1.is_space = False
    
        mock_doc = Mock()
        mock_doc.__iter__ = Mock(return_value=iter([mock_token1]))
        mock_nlp.return_value = mock_doc
    
&gt;       service.language_configs['ru']['spacy_model'] = mock_nlp
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:207: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_apply_lemmatization_fallback" time="0.056"><failure message="AttributeError: 'NormalizationService' object has no attribute 'language_configs'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationService object at 0x16b93f4d0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c4b3a9d0&gt;

    def test_apply_lemmatization_fallback(self, service):
        """Test lemmatization fallback when SpaCy not available"""
        # Set spacy model to None in language config
&gt;       service.language_configs['en']['spacy_model'] = None
        ^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'NormalizationService' object has no attribute 'language_configs'

tests/unit/text_processing/test_normalization_service_old.py:218: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_success" time="0.049" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_without_optional_processing" time="0.059" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_ukrainian_with_forms" time="0.001" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_empty_text" time="0.047" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_whitespace_only" time="0.048" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_unicode_error" time="0.046" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_language_detection_error" time="0.048" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationService" name="test_normalize_processing_error" time="0.052" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceEdgeCases" name="test_normalize_very_long_text" time="0.047" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceEdgeCases" name="test_normalize_special_characters" time="0.053" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceEdgeCases" name="test_normalize_mixed_languages" time="0.066" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceEdgeCases" name="test_normalize_unsupported_language" time="0.050" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceEdgeCases" name="test_ukrainian_normalization_basic" time="0.090" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration" name="test_initialization_without_spacy" time="0.000"><failure message="AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'SPACY_AVAILABLE'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration object at 0x16ba6c2d0&gt;

    def test_initialization_without_spacy(self):
        """Test service initialization when SpaCy is not available"""
&gt;       with patch('src.ai_service.layers.normalization.normalization_service.SPACY_AVAILABLE', False), \
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch('src.ai_service.layers.normalization.normalization_service.nlp_en', None), \
             patch('src.ai_service.layers.normalization.normalization_service.nlp_ru', None), \
             patch('src.ai_service.layers.normalization.normalization_service.nlp_uk', None):

tests/unit/text_processing/test_normalization_service_old.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f04b50&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f04b50&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'SPACY_AVAILABLE'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration" name="test_initialization_without_nltk" time="0.000"><failure message="AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'NLTK_AVAILABLE'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration object at 0x16ba6c410&gt;

    def test_initialization_without_nltk(self):
        """Test service initialization when NLTK is not available"""
&gt;       with patch('src.ai_service.layers.normalization.normalization_service.NLTK_AVAILABLE', False), \
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch('src.ai_service.layers.normalization.normalization_service._nltk_stopwords', None), \
             patch('src.ai_service.layers.normalization.normalization_service.porter_stemmer', None):

tests/unit/text_processing/test_normalization_service_old.py:570: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f05230&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f05230&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'NLTK_AVAILABLE'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration" name="test_initialization_minimal_dependencies" time="0.001"><failure message="AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'SPACY_AVAILABLE'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration object at 0x16ba00fc0&gt;

    async def test_initialization_minimal_dependencies(self):
        """Test service initialization with minimal dependencies"""
&gt;       with patch('src.ai_service.layers.normalization.normalization_service.SPACY_AVAILABLE', False), \
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch('src.ai_service.layers.normalization.normalization_service.NLTK_AVAILABLE', False):

tests/unit/text_processing/test_normalization_service_old.py:579: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f057b0&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f057b0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'SPACY_AVAILABLE'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration" name="test_cache_functionality" time="0.001"><failure message="AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'nlp_en'">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationServiceConfiguration object at 0x16ba010f0&gt;

    async def test_cache_functionality(self):
        """Test caching functionality"""
&gt;       with patch('src.ai_service.layers.normalization.normalization_service.nlp_en'), \
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch('src.ai_service.layers.normalization.normalization_service.nlp_ru'), \
             patch('src.ai_service.layers.normalization.normalization_service.nlp_uk'):

tests/unit/text_processing/test_normalization_service_old.py:606: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f05bd0&gt;

    def __enter__(self):
        """Perform the patch."""
        if self.is_started:
            raise RuntimeError("Patch is already started")
    
        new, spec, spec_set = self.new, self.spec, self.spec_set
        autospec, kwargs = self.autospec, self.kwargs
        new_callable = self.new_callable
        self.target = self.getter()
    
        # normalise False to None
        if spec is False:
            spec = None
        if spec_set is False:
            spec_set = None
        if autospec is False:
            autospec = None
    
        if spec is not None and autospec is not None:
            raise TypeError("Can't specify spec and autospec")
        if ((spec is not None or autospec is not None) and
            spec_set not in (True, None)):
            raise TypeError("Can't provide explicit spec_set *and* spec or autospec")
    
&gt;       original, local = self.get_original()
                          ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0x5c2f05bd0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'src.ai_service.layers.normalization.normalization_service' from '/Users/dariapavlova/Desktop/ai-service/src/ai_service/layers/normalization/normalization_service.py'&gt; does not have the attribute 'nlp_en'

/opt/homebrew/Cellar/python@3.13/3.13.7/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationResult" name="test_normalization_result_creation" time="0.000" /><testcase classname="tests.unit.text_processing.test_normalization_service_old.TestNormalizationResult" name="test_normalization_result_error_case" time="0.000"><failure message="AttributeError: 'NormalizationResult' object has no attribute 'error'. Did you mean: 'errors'?">self = &lt;tests.unit.text_processing.test_normalization_service_old.TestNormalizationResult object at 0x16ba6c690&gt;

    def test_normalization_result_error_case(self):
        """Test NormalizationResult for error scenarios"""
        result = NormalizationResult(
            success=False,
            normalized="Test text",
            tokens=[],
            trace=[],
            language="unknown",
            confidence=0.0,
            original_length=9,
            normalized_length=9,
            token_count=0,
            processing_time=0.05,
            errors=["Processing failed"]
        )
    
        assert result.success == False
&gt;       assert result.error == "Processing failed"
               ^^^^^^^^^^^^

tests/unit/text_processing/test_normalization_service_old.py:675: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = NormalizationResult(normalized='Test text', tokens=[], trace=[], errors=['Processing failed'], language='unknown', con....05, success=False, persons_core=None, organizations_core=None, persons=[], person_gender=None, gender_confidence=None)
item = 'error'

    def __getattr__(self, item: str) -&gt; Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
&gt;                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'NormalizationResult' object has no attribute 'error'. Did you mean: 'errors'?

venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError</failure></testcase><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_org_acronyms_are_tagged_as_unknown" time="0.050" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_org_acronyms_not_in_normalized_output" time="0.050" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_person_tokens_survive" time="0.054" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_various_org_acronyms_are_filtered" time="0.050" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_org_acronyms_case_insensitive" time="0.051" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_org_acronyms_excluded_from_positional_fallbacks" time="0.073" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_mixed_content_with_org_acronyms" time="0.057" /><testcase classname="tests.unit.text_processing.test_org_acronyms_filter.TestOrgAcronymsFilter" name="test_org_acronyms_constant_contains_expected_values" time="0.049" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_multi_initial_splitting" time="0.064" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_triple_initial_splitting" time="0.055" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_enhanced_patronymic_patterns_male" time="0.063" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_enhanced_patronymic_patterns_female" time="0.064" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_enhanced_surname_patterns_enko" time="0.070" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_enhanced_surname_patterns_ov_ova" time="0.072" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_enhanced_surname_patterns_sky_ska" time="0.100" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_new_surname_patterns_yan" time="0.069" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_new_surname_patterns_dze" time="1.746" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_conservative_unknown_tagging" time="0.053" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_positional_heuristics_still_work" time="0.052" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_integration_with_organization_roles" time="0.048" /><testcase classname="tests.unit.text_processing.test_role_tagging_extended.TestExtendedRoleTagging" name="test_sentence_with_org_and_people" time="0.097" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_aggressive_normalization_sao_paulo" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_cyrillic_processing" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_empty_text_handling" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_none_text_handling" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_complex_mappings_applied" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_confidence_calculation" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_batch_normalization" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_similarity_score" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_encoding_issues_detection" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_final_cleanup" time="0.000"><failure message="AssertionError: assert 'Multiple spaces' == '  Multiple   spaces  \t\n  '&#10;  &#10;  -   Multiple   spaces  &#09;&#10;  ? --         --      ----&#10;  + Multiple spaces&#10;  -">self = &lt;tests.unit.text_processing.test_unicode_service.TestUnicodeService object at 0x16ba98500&gt;
unicode_service = &lt;src.ai_service.layers.unicode.unicode_service.UnicodeService object at 0x56ec877d0&gt;

    def test_final_cleanup(self, unicode_service):
        """Test final text cleanup"""
        # Arrange
        messy_text = "  Multiple   spaces  \t\n  "
    
        # Act
        result = unicode_service.normalize_text(messy_text)
    
        # Assert
        normalized = result['normalized']
        # UnicodeService doesn't perform space cleanup or case conversion - that's done by other services
&gt;       assert normalized == "  Multiple   spaces  \t\n  "  # Should be unchanged by UnicodeService
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'Multiple spaces' == '  Multiple   spaces  \t\n  '
E         
E         -   Multiple   spaces  	
E         ? --         --      ----
E         + Multiple spaces
E         -

tests/unit/text_processing/test_unicode_service.py:182: AssertionError</failure></testcase><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_preserve_chars_functionality" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_unicode_normalization_nfd_nfkc" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_ascii_folding_failure_handling" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_unicode_normalization_failure_handling" time="0.001" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_length_metadata" time="0.000" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_case_normalization" time="0.001" /><testcase classname="tests.unit.text_processing.test_unicode_service.TestUnicodeService" name="test_german_umlauts_handling" time="0.000" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_transliteration_variants_grigoriy" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_compound_surname_processing" time="0.026" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_basic_transliteration_functionality" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_multiple_transliteration_standards" time="0.026" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_phonetic_variants_generation" time="0.023" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_visual_similarities_generation" time="0.028" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_typo_variants_generation" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_comprehensive_variants_generation" time="0.029" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_empty_text_handling" time="0.024" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_none_text_handling" time="0.023" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_max_variants_limit" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_language_specific_processing" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_find_best_matches_functionality" time="0.024" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_similarity_calculation" time="0.024" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_keyboard_layout_variants" time="0.027" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_morphological_variants_integration" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_morphological_variants_mocked" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_processing_statistics" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_duplicate_removal" time="0.026" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_case_preservation_and_normalization" time="0.025" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_special_characters_handling" time="0.027" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_performance_with_long_names" time="0.027" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_error_handling_in_transliteration" time="0.024" /><testcase classname="tests.unit.text_processing.test_variant_generation_service.TestVariantGenerationService" name="test_variant_scores_match_config" time="0.025" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_ukrainian_apostrophes_unification" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_compound_names_normalization" time="0.001" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_irish_names_apostrophes" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_company_quotes_unification" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_mixed_apostrophes_in_text" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_preserve_meaningful_punctuation" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_confidence_calculation_with_replacements" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_batch_normalization_consistency" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_similarity_after_normalization" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_encoding_recovery_with_apostrophes" time="0.000" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_performance_with_many_replacements" time="0.001" /><testcase classname="tests.unit.unicode.test_apostrophe_normalization.TestApostropheNormalization" name="test_edge_cases_empty_and_none" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_initialization" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalize_text_basic" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalize_text_cyrillic_mapping" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalize_text_latin_diacritics" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalize_text_aggressive_mode" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalize_text_mixed_scripts" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_unicode_nfc_normalization" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_encoding_recovery" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_whitespace_normalization" time="0.001" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_invisible_characters_removal" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_homoglyph_handling" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_preserve_cyrillic_characters" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_edge_cases" time="0.001" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_long_text_handling" time="0.005" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_character_mapping_completeness" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalization_consistency" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_normalization_with_numbers_and_punctuation" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_different_normalization_forms" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeService" name="test_rtl_and_bidi_text" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeServiceIntegration" name="test_real_world_name_normalization" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeServiceIntegration" name="test_payment_text_normalization" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeServiceIntegration" name="test_normalization_preserves_structure" time="0.000" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeServiceIntegration" name="test_aggressive_vs_conservative_mode[True]" time="0.001" /><testcase classname="tests.unit.unicode.test_unicode_service_comprehensive.TestUnicodeServiceIntegration" name="test_aggressive_vs_conservative_mode[False]" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_basic_set_get" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_get_nonexistent_key" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_lru_eviction" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_ttl_expiration" time="1.102" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_statistics" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_get_or_set_cache_hit" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_get_or_set_cache_miss" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_clear_cache" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_exists_method" time="0.000" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_exists_with_expired_key" time="1.103" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_touch_method" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_touch_nonexistent_key" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_cleanup_expired" time="1.106" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_set_max_size" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_get_keys" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_memory_usage_estimation" time="0.001" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_generate_key_method" time="0.003" /><testcase classname="tests.unit.utilities.test_cache_service.TestCacheService" name="test_lru_logic_with_access" time="0.001" /><testcase classname="tests.unit.utilities.test_canary_overfit.TestCanaryOverfit" name="test_context_words_never_become_names" time="0.073"><failure message="AssertionError: Expected name 'п.і.' not found in normalized output: П. І. Коваленко Петросян&#10;assert 'п.і.' in 'п. і. коваленко петросян'">self = &lt;tests.unit.utilities.test_canary_overfit.TestCanaryOverfit object at 0x16ba6ed50&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16bb0c8d0&gt;

    def test_context_words_never_become_names(self, service):
        """Test that context words like 'та', 'и', 'and', 'разом', 'працюють' never become given/surname"""
        # Test case from the requirement: "П.І. Коваленко, ТОВ "ПРИВАТБАНК" та Петросян працюють разом"
        text = 'П.І. Коваленко, ТОВ "ПРИВАТБАНК" та Петросян працюють разом'
        result = service.normalize(text, language='uk', preserve_names=True)
    
        # Check that context words are not in normalized output
        normalized = result.normalized.lower()
        context_words = ['та', 'працюють', 'разом']
    
        for context_word in context_words:
            assert context_word not in normalized, f"Context word '{context_word}' should not appear in normalized output: {result.normalized}"
    
        # Check that only actual names are preserved
        expected_names = ['п.і.', 'коваленко', 'петросян']
        for name in expected_names:
&gt;           assert name in normalized, f"Expected name '{name}' not found in normalized output: {result.normalized}"
E           AssertionError: Expected name 'п.і.' not found in normalized output: П. І. Коваленко Петросян
E           assert 'п.і.' in 'п. і. коваленко петросян'

tests/unit/utilities/test_canary_overfit.py:34: AssertionError</failure></testcase><testcase classname="tests.unit.utilities.test_canary_overfit.TestCanaryOverfit" name="test_ukrainian_context_words" time="0.057"><failure message="AssertionError: Context word 'і' should not appear in normalized output: Іван І. Петро Коваленко&#10;assert 'і' not in 'іван і. петро коваленко'&#10;  &#10;  'і' is contained here:&#10;    іван і. петро коваленко&#10;  ? +">self = &lt;tests.unit.utilities.test_canary_overfit.TestCanaryOverfit object at 0x16ba6e850&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x16baf3ed0&gt;

    def test_ukrainian_context_words(self, service):
        """Test Ukrainian context words are never treated as names"""
        context_words = ['та', 'і', 'або', 'але', 'щоб', 'як', 'що', 'хто', 'де', 'коли', 'чому']
        context_words.extend(['працюють', 'працює', 'працюю', 'працюємо', 'працюєте', 'працювати'])
        context_words.extend(['разом', 'окремо', 'тут', 'там', 'тепер', 'зараз'])
        context_words.extend(['дуже', 'досить', 'майже', 'зовсім', 'повністю', 'частково'])
        context_words.extend(['добре', 'погано', 'краще', 'гірше', 'найкраще', 'найгірше'])
        context_words.extend(['може', 'можна', 'можливо', 'ймовірно', 'звичайно'])
        context_words.extend(['так', 'ні', 'можливо'])
    
        for context_word in context_words:
            # Test each context word in a sentence with actual names
            text = f'Іван {context_word} Петро Коваленко'
            result = service.normalize(text, language='uk', preserve_names=True)
    
            # Context word should not appear in normalized output
&gt;           assert context_word not in result.normalized.lower(), f"Context word '{context_word}' should not appear in normalized output: {result.normalized}"
E           AssertionError: Context word 'і' should not appear in normalized output: Іван І. Петро Коваленко
E           assert 'і' not in 'іван і. петро коваленко'
E             
E             'і' is contained here:
E               іван і. петро коваленко
E             ? +

tests/unit/utilities/test_canary_overfit.py:55: AssertionError</failure></testcase><testcase classname="tests.unit.utilities.test_canary_overfit.TestCanaryOverfit" name="test_russian_context_words" time="0.056"><failure message="AssertionError: Context word 'и' should not appear in normalized output: Иван Петр Коваленко&#10;assert 'и' not in 'иван петр коваленко'&#10;  &#10;  'и' is contained here:&#10;    иван петр коваленко&#10;  ? +">self = &lt;tests.unit.utilities.test_canary_overfit.TestCanaryOverfit object at 0x16ba029e0&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5c6cca4d0&gt;

    def test_russian_context_words(self, service):
        """Test Russian context words are never treated as names"""
        context_words = ['и', 'или', 'но', 'чтобы', 'как', 'что', 'кто', 'где', 'когда', 'почему']
        context_words.extend(['работают', 'работает', 'работаю', 'работаем', 'работаете', 'работать'])
        context_words.extend(['вместе', 'отдельно', 'здесь', 'там', 'теперь', 'сейчас'])
        context_words.extend(['очень', 'довольно', 'почти', 'совсем', 'полностью', 'частично'])
        context_words.extend(['хорошо', 'плохо', 'лучше', 'хуже', 'лучший', 'худший'])
        context_words.extend(['может', 'можно', 'возможно', 'вероятно', 'обычно'])
        context_words.extend(['да', 'нет', 'возможно'])
    
        for context_word in context_words:
            # Test each context word in a sentence with actual names
            text = f'Иван {context_word} Петр Коваленко'
            result = service.normalize(text, language='ru', preserve_names=True)
    
            # Context word should not appear in normalized output
&gt;           assert context_word not in result.normalized.lower(), f"Context word '{context_word}' should not appear in normalized output: {result.normalized}"
E           AssertionError: Context word 'и' should not appear in normalized output: Иван Петр Коваленко
E           assert 'и' not in 'иван петр коваленко'
E             
E             'и' is contained here:
E               иван петр коваленко
E             ? +

tests/unit/utilities/test_canary_overfit.py:78: AssertionError</failure></testcase><testcase classname="tests.unit.utilities.test_canary_overfit.TestCanaryOverfit" name="test_english_context_words" time="0.054" /><testcase classname="tests.unit.utilities.test_canary_overfit.TestCanaryOverfit" name="test_mixed_language_context_words" time="0.049"><failure message="AssertionError: Context word 'and' should not appear in normalized output: П. І. Коваленко And Петросян Work Together&#10;assert 'and' not in 'п. і. ковал...ork together'&#10;  &#10;  'and' is contained here:&#10;    п. і. коваленко and петросян work together&#10;  ?                 +++">self = &lt;tests.unit.utilities.test_canary_overfit.TestCanaryOverfit object at 0x16baeef90&gt;
service = &lt;ai_service.layers.normalization.normalization_service.NormalizationService object at 0x5ca177e50&gt;

    def test_mixed_language_context_words(self, service):
        """Test mixed language context words are never treated as names"""
        # Test case with mixed Ukrainian and English context words
        text = 'П.І. Коваленко and ТОВ "ПРИВАТБАНК" та Петросян work together разом'
        result = service.normalize(text, language='uk', preserve_names=True)
    
        # Context words should not appear in normalized output
        context_words = ['and', 'та', 'work', 'together', 'разом']
        normalized = result.normalized.lower()
    
        for context_word in context_words:
&gt;           assert context_word not in normalized, f"Context word '{context_word}' should not appear in normalized output: {result.normalized}"
E           AssertionError: Context word 'and' should not appear in normalized output: П. І. Коваленко And Петросян Work Together
E           assert 'and' not in 'п. і. ковал...ork together'
E             
E             'and' is contained here:
E               п. і. коваленко and петросян work together
E             ?                 +++

tests/unit/utilities/test_canary_overfit.py:119: AssertionError</failure></testcase><testcase classname="tests.unit.utilities.test_canary_overfit.TestCanaryOverfit" name="test_positional_heuristics_blocked_for_context_words" time="0.054" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestUnicodeServiceEdgeCases" name="test_normalize_text_with_homoglyphs" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestUnicodeServiceEdgeCases" name="test_normalize_text_with_zero_width_characters" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestUnicodeServiceEdgeCases" name="test_normalize_text_with_surrogate_pairs" time="0.001" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestUnicodeServiceEdgeCases" name="test_normalize_text_with_combining_characters" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestUnicodeServiceEdgeCases" name="test_normalize_text_with_malformed_utf8" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestUnicodeServiceEdgeCases" name="test_normalize_text_with_rtl_text" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestLanguageDetectionEdgeCases" name="test_detect_language_very_short_text" time="0.011" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestLanguageDetectionEdgeCases" name="test_detect_language_numbers_only" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestLanguageDetectionEdgeCases" name="test_detect_language_symbols_only" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestLanguageDetectionEdgeCases" name="test_detect_language_mixed_scripts" time="0.005" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestLanguageDetectionEdgeCases" name="test_detect_language_code_snippets" time="0.007" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestLanguageDetectionEdgeCases" name="test_detect_language_with_html_tags" time="0.009" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCacheServiceEdgeCases" name="test_cache_with_complex_objects" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCacheServiceEdgeCases" name="test_cache_key_collision_with_similar_keys" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCacheServiceEdgeCases" name="test_cache_overflow_handling" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCacheServiceEdgeCases" name="test_cache_with_zero_ttl" time="0.013" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCacheServiceEdgeCases" name="test_cache_with_negative_ttl" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCustomExceptionHandling" name="test_validation_api_error_creation" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCustomExceptionHandling" name="test_validation_api_error_with_details" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCustomExceptionHandling" name="test_internal_server_error_creation" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCustomExceptionHandling" name="test_service_unavailable_error_creation" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestCustomExceptionHandling" name="test_exception_chaining" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestResourceCleanupAndMemoryManagement" name="test_service_cleanup_on_deletion" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestResourceCleanupAndMemoryManagement" name="test_large_object_caching_memory_usage" time="0.000" /><testcase classname="tests.unit.utilities.test_edge_cases_comprehensive.TestResourceCleanupAndMemoryManagement" name="test_concurrent_access_resource_safety" time="0.064" /><testcase classname="tests.unit.utilities.test_flags_ab_strict" name="test_enable_advanced_features_false_no_morph" time="0.055" /><testcase classname="tests.unit.utilities.test_flags_ab_strict" name="test_preserve_names_false_splits_apostrophe" time="0.054" /><testcase classname="tests.unit.utilities.test_flags_ab_strict" name="test_remove_stop_words_false_keeps_stopwords" time="0.046" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_valid_text_processing" time="0.002" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_homoglyph_replacement" time="0.000"><failure message="AssertionError: assert 'Pаvlоv' == 'Pavlov'&#10;  &#10;  - Pavlov&#10;  + Pаvlоv">self = &lt;tests.unit.utilities.test_input_validation.TestInputValidator object at 0x16ba6fd90&gt;
validator = &lt;src.ai_service.utils.input_validation.InputValidator object at 0x5befd2490&gt;

    def test_homoglyph_replacement(self, validator):
        """Test homoglyph character replacement"""
        # Arrange
        text_with_homoglyphs = "Pаvlоv"  # Contains Cyrillic 'а' and 'о'
    
        # Act
        result = validator.validate_and_sanitize(text_with_homoglyphs, remove_homoglyphs=True)
    
        # Assert
        assert result.is_valid is True
&gt;       assert result.sanitized_text == "Pavlov"  # Should be normalized
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError: assert 'Pаvlоv' == 'Pavlov'
E         
E         - Pavlov
E         + Pаvlоv

tests/unit/utilities/test_input_validation.py:48: AssertionError</failure></testcase><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_zero_width_character_removal" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_control_character_removal" time="0.001" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_suspicious_pattern_detection" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_strict_mode_blocking" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_text_length_limiting" time="0.001" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_empty_text_handling" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_unicode_normalization" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_sanctions_input_validation" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_sanctions_input_missing_required_field" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_sanctions_input_with_malicious_content" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_suspicion_analysis_high_zero_width" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_suspicion_analysis_high_homoglyph_ratio" time="0.000"><failure message="assert False is True">self = &lt;tests.unit.utilities.test_input_validation.TestInputValidator object at 0x16ba6aa90&gt;
validator = &lt;src.ai_service.utils.input_validation.InputValidator object at 0x5c18881f0&gt;

    def test_suspicion_analysis_high_homoglyph_ratio(self, validator):
        """Test suspicion analysis for high homoglyph ratio"""
        # Arrange
        homoglyph_text = "Nаmе"  # 50% homoglyphs (Cyrillic а, е)
    
        # Act
        analysis = validator.is_text_suspicious(homoglyph_text)
    
        # Assert
&gt;       assert analysis['is_suspicious'] is True
E       assert False is True

tests/unit/utilities/test_input_validation.py:207: AssertionError</failure></testcase><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_non_string_input_raises_error" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_whitespace_normalization" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_url_encoding_detection" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_html_entity_detection" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_unicode_normalization_failure" time="0.001" /><testcase classname="tests.unit.utilities.test_input_validation.TestInputValidator" name="test_input_validator_global_instance" time="0.000" /><testcase classname="tests.unit.utilities.test_input_validation.TestValidationResult" name="test_validation_result_creation" time="0.000" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_russian_names_no_internal_duplicates" time="0.001" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_ukrainian_names_no_internal_duplicates" time="0.001" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_english_names_no_internal_duplicates" time="0.000" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_no_cross_dictionary_duplicates" time="0.000" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_additional_english_names_consistency" time="0.000" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_dictionaries_statistics" time="0.000" /><testcase classname="tests.unit.utilities.test_name_dictionaries_validation.TestNameDictionariesValidation" name="test_name_data_structure" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_unified_pattern_creation" time="0.001" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_generate_patterns_basic" time="0.001" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_generate_patterns_empty_text" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_generate_patterns_ukrainian" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_generate_patterns_compound_name" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_pattern_confidence_scoring" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_pattern_types_variety" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_pattern_metadata_inclusion" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_special_characters_handling" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_case_sensitivity_handling" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_multilingual_pattern_generation" time="0.001" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_performance_with_long_names" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_error_handling_invalid_language" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_pattern_uniqueness" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_confidence_ordering" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_empty_and_whitespace_handling" time="0.000" /><testcase classname="tests.unit.utilities.test_pattern_service.TestUnifiedPatternService" name="test_numeric_and_special_content" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_initialization" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_initialize_success" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_initialize_failure" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_not_initialized" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_success" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_invalid_input" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_exception_handling" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_empty_text" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_long_text" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_and_sanitize_none_input" time="0.000" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_with_risk_levels" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_with_blocked_patterns" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_validate_with_warnings" time="0.001" /><testcase classname="tests.unit.validation.test_validation_service.TestValidationService" name="test_interface_compliance" time="0.006" /></testsuite></testsuites>